--
-- PostgreSQL database dump
--

-- Dumped from database version 15.1
-- Dumped by pg_dump version 15.1

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: schema; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA schema;


ALTER SCHEMA schema OWNER TO postgres;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: comment; Type: TABLE; Schema: schema; Owner: postgres
--

CREATE TABLE schema.comment (
    comment_id bigint,
    comment_binding bigint,
    user_id bigint,
    comment_body text,
    comment_create_time timestamp without time zone,
    comment_is_reply boolean,
    comment_permission smallint
);


ALTER TABLE schema.comment OWNER TO postgres;

--
-- Name: post; Type: TABLE; Schema: schema; Owner: postgres
--

CREATE TABLE schema.post (
    post_id bigint,
    post_body text,
    post_create_time timestamp without time zone,
    post_access_time timestamp without time zone,
    post_modify_time timestamp without time zone,
    post_permission smallint,
    post_title text,
    user_id bigint
);


ALTER TABLE schema.post OWNER TO postgres;

--
-- Name: token; Type: TABLE; Schema: schema; Owner: postgres
--

CREATE TABLE schema.token (
    token_hash text,
    token_create_time timestamp without time zone,
    token_access_time timestamp without time zone,
    token_expire_time timestamp without time zone
);


ALTER TABLE schema.token OWNER TO postgres;

--
-- Name: user; Type: TABLE; Schema: schema; Owner: postgres
--

CREATE TABLE schema."user" (
    user_id bigint,
    user_name text,
    user_pwd_hash text,
    user_create_time timestamp without time zone,
    user_email text,
    user_permission smallint,
    user_access_time timestamp without time zone
);


ALTER TABLE schema."user" OWNER TO postgres;

--
-- Data for Name: comment; Type: TABLE DATA; Schema: schema; Owner: postgres
--

COPY schema.comment (comment_id, comment_binding, user_id, comment_body, comment_create_time, comment_is_reply, comment_permission) FROM stdin;
30016	30015	1001	M1 Max虽然带来了更强的GPU性能和内存带宽，但它在同负载下的能耗比不如Pro优秀（Pro在同场景下能比它多出3至4小时的续航）。另外这一代的单核性能没有提升，我对这一点感到稍稍失望。macOS虽然支持运行iOS程序，但苹果禁用了侧载，导致这些应用的安装不是很方便，但仍可用。	2021-11-23 10:13:39	t	12
30021	30020	1001	已修改，感谢指正	2022-03-09 17:54:46	t	12
30004	12431	1006	爷爷王来啦~	2020-09-27 15:55:57	f	4
30014	12437	1004	我想知道这段网址是什么？	2021-10-23 10:33:10	f	4
30025	30023	1001	非常有价值的建议，我会开发有关功能的。	2022-03-29 09:09:50	t	12
30013	12384	1001	哈喽！欢迎评论~！	2017-07-16 07:12:00	f	12
30008	12366	1010	话说我也没用那插件了..\r\n感觉地址的话中文的不太好… 可以改成拼音或翻译成英文	2017-08-05 06:30:00	f	4
30001	12431	1005	来自雅爱方雏的钦定！雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎雅虎！	2020-09-21 22:52:28	f	4
30024	30022	1001	每月评论通常会在当月末或下月初发行。	2022-03-29 09:07:11	t	12
30002	30001	1007	雅子我爱你呀~哼哼哼啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊	2020-09-21 22:53:11	t	4
30020	12477	1009	注解有错误，左幺元公式错了	2022-03-08 23:13:29	f	4
30027	12491	1004	你的第八期评论发了两遍，望悉知	2022-04-28 18:45:21	f	4
30012	12384	1005	支持一下。。。	2017-12-09 13:53:00	f	4
30018	12455	1007	henghenghengaAAAAAAAAAAAAAAAAA	2021-12-31 08:24:07	f	4
30010	30009	1001	emmmmmm……..	2017-08-05 13:26:00	t	12
30023	12496	1004	这个评论系统居然不能换行？难不成要加</br>才可以换行？markdown表情呢​:poodle:补充补充[doge]	2022-03-28 15:53:01	f	4
30011	30008	1001	感觉中文的用户体验好一些吧，不影响什么速度也方便我维护	2017-08-05 13:30:00	t	12
30000	12431	1001	来自小品的钦定！	2020-09-21 22:49:22	f	12
30015	12456	1004	可以再详细讲一下关于MacBook Pro的缺点嘛？	2021-11-21 21:43:03	f	4
30009	12366	1010	(评论是要审核么2333)\r\n还有 既然都用pjax了就顺便加个ajax评论吧…\r\n而且我用的是jquery.pjax.js(滑稽)	2017-08-05 06:32:00	f	4
30026	30018	1001	下北泽特有评论	2022-03-29 09:11:05	t	12
30019	12383	1008	Hi,我是xiaoyu，我的博客即将搬迁，url为：www.rakkaus.space	2022-03-06 20:44:36	f	4
30003	30002	1001	我看你是欠日	2020-09-21 22:54:19	t	12
30022	12496	1004	>受限于各类因素，每月评论将按需发行。\n\n意思就是第十期这个月不发了？	2022-03-28 15:50:13	f	4
27365567939743744	12503	1004	仅靠生存本身是不能保证生存的，发展是生存的最好保障	2022-10-30 09:23:59.298071	f	0
29455234048724992	12508	1011	哼哼哼啊啊啊啊阿	2022-11-22 10:58:20.197338	f	0
29455234048724993	29455234048724992	1001	_????_	2022-11-22 17:13:38	t	0
33374004223938560	12504	1011	test	2023-01-04 17:05:30.664982	f	0
\.


--
-- Data for Name: post; Type: TABLE DATA; Schema: schema; Owner: postgres
--

COPY schema.post (post_id, post_body, post_create_time, post_access_time, post_modify_time, post_permission, post_title, user_id) FROM stdin;
12476	# Monad\n\n单子\n\n## 概要\n\n自函子范畴上的幺半群（逃\n\n## 什么是Monad\n\n如果一个应用函子拥有`unit`函数和`bind`函数，那么它就是**单子**（Monad）。所有的Monad都是应用函子。\n\n如果你已经了解函子和应用函子，那么理解Monad其实并不困难：\n\n```Kotlin\n@Suppress("unchecked_cast")\ninterface Monad<T : Kind<T, *>> : Applicative<T> {\n    override fun <A> A.pure(): Kind<T, A> = this.unit()\n    override fun <A, B> Kind<T, A>.ap(af: Kind<T, (A) -> B>): Kind<T, B> = this.ap(af)\n\n    fun <A> A.unit(): Kind<T, A> = pure()\n\n    fun <A, B> Kind<T, A>.bind(mf: (A) -> Kind<T, B>): Kind<T, B>\n}\n```\n\n`unit`用于包装一个值，其实它等效于`pure`，只是名称不同而已。  \n`bind`接收一个函数，与之前不同的是，该函数接收一个未被包装的值，并返回一个被包装的值。\n\n另外，所有的Monad都具有一个奇妙的特性：把函数通过`bind`应用到Monad的结果总是等于把函数通过`fmap`应用到Monad然后将结果展平(`join`)（因为结果是一个嵌套的Monad）：\n\n```Kotlin\nfun <A> Kind<T, Kind<T, A>>.join(): Kind<T, A>\n\nfun <A, B> Kind<T, A>.bind(mf: (A) -> Kind<T, B>): Kind<T, B> = this.fmap(mf).join()\n```\n\n这一特性可以帮助我们在不知道如何实现`bind`的情况下间接的实现它，因为通常很容易指出如何展平一个Monad。\n\n## 单子定律\n\n如果实现以上接口，那么所有的Monad都满足以下定律：\n\n* 左幺元\n\n    ```Kotlin\n    m.unit().bind(mf) == mf(m)\n    ```\n\n* 右幺元\n  \n    ```Kotlin\n    m.bind{ x -> x.unit() } == m\n    ```\n\n* 结合律\n\n    ```Kotlin\n    (m.bind(mf1)).bind(mf2) == m.bind{ x -> mf1(x).bind(mf2) }\n    ```\n\n可以发现，Monad具有Monoid的一些特征。  \n其实，迄今我们讨论的Functor都是自函子，自然Monad也是。  \n自然地，Monad就是自函子范畴上的幺半群了（是的，这是句废话233\n\n## 应用\n\nMonad这类代数结构的独特特点决定了它很适合抽象副作用，通过使用Monad，我们能将副作用隔离在Monad上下文中，从而最大限度地避免其对程序的其他部分产生不良影响。\n\nMaybe是一个典型的Monad，下面我们以Maybe为例看看Monad的应用$^{*1}$:\n\n```Kotlin\n@Suppress("unchecked_cast")\ninterface MaybeMonad<V> : Monad<MaybeMonad<*>>, Kind<MaybeMonad<*>, V> {\n\n    override fun <A> A.unit(): Kind<MaybeMonad<*>, A> = Just<A>(this)\n\n    override fun <A, B> Kind<MaybeMonad<*>, A>.bind(mf: (A) -> Kind<MaybeMonad<*>, B>): Kind<MaybeMonad<*>, B> {\n        val mb = when (val ma = this) {\n            is Just<A> -> mf(ma.value)\n            is Nothing -> Nothing<B>()\n            else -> Nothing<B>()\n        }\n        return mb as Kind<MaybeMonad<*>, B>\n    }\n}\n\nobject WithMaybeMonad : MaybeMonad<Any>\nsealed class Maybe<V> : MaybeMonad<V>, Kind<MaybeMonad<*>, V> {\n    class Just<V>(val value: V) : Maybe<V>()\n    class Nothing<V> : Maybe<V>()\n}\n```\n\n`Maybe<V>`类型有两种，`Just<V>`反映了正确的结果，而`Nothing<V>`则代表出现了错误。\n\n假设现在你开发的程序从某用户那里得到一串数字输入，该程序计算它们的和。但该用户在这串输入中不小心夹杂了一个字符串（会导致运算错误！），显然你不希望用户在这个情境中收到一串错误代码或是发现程序崩溃了，那么你就可以使用`Maybe<Sum>`来表达这种可能发生错误的计算结果$^{*2}$：\n\n```Kotlin\n    val J1 = Just<Sum>(Sum(1))\n    val J2 = Just<Sum>(Sum(2))\n    val ERR = Nothing<Sum>()\n    val J3 = Just<Sum>(Sum(3))\n\n    val succResult = WithMaybeMonad.run {//正确的计算流\n        J1.bind { x: Sum -> J2.bind { y: Sum -> J3.bind { z: Sum -> Just<Sum>(x.mappend(y.mappend(z))) } } }\n    }\n    val errResult = WithMaybeMonad.run {//发生错误的计算流\n        J1.bind { x: Sum -> ERR.bind { y: Sum -> J3.bind { z: Sum -> Just<Sum>(x.mappend(y.mappend(z))) } } }\n    }\n\n    when (succResult) {//6\n        is Just<Sum> -> println(succResult.value.value)\n        is Nothing -> println("Noting")\n    }\n    when (errResult) {//Nothing\n        is Just<Sum> -> println(errResult.value.value)\n        is Nothing<Sum> -> println("Noting")\n    }\n```\n\n如此，错误就完全由Maybe进行托管了，你不需要关注哪一部分出现了错误（并加上相应的错误处理逻辑或是设定一个特殊的值来表示错误），而只需要在最终取用计算结果的时候对其进行判断即可。\n\n你可能会说，我一开始判断用户输入是否合法不就行了吗？上述讨论的其实是一种函数式编程的思维方式，函数式编程使用类型来代替命令式编程中异常处理(即`try...catch...`块)，这种方式的好处是能够始终把错误隔离在类型中，从而防止错误的影响传播到其他地方（比如让程序崩溃）。这样的方式在命令式编程中是存在的（比如Java8引入的`Optional<T>`就是为了用类型代替错误的），但尚未得到广泛应用。\n\n## Playground\n\n没作业。\n\n### 注解\n\n1. `Maybe<V>`仍满足单子定律，读者可以自行验证。\n2. 幺半群`Sum`出现在Monoid那节中，由于当时使用Java表述，现给出其Kotlin表述：\n\n    ```Kotlin\n    interface Semigroup<T> {\n        fun sappend(sb: T): T\n    }\n    interface Monoid<T> : Semigroup<T> {\n        fun mempty(): T\n\n        fun mappend(mb: T): T {\n            val ma = this\n            return ma.sappend(mb)\n        }\n    }\n\n    abstract class SumMonoid : Monoid<Sum> {\n        override fun sappend(sb: Sum): Sum {\n            val sa = this as Sum\n            return Sum(sa.value + sb.value)\n        }\n\n        override fun mempty(): Sum = Sum(0)\n    }\n    class Sum(val value: Int) : SumMonoid\n    ```\n	2021-12-15 22:55:23	2021-12-15 22:55:23	2021-12-15 22:55:23	12	Monad	1001
12408	上学的时候读到了刘慈欣的《乡村教师》，虽然是节选，我还是很有感触，忽然想读《三体》了	2019-12-14 23:40:20	2019-12-14 23:40:22	2019-12-14 23:40:22	12		1001
12451	# 每月评论\n\n> 每月评论 - 第五期\n\n* 每一刊每月评论将在当月的月末发行，~~同时也会伴随博客的版本更新。~~\n\n---\n\n## 开学\n\n&emsp;&emsp;真他妈的卷啊。  \n&emsp;&emsp;全是课，无用的课。  \n\n> 本节经过多次删减，综合考量还是不写了。\n\n---\n\n很忙啊，头痛开始了。  \n那么，我是来找答案的啊。\n\n---\n\n<div align="right">\n\n每月评论 - 2103期(共5期)  \n撰稿&校对&审核：Thaumy\n\n</div>\n\n麻木的人貌似都赢了。\n	2021-04-09 19:49:59	2021-04-09 19:50:25	2021-04-09 19:50:25	12	每月评论2103	1001
12453	通关啦！推荐一个不错的Git学习工具：[https://learngitbranching.js.org/?locale=zh_CN](https://learngitbranching.js.org/?locale=zh_CN)	2021-06-30 11:31:38	2021-06-30 11:32:24	2021-06-30 11:32:24	12		1001
12488	# Y Combinator\n\n$Y$ 组合子\n\n## 概要\n\n$Y$ 组合子又称不动点组合子或不动点算子，是一种高阶函数，由Haskell Brooks Curry发现。由于λ表达式是匿名的，即任何λ表达式均不具有名字，所以是没有办法实现递归的。$Y$ 组合子也是一种λ表达式，它就是来解决该问题的。\n\n## 问题引入\n\n考虑阶乘函数（一般数学表述）：  \n$fac(x)=if\\ x > 0\\ then\\ x*fac(x-1)\\ else\\ 1$  \nλ表述：  \n$fac=λx.(if\\ x > 0\\ then\\ x*fac(x-1)\\ else\\ 1)$\n\n你应该注意到，在λ项中递归地使用名 $fac$ 是不恰当的，因为这样的写法并不能归约到不具备名 $fac$ 的函数 $fac$，因而违反了λ项的匿名性，所以我们尝试如下改造该表达式：\n\n$fac'=λx.λf.(if\\ x > 0\\ then\\ x*f(x-1)\\ else\\ 1)$\n\n我们通过传入函数 $f$ 的方式来表示函数本身，于是我们的阶乘函数定义如下：\n\n$fac=fac'\\ fac$\n\n然后我们就可以这样调用：\n\n$\\quad fac\\ 2$  \n$=(fac'\\ fac)\\ 2$  \n$=λx.(if\\ x > 0\\ then\\ x*fac(x-1)\\ else\\ 1)\\ 2$  \n$=2*(fac\\ 1)$  \n$=2*((fac'\\ fac)\\ 1)$  \n$=2*(λx.(if\\ x > 0\\ then\\ x*fac(x-1)\\ else\\ 1)\\ 1)$  \n$=2*(if\\ 1 > 0\\ then\\ 1*fac(1-1)\\ else\\ 1)$  \n$=2*(fac\\ 0)$  \n$=2*((fac'\\ fac)\\ 0)$  \n$=2*(λx.(if\\ x > 0\\ then\\ x*fac(x-1)\\ else\\ 1)\\ 0)$  \n$=2*(if\\ 0 > 0\\ then\\ 0*fac(0-1)\\ else\\ 1)$  \n$=2*1=2$\n\n显然，2的阶乘是2。\n\n但λ项中仍然使用了 $fac$，于是我们假设一个高阶函数 $Y=λf.f(Y f)$，则有：  \n$Y\\ g=g(Y\\ g)$  \n易得：  \n$fac=Y\\ fac'=fac'(Y\\ fac')⇔fac'\\ fac$  \n\n如果该高阶函数 $Y$ 的λ项中不含 $Y$，那么我们就能实现该阶乘函数了。  \n\n## $Y$ 组合子\n\n$Y=λf.((λx.f(x\\ x))\\ (λx.f(x\\ x)))$\n\n考虑归约：  \n$\\quad Y\\ g$  \n$=(λx.g(x\\ x))\\ (λx.g(x\\ x))$  \n$=g((λx.g(x\\ x))\\ (λx.g(x\\ x))))$  \n$=g(Y\\ g)$  \n可知：$Y⇒Y=λf.f(Y f)$\n\n显然，问题得到了解决，我们阶乘函数的λ表述为：\n\n$fac=(λf.((λx.f(x\\ x))\\ (λx.f(x\\ x))))\\ (λx.λf.(if\\ x > 0\\ then\\ x*f(x-1)\\ else\\ 1))$\n\n可简记为 $fac=Y\\ (λx.λf.(if\\ x > 0\\ then\\ x*f(x-1)\\ else\\ 1))$，这并不影响函数的匿名性。\n	2021-12-15 23:01:08	2021-12-15 23:01:08	2021-12-15 23:01:08	12	Y-Combinator	1001
12382	<style>p{text-indent: 2em; /*首行缩进*/}</style>\n\n## <span style="color:#3A65EB">一个先进的博客系统</span>\n\n这是一个响亮的名字！  \n\n<blockquote>\n噼里啪啦的命名灵感来自于键盘的敲击声。\n</blockquote>\n\n为改善网站运行效率，构建更好的信息发布平台，我开发了基于ASP.NET的博客系统，以噼里啪啦命名。  \n\n它是一个支持主题、精简高效、部署方便、易于拓展的工程，使用C#开发。  \n\n处于多重考虑，我们为该博客使用了MySql数据库，而不是MSSql。\n\n### <span style="color:#53A0FE">为什么要开发PiliPala？</span>\n\nWordpress是一个非常不错的博客系统，丰富的生态为它带来了很好的市场。  \n\n我尝试Wordpress的主题与插件，但是Wordpress臃肿的代码和复杂的函数使我不得不放弃。  \n\n之后我尝试了Typecho。  \n\n很快我便发现，php这种语言并不适合大型项目的开发：弱类型、版本之间的不兼容性、不完全的面向对象支持、不理想的运行效率、低效率的DeBug支持......  \n\n我认为，是时候出现一个新的博客系统了。  \n\n3年前，博客重构计划启动。\n\n### <span style="color:#53A0FE">来自WaterLibrary内核的全速驱动</span>\n\n<img style="width:100%" src="https://cdn.thaumy.cn/md-img/WaterLibrary-水库.min.png">\n\n————原名StudioLibrary，由水瓜啪啦开发工程组联合开发，它以极少的代码量，驱动了PiliPala的数据与业务层。\n\n它原本是为精简桌面程序开发过程而开发的类库，但现在它的使命是全速驱动噼里啪啦。  \n\n得益于C#的强大支持，这个内核的代码十分规范，.NET的强大编译器让责任与能力达成共识。  \n\n### <span style="color:#53A0FE">永久开源</span>\n\n我们的项目在GitHub开源，目前已达8个版本迭代。  \n点击这个超链接按钮，你可以于GitHub下载pilipala源代码:<a href="https://github.com/Thaumy/PILIPALA">PiliPala On GitHub</a>\n\n### <span style="color:#53A0FE">持续动力迭代</span>\n\n每个周PiliPala都会进行更新，每个季度PiliPala都会对上一阶段的问题进行汇总，将实用的新特性纳入新版本的开发列表之中。  \n\n每个版本的发布都伴随着新的pilipala功能，不断带来性能优化和更加强大的内核支持。\n\n### <span style="color:#53A0FE">非同寻常的系统</span>\n\n我们将ASP.NET(C#)与MySql组合，从高效和高可靠中同时受益，结构化的组件式架构使pilipala的拓展性进一步延伸。  \n\n得益于强大的MarkDown，即使是再复杂的文章，pilipala也能出色展现。  \n\n丰富且不断更新的内核函数让每一行代码的精简与高效完美契合。\n\n### <span style="color:#53A0FE">WE NEED HEROES</span>\n\n噼里啪啦由水瓜啪啦开发工程组开发运营，你可以通过QQ群（917328480）了解它的详细开发过程，或着手它的下一版本开发。\n\n我期待更多的开发者加入到这个颠覆性的项目当中。	2019-04-14 06:58:04	2020-10-06 21:44:02	2020-10-06 21:44:02	28	关于PiliPala	1001
12459	# Simply Typed Lambda Calculus\n\n简单类型λ演算\n\n## 概要\n\n**简单类型λ演算**（$λ\\scriptsize{→}$）是一种有类型的λ演算，它通过在λ演算上引入一个基本的类型系统来实现对类型的约束。本文仅概要性地介绍*Church风格*$^{*1}$下原始意义上的$λ\\scriptsize{→}$。\n\n## $λ\\scriptsize{→}$中的类型系统\n\n$λ\\scriptsize{→}$中的类型构造自形如 $α\\ β\\ γ...$ 的基本类型，如 $α→β$表示函数类型。其中，$→$ 是右结合的，这意味着 $α→β→γ:=α→(β→γ)$ $^{*2}$。\n\n通过介入类型上下文（以下简称“上下文”） $Γ\\ Δ...$，我们可以按照如下规则确定一个 $λ$ 项的类型：\n\n1. ${}\\over \\displaystyle {x:σ\\ \\vdash\\ x:σ}$，即如果 $x$ 为 $σ$ 类型，那么我们可以知道 $x$ 为 $σ$ 类型（对同一律抽象）。\n\n2. ${\\displaystyle Γ\\ \\vdash\\ x:σ\\quad x\\not=y}\\over \\displaystyle {Γ,y:τ\\ \\vdash\\ x : σ}$，即在上下文 $Γ$ 中，$x$ 有 $σ$ 类型，且 $x≠y$，那么可以推导出：在上下文 $Γ$ 中，$y$ 有 $τ$ 类型，可以推导出 $x$ 有 $σ$ 类型。即向 $Γ$ 中新增具有某类型的值并不影响原有值的类型。\n\n3. ${\\displaystyle Γ,x:σ\\ \\vdash\\ t:τ}\\over \\displaystyle {Γ\\ \\vdash\\ λx:σ.\\ t : σ \\to τ}$，即如果由上下文 $Γ$ 和 $x$ 具有类型 $σ$ 的事实可以推出 $t$ 具有 $τ$ 类型，那么在上下文 $Γ$ 中可以抽象出具有 $σ→τ$ 类型的函数 $λx.\\ t$。\n\n4. ${\\displaystyle Γ\\ \\vdash\\ t:σ\\toτ\\quadΓ\\ \\vdash\\ u:σ}\\over \\displaystyle{Γ\\ \\vdash\\ t\\,u : τ}$，即函数应用：上下文 $Γ$ 中有 $σ→τ$ 的 $t$ 和 $σ$ 类型的 $u$，可以推导出上下文 $Γ$ 中的 $t\\ u$ 为 $τ$ 类型。\n\n## 关于正则化\n\n如果一个 $λ$ 项，如果它不能被进一步地 $β$ 归约，那么它就是正则的（Normalized）。不是所有的 $λ$ 演算都具有这种性质，因为它存在可被无穷 $β$ 规约的项（$λx.x\\ x$ 就是一个例子）。而在 $λ\\scriptsize{→}$ 中，项要么是正则的，要么是可以被化为正则的（即可正则化（Normalizable）的）。\n\n### $λ\\scriptsize{→}$是强正则的\n\n类型系统的引入使得 $λ\\scriptsize{→}$ 的所有 $λ$ 项都是**强正则**（Strongly Normalized）的，这意味着不存在一个 $λ$ 项使得其可以被无穷地 $β$ 归约，因为你无法找到这样的 $λ$ 项所对应的类型。同时这也是**强正则定理**（Strong Normalization Theorem）的表述：任何 $λ$ 项都能经过有限次 $β$ 归约化为正则项，如果 $λ$ 项是有类型的。\n\n### $λ\\scriptsize{→}$也是弱正则的\n\n**弱正则定理**（Weak Normalization Theorem）：对于一个有类型的 $λ$ 项，其可被正则化。\n\n显然，弱正则定理是强正则定理的推论，这也解释了为什么 $λ\\scriptsize{→}$ 具有*可计算性*$^{*3}$。\n\n## 关于$λ\\scriptsize{→}$的表达\n\n通过引入类型系统，我们现在可以*这样*$^{*4}$构造自然数：\n\n$0:=λf:α→α.\\ λx:α.\\ x$  \n$1:=λf:α→α.\\ λx:α.\\ f\\ x$  \n$2:=λf:α→α.\\ λx:α.\\ f\\ (f\\ x)$  \n$...$  \n$n:=λf:α→α.\\ λx:α.\\ f^{○n}\\ x$\n\n现在，我们可以规定自然数的类型了（受限于自然数的特点，这有些牵强）：\n\n$1_{int}:=λf:int→int.\\ λx:int.\\ f\\ x$  \n$2_{float}:=λf:float→float.\\ λx:float.\\ f\\ (f\\ x)$  \n\n和布尔值：\n\n$true\\ \\ :=λa:α.\\ λb:α.\\ a$  \n$false:=λa:α.\\ λb:α.\\ b$\n\n还记得之前的 $if$ 吗？现在它的两个分支必须是相同类型的了：\n\n$if:=λp:α.\\ λa:α.\\ λb:α.\\ p\\ a\\ b$\n\n注意这里所有的 $α$ 都是**具体类型**，它并不是类型参数。也就是说形如 $λf:α→α.\\ λx:α.\\ x$ 的项是一个**值**，而非**值构造器**。\n\n## In λ Cube\n\n$λ$ 立方体（Lambda Cube）描述了不同类型系统之间的关系，自左下角至右上角，类型系统的表达能力逐渐增强。\n\n<img style="background:white;" src="https://cdn.thaumy.cn/post/技术/瓜计导/STLC/res/lambda_cube.svg" width="256px">\n\n在λ立方体中，$λ\\scriptsize{→}$ 居于最左下角，具有最基本（也是最弱）的表达能力。\n\n|     系统\\特征     |   $→$   |  $Π$  |  $ω$  |  $2$  |\n| :---------------: | :-----: | :---: | :---: | :---: |\n| $λ\\scriptsize{→}$ | $(*,*)$ |   ╳   |   ╳   |   ╳   |\n\n$(*,*)$ 表示 $λ\\scriptsize{→}$ 允许由项构造项（函数），这也是其唯一具有的特征。\n\n---\n\n### 注解\n\n1. 另有Curry风格的$λ\\scriptsize{→}$，其特征是不在变量上标注类型。\n2. $a:=b$ 表示可以将 $a$ 代换为 $b$，即它们是**外延相等**的。\n3. 即可以在有限步骤内被解决。显然在 $λ\\scriptsize{→}$ 中所有的 $λ$ 项都能在有限次的 $β$ 规约中化为正则项。\n4. 使用Church Encoding。\n	2021-12-15 22:46:54	2021-12-15 23:04:05	2021-12-15 23:04:05	12	STLC	1001
12475	# λ - Calculus\n\n$λ$ 演算\n\n## 概要\n\n**λ - Calculus**（λ：\\\\'læmdə\\）是一种研究函数的形式化系统，能表达任意类型的计算过程，因而具有图灵完备性，可看作最简单的程序设计语言。$λ$ 演算又称**无类型 $λ$ 演算**（Untyped Lambda Calculus，UTLC），因为它缺乏类型系统，所以表达能力有限。\n\n本文仅介绍无类型λ演算。\n\n## 介绍\n\n下面我们来看一个简单的**λ项**$^{*1}$：  \n$λx.\\ x+1$\n\n其中， $λ$ 表示一个函数的开始，而 $λx.$ 则表示将变量 $x$ **绑定**（Binding）到函数体 $x+\n1$ 上（即该 $x$ 的作用域被限定为 $x+1$ ），$x+1$ 是函数体。  \n\n看起来可能不是很好懂，实际上这种表示形式和你所熟知的 $f(x)=x+1$ 是等价的。\n\n**函数应用**（Function Applictaion）是指将函数作用到一个或一些值上，表示为 $f(a)$ ，其中 $a$ 为**参数**（Argument）。例如 $f(1)$ 即为一个函数应用，读作 “将函数 $f$ 作用于值 $1$ ”。\n\nλ演算的函数应用表示为：  \n$(λx.\\ x+1)\\ a$\n\n括号是为了将函数体和参数 $a$ 区分开而添加的，所以该应用也可以表示为 $((λx.\\ x+1))\\ a$，若取 $a=2$，则该λ项的**归约**$^{*2}$结果为 $2$。由于 $a$ 是独立于 $λ$ 项 $(λx.\\ x+1)$ 而存在的，即它没有被绑定，所以被称作**自由变量**。\n\n## Playground\n\n请计算λ表达式 $(λx.\\ x+x+x)\\ 1$ 的结果。\n\n---\n\n### 注解\n\n1. 符合以下三种情况之一的，被称作λ项：\n\n   * 变量 $x$ 本身\n   * $(λx.\\ E)$，其中 $E$ 必须是一个λ项\n   * $(E_1\\ E_2)$，即函数应用，要求 $E_1$ 与 $E_2$ 均为λ项\n\n    为便于表述或兼顾上下文起见，可能把λ项称作**λ表达式**。\n\n2. 在λ演算中，归约（Reduce）有以下两种形式：\n\n   * $α$ - 变换：对表达式中的变量绑定进行重命名，如 $λx.\\ x$ 经 $α$ - 变换后可得 $λy.\\ y$，这可以在某些时候避免名称冲突，变换前后表达式等价。\n   * $β$ - 归约：即对表达式化简，更严格的表述是 “用参数表达式代替绑定变量”，如 $(λx.\\ x)\\ a$ 经 $β$ - 归约后可得 $a$，实质上表达的是函数应用的概念。\n	2021-12-15 22:55:00	2021-12-15 22:55:00	2021-12-15 22:55:00	12	Lambda Calculus	1001
12474	# Higher-Order Function\n\n## 概要\n\n高阶函数（Higher-Order Function），是一种算子。和普通函数不同，高阶函数接受少一个函数作为参数（是的！该参数是一个函数）。\n\n## 演示\n\n考虑 $f(x,k)=k(x)$，$g(y)=y+1$  \n则函数应用 $f(2,g)$ 的结果为3，即 $f(2,g)=g(2)=2+1=3$  \n那么 $f(x,k)$ 就被称为高阶函数\n\n## Playground\n\n给出高阶函数 $f(x,y,g)=g(x)+y$，请写出一个函数$g(x)$，使得 $f(1,2,g)=3$\n	2021-12-15 22:54:29	2021-12-15 22:54:29	2021-12-15 22:54:29	12	HOF	1001
12394	# 氛V2主题\n\n<blockquote>\n经过全新设计\n</blockquote>\n\n## 高分辨率视觉\n\n<div align="center">\n<img style="width:94%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V2/xiangyingshi.svg">\n</div>\n\n相较于氛V1，氛V2在2K分辨率下进行设计，出色的响应式结构让氛V2拥有更大的分辨率支持空间。  \n\n## 手机与平板的出色体验\n\n<div>\n<img style="width:70%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V2/phone&pad.svg">\n</div>\n\n我们兼容所有移动端设备，氛V2为移动端自适应提供了出色解决方案。  \n下拉式菜单经过精心设计，支持全面屏。\n\n## 来源于对文字的专注\n\n<div>\n<img style="width:100%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V2/new_tag.svg">\n</div>\n不同于氛V1，氛V2的标签样式更加简单，你看到的每一篇文章，以文字回归。\n\n## 思源，饮水思源\n\n<div>\n<img style="width:100%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V2/source_han_sans.jpg">\n</div>\n\n一笔一划的匠心雕琢，来自我们颇受欢迎的思源黑体的拉丁文、希腊文和西里尔文字形。  \n\n## 标准色\n\n<div>\n<img style="width:30%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V2/srgb_color.svg">\n</div>\n\n100%SRGB的设计师标准，我们的颜色，精准到每一像素。\n\n## 阅读本身就是一种放松\n\n<div>\n<img style="width:70%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V2/deep_dark_field.svg">\n</div>\n\n减少光刺激的暗色调阅读区。\n\n## 人人皆作家\n\n<div>\n<img style="width:50%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V2/markdown_logo.svg">\n</div>\n\n忘掉html，这里没有标记块。  \n得益于marked.js解析引擎，你可以在写作时使用markdown语言，可读易用。  \n\n## 这个需求很简单\n\n<pre>C#<code>public void HelloField()\n{\n    Console.WriteLine("HelloField!");\n}</code></pre>\n\n现在是开发者时间，氛V2支持高亮。\n\n## This Is Field.\n\n这就是氛。	2019-08-25 09:59:35	2019-08-31 22:30:54	2019-08-31 22:30:54	12	氛V2	1001
12425	<span style="float:right;" class="wd-dt5 cur" onclick="up();showPost(12376)">点此返回索引根目录</span>\n\n## <span id="A6EiaHlYhcUW">WaterLibrary1.1.7维护暂栏，伴随PILIPALA BETA9预览更新</span>[#](#A6EiaHlYhcUW)\n\n<span class="mk-dt">21.12.09<span class="mk-dbg"></span></span>修复了评论计数不显示的问题  \n<span class="mk-dt">21.11.09<span class="mk-updt"></span></span>使用更加全面的HTML过滤器  \n<span class="mk-dt">21.11.09<span class="mk-updt"></span></span>添加了对Markdown的任务列表解析语法  \n<span class="mk-dt">21.08.30<span class="mk-updt"></span></span>修复了隐藏文章的可见性问题  \n<span class="mk-dt">21.08.01<span class="mk-updt"></span></span>引入文章树（PostTree），可构建树形文章层次结构  \n<span class="mk-dt">21.07.29<span class="mk-updt"></span></span>将Writer组件标记为过时  \n<span class="mk-dt">21.07.28<span class="mk-dbg"></span></span>修复了用户登录密码识别不正确的问题\n<span class="mk-dt">21.07.27<span class="mk-updt"></span></span>引入文章栈（PostStack）  \n<span class="mk-dt">21.07.26<span class="mk-updt"></span></span>引入文章记录（PostRecord），相较于Post它具有一个带有缓存设计的惰性求值访问器  \n<span class="mk-dt">21.06.28<span class="mk-dbg"></span></span>修复了在ajax刷新中的LaTeX渲染失败问题  \n<span class="mk-dt">21.06.01<span class="mk-updt"></span></span>修改了插件的耦合实现  \n<span class="mk-dt">21.03.26<span class="mk-updt"></span></span>为Markdown数学公式提供渲染支持(使用MathJax)  \n<span class="mk-dt">21.03.21<span class="mk-updt"></span></span>Field3代码高亮优化  \n<span class="mk-dt">21.03.21<span class="mk-updt"></span></span>对Field3的性能和内存占用进行了优化  \n<span class="mk-dt">21.02.22<span class="mk-updt"></span></span>LigntningLink开发完成  \n<span class="mk-dt">21.02.14<span class="mk-updt"></span></span>进一步简化了组件工厂和内核的构造设计  \n<span class="mk-dt">21.02.12<span class="mk-updt"></span></span>将内核事件驱动机制移交到pilipala层  \n<span class="mk-dt">21.02.10<span class="mk-updt"></span></span>删除了文章属性接口和评论属性接口，改用枚举替代  \n<span class="mk-dt">21.02.09<span class="mk-updt"></span></span>文件结构优化  \n<span class="mk-dt">21.02.09<span class="mk-updt"></span></span>新增插件LightningLink(闪链)，用以替换内容  \n<span class="mk-dt">21.02.09<span class="mk-updt"></span></span>替换了内核中大量的反射式API，使页面刷新速度获得显著提升  \n<span class="mk-dt">21.02.09<span class="mk-updt"></span></span>将`pl_index`表更名为`pl_meta`  \n<span class="mk-dt">21.02.09<span class="mk-updt"></span></span>现在可以配置云存储目录位置了  \n<span class="mk-dt">21.02.08<span class="mk-ui"></span></span>统一了Field3主题的各端背景显示，并修复了背景不居中显示的问题  \n<span class="mk-dt">21.02.08<span class="mk-updt"></span></span>全站HTTPS开启  \n<span class="mk-dt">21.01.31<span class="mk-updt"></span></span>删除了直接操作表的方法以提升安全性  \n<span class="mk-dt">21.01.31<span class="mk-updt"></span></span>修复了事务托管器无效的问题，扩展了SqlCommand方法，简化了对数据库的增删改操作  \n<span class="mk-dt">21.01.31<span class="mk-updt"></span></span>优化了库表结构，归档信息现在由index表存储  \n<span class="mk-dt">21.01.30<span class="mk-updt"></span></span>完善了归档管理器  \n<span class="mk-dt">21.01.30<span class="mk-updt"></span></span>新增事务托管器，同时优化了代码结构  \n<span class="mk-dt">21.01.29<span class="mk-updt"></span></span>新增连接托管器，同时优化了代码结构，并修复了潜在于CommentLake中的一个的连接池溢出问题  \n<span class="mk-dt">21.01.29<span class="mk-updt"></span></span>新增命令托管器，使用该方法托管的命令能实现更少的代码量和更好的资源控制  \n<span class="mk-dt">21.01.29<span class="mk-updt"></span></span>为数据库管理器添加了若干进一步简化查询的方法  \n<span class="mk-dt">21.01.28<span class="mk-updt"></span></span>优化了主题配置文件的读取功能  \n<span class="mk-dt">21.01.25<span class="mk-updt"></span></span>为PostSet添加了索引器  \n<span class="mk-dt">21.01.13<span class="mk-updt"></span></span>支持了主题自定义归档展示  \n<span class="mk-dt">21.01.11<span class="mk-updt"></span></span>新增归档管理组件和`pl_archive`表，调整了工厂方法的构造和组件的构造以减少箱操作  \n<span class="mk-dt">21.01.10<span class="mk-updt"></span></span>对`pl_stack`表的相关字段进行语义重命名，统一了各表字段间的语义  \n<span class="mk-dt">21.01.10<span class="mk-updt"></span></span>增添了表`pl_archive`用于统计归档信息，并将`pl_backup`表更名为`pl_stack`以更贴切语义  \n<span class="mk-dt">21.01.09<span class="mk-updt"></span></span>对Reader的工厂生成提供了隐性读取开关(WithRawMode)，大幅简化了Reader内的操作逻辑  \n<span class="mk-dt">21.01.09<span class="mk-updt"></span></span>对Writer组件中用于更新文章类型的方法进行了合并，提供了文章类型状态枚举以代替泛型  \n<span class="mk-dt">21.01.08<span class="mk-updt"></span></span>对Writer组件中用于更新文章模式的方法进行了合并，提供了文章模式状态枚举以代替泛型  \n<span class="mk-dt">21.01.08<span class="mk-updt"></span></span>更改了MySqlManager的构造逻辑，并对MySqlConnMsg的Database字段剔除以解耦  \n<span class="mk-dt">21.01.07<span class="mk-updt"></span></span>应用C#9.0关键字"record"对小型数据结构进行了改良  \n<span class="mk-dt">21.01.07<span class="mk-updt"></span></span>对Reader组件的脏读控制由内核表设定改为由组件工厂控制；同时简化了内核表定义，将默认表定义打包到配置文件，对脏视图和净视图统一管理  \n<span class="mk-dt">21.01.06<span class="mk-updt"></span></span>更名Tools命名空间为Util，并在MathH增加了排序顺序表示枚举  \n<span class="mk-dt">21.01.05<span class="mk-updt"></span></span>应用C#9.0的一些特性对内核进行了改写，如增强型模式匹配、仅限Init的资源库等特性  \n<span class="mk-dt">21.01.05<span class="mk-updt"></span></span>改用元组代替MySqlKey，优化了查询的拆装箱操作，以及其他结构性优化  \n\n## <span id="w73SGkGkeFnM">PILIPALA 2009BETA8 LTS Build2维护日志</span>[#](#w73SGkGkeFnM)\n\n<span class="mk-dt">21.01.02<span class="mk-updt"></span></span>将jiligulu移植到了Electron  \n<span class="mk-dt">20.12.28<span class="mk-updt"></span></span>为KeyPair提供了自序列化到JSON功能  \n<span class="mk-dt">20.12.27<span class="mk-updt"></span></span>大幅度提升了系统的并发性能，强化了数据库连接池的管理能力  \n<span class="mk-dt">20.12.26<span class="mk-updt"></span></span>为WL内核数据库控制器开发了一个连接池系统，有效避免了连接过多导致的卡死问题。  \n<span class="mk-dt">20.12.26<span class="mk-ui"></span></span>修复了叽里咕噜后台查看迭代栈时服务器会卡死的问题  \n<span class="mk-dt">20.12.26<span class="mk-updt"></span></span>对日期格式化功能解耦，禁用了组件单独构造  \n<span class="mk-dt">20.12.24<span class="mk-updt"></span></span>完善了叽里咕噜后台的用户页面  \n<span class="mk-dt">20.12.24<span class="mk-updt"></span></span>丰富了Authentication组件的功能和User组件的功能  \n<span class="mk-dt">20.12.24<span class="mk-updt"></span></span>将CommentLake和User对象归入组件模式  \n<span class="mk-dt">20.12.23<span class="mk-updt"></span></span>为叽里咕噜后台开发了登录功能，并提供了一套非常可信的RSA验证机制确保了数据安全性  \n<span class="mk-dt">20.12.22<span class="mk-updt"></span></span>添加了对https支持（但是部分外链内容仍不安全）  \n<span class="mk-dt">20.12.20<span class="mk-updt"></span></span>内核接口开放完成，现支持使用组件工厂模式的初始化  \n<span class="mk-dt">20.12.20<span class="mk-updt"></span></span>优化了参数化查询结构，为数据集提供ForEach迭代支持  \n<span class="mk-dt">20.12.17<span class="mk-ui"></span></span>删除了蓝线加载条，改用模糊加透明的渐变动画  \n<span class="mk-dt">20.12.17<span class="mk-ui"></span></span>为滑至底部查看背景图添加了作者版权标识  \n<span class="mk-dt">20.12.15<span class="mk-ui"></span></span>删除了下雪特效以减少访问时的GPU开销  \n<span class="mk-dt">20.12.16<span class="mk-ui"></span></span>为Field主题添加了滑动到底部可查看背景图的功能  \n<span class="mk-dt">20.12.15<span class="mk-updt"></span></span>为Markdown提供了对拓展语法`额外强调`的支持  \n<span class="mk-dt">20.12.14<span class="mk-updt"></span></span>博客现已完全迁移至Linux环境(Ubuntu2004)  \n<span class="mk-dt">20.12.12<span class="mk-updt"></span></span>2020年12月12日15时52分，pilipala在linux环境下运行成功！  \n<span class="mk-dt">20.12.11<span class="mk-dbg"></span></span>大幅度简化了内核的命名空间  \n<span class="mk-dt">20.12.11<span class="mk-dbg"></span></span>修复了js防抖失效的问题  \n<span class="mk-dt">20.12.10<span class="mk-dbg"></span></span>修复了蓝线加载条不显示的问题  \n<span class="mk-dt">20.12.10<span class="mk-updt"></span></span>将piliala数据库移植到了MySQL8下  \n<span class="mk-dt">20.12.09<span class="mk-updt"></span></span>Comment对象和Post对象现支持自序列化  \n<span class="mk-dt">20.12.09<span class="mk-updt"></span></span>pilipala已完全移植到.net core  \n<span class="mk-dt">20.12.08<span class="mk-updt"></span></span>修复了内核Writer组件中查找消极文章GUID方法的一个SQL格式化错误  \n<span class="mk-dt">20.12.08<span class="mk-updt"></span></span>现已将WaterLibrary内核移植到.net core  \n<span class="mk-dt">20.12.08<span class="mk-updt"></span></span>为内核应用了新的MySQL控制器  \n<span class="mk-dt">20.12.08<span class="mk-updt"></span></span>WL的session和cookie管理器已不受支持\n\n## <span id="ER0RRga0rrjj">PILIPALA 2009BETA8 LTS Build1维护日志</span>[#](#ER0RRga0rrjj)\n\n<span class="mk-dt">20.12.08<span class="mk-updt"></span></span>对Post对象增添了更多聚合方法  \n<span class="mk-dt">20.12.08<span class="mk-updt"></span></span>新增可迭代对象PostSet(文章数据集)，和CommentSet有相似的优点  \n<span class="mk-dt">20.12.07<span class="mk-updt"></span></span>新增可迭代对象CommentSet(评论数据集)，此对象可提供较泛型集合更专一化的数据聚合功能  \n<span class="mk-dt">20.12.07<span class="mk-updt"></span></span>Html过滤器现在支持对转义字符的过滤  \n<span class="mk-dt">20.12.07<span class="mk-updt"></span></span>在内核层面提供了对文章原数据的格式化支持  \n<span class="mk-dt">20.12.07<span class="mk-updt"></span></span>现已在内核层面提供了对文章内容的Html过滤和Markdown转义支持  \n<span class="mk-dt">20.12.07<span class="mk-updt"></span></span>简化了FieldV3主题的一些样式函数  \n<span class="mk-dt">20.12.06<span class="mk-updt"></span></span>重新设计了FieldV3主题的蓝线导航条，它现在不会因为刷新和路由丢失位置了！  \n<span class="mk-dt">20.12.06<span class="mk-updt"></span></span>更改了FieldV3主题的路由格式，现在的路由地址更易于理解和可读  \n<span class="mk-dt">20.12.06<span class="mk-updt"></span></span>FieldV3主题现支持PJAX(和以前的不一样！这次真正地利用了PJAX的所有优点和特性！)  \n<span class="mk-dt">20.12.06<span class="mk-updt"></span></span>现已将pilipala完全迁移至MVC模式下，为后续转移至.net core和跨平台部署做准备(啊啊啊一下午一晚上没了)  \n<span class="mk-dt">20.12.06<span class="mk-updt"></span></span>修复了后台迭代化系统获取的备份全都一样的问题  \n<span class="mk-dt">20.12.06<span class="mk-updt"></span></span>修复了后台删除文章失败的问题  \n<span class="mk-dt">20.12.06<span class="mk-updt"></span></span>修复了后台无法获得到备份列表的问题  \n<span class="mk-dt">20.12.06<span class="mk-updt"></span></span>修复了WL内核计数器组件正则匹配错误导致的计数失效问题  \n<span class="mk-dt">20.12.05<span class="mk-updt"></span></span>WL内核升级到1.1.6.9，此版本提升了性能并优化了接口  \n<span class="mk-dt">20.12.05<span class="mk-updt"></span></span>用户功能恢复，经过重新设计的用户功能相比以前的充数版本具有更明确的设计目标和更强大的功能  \n<span class="mk-dt">20.12.04<span class="mk-ui"></span></span>重新设计了主题的部分样式  \n<span class="mk-dt">20.12.04<span class="mk-dbg"></span></span>修复了块状代码样式错误的问题  \n<span class="mk-dt">20.12.03<span class="mk-dbg"></span></span>修复了未点赞但刷新文章会导致星星被点亮的问题  \n<span class="mk-dt">20.12.03<span class="mk-updt"></span></span>重新设计了后台数据接口  \n<span class="mk-dt">20.12.02<span class="mk-updt"></span></span>叽里咕噜后台评论管理现可用  \n<span class="mk-dt">20.12.01<span class="mk-dbg"></span></span>修复了评论楼层错误的问题  \n<span class="mk-dt">20.11.30<span class="mk-ui"></span></span>大规模维护了文章内容  \n<span class="mk-dt">20.11.29<span class="mk-ui"></span></span>修复了CommentLake评论系统在对无评论文章进行评论时的失效问题  \n<span class="mk-dt">20.11.27<span class="mk-ui"></span></span>修复了markdown样式错乱的问题，在GitHub样式的基础上优化了markdown样式  \n<span class="mk-dt">20.11.26<span class="mk-updt"></span></span>叽里咕噜开始试运行，感谢<a href="http://www.gxhsoulstar.cn">Soulstar</a>提供的测试支持  \n<span class="mk-dt">20.11.23-24<span class="mk-updt"></span></span>WL内核升级到1.1.6.8，该版本对迭代化系统提供重点支持  \n<span class="mk-dt">20.11.22<span class="mk-updt"></span></span>优化了pilipala数据库索引结构，提升了最高约500%的性能  \n<span class="mk-dt">20.11.22<span class="mk-updt"></span></span>IPostKey接口功能单一化，仅用于泛型约束  \n<span class="mk-dt">20.11.22<span class="mk-updt"></span></span>pilipala内核配件的初始化改为由事件驱动以简化初始化流程，数据库结构和数据库连接设置为在pilipala开发层不可见  \n<span class="mk-dt">20.11.22<span class="mk-updt"></span></span>重构了PLDR以使在pilipala开发层面无需关心数据库结构  \n<span class="mk-dt">20.11.20<span class="mk-updt"></span></span>重新设计了WL内核中与pilipala系统初始化有关的结构  \n<span class="mk-dt">20.11.17<span class="mk-updt"></span></span>叽里咕噜已完成技术验证开发  \n<span class="mk-dt">20.11.09<span class="mk-updt"></span></span>为pilipala框架添加了更多接口以支持后台数据访问  \n<span class="mk-dt">20.11.15<span class="mk-updt"></span></span>内核文章类型现支持MD5访问器计算以解耦  \n<span class="mk-dt">20.11.11-14<span class="mk-updt"></span></span>完成了pilipala试作型后台(叽里咕噜)的UI开发工作  \n<span class="mk-dt">20.11.10<span class="mk-updt"></span></span>为WL内核增加了RSA验证器  \n<span class="mk-dt">20.11.09<span class="mk-updt"></span></span>改善了WL内核的底层查询性能  \n<span class="mk-dt">20.11.05-08<span class="mk-updt"></span></span>优化了pilipala数据库的性能  \n<span class="mk-dt">20.11.05<span class="mk-updt"></span></span>完善了CommentLake实现，增加若干增删改查功能  \n<span class="mk-dt">20.11.04<span class="mk-updt"></span></span>WL内核现已集成CommentLake，优化了若干结构  \n<span class="mk-dt">20.11.03<span class="mk-updt"></span></span>叽里咕噜后台(技术验证型)开发完成  \n<span class="mk-dt">20.11.02<span class="mk-updt"></span></span>WL内核新增啪啦计数器类(该类为详细统计噼里啪啦数据库内容提供底层支持)  \n<span class="mk-dt">20.11.01<span class="mk-updt"></span></span>WL内核改用了反射型Post索引器，相较于原来的枚举型Post索引器有了更大的性能提升和可拓展性  \n<span class="mk-dt">20.10.30<span class="mk-updt"></span></span>WL内核的可迭代对象转字符串功能拓展性进一步增强  \n<span class="mk-dt">20.10.29<span class="mk-updt"></span></span>丰富了WL内核对pilipala历史迭代系统(一种类似于git的文章日志型系统)的支持  \n\n## <span id="7QH1TSs0XUt7">PILIPALA 2009BETA8 LTS 先行测试2维护日志</span>[#](#7QH1TSs0XUt7)\n\n<span class="mk-dt">20.10.26<span class="mk-dbg"></span></span>修复了文章内提示bar的错误搭配问题  \n<span class="mk-dt">20.10.26<span class="mk-updt"></span></span>考量到功能体验的完整性，便签现在也支持点击访问了  \n<span class="mk-dt">20.10.26<span class="mk-dbg"></span></span>修复了WL内核因事务查询设计错误导致PLDU部分方法无法使用的问题  \n<span class="mk-dt">20.10.25<span class="mk-dbg"></span></span>修复了WL内核 PrevID&lt;T&gt;(ID)、NextID&lt;T&gt;(ID) 目标视图错误的bug  \n<span class="mk-dt">20.10.24<span class="mk-bug"></span></span>1024！节日快乐！！！  \n<span class="mk-dt">20.10.24<span class="mk-w"></span></span>优化了图片外链CDN结构  \n<span class="mk-dt">20.10.23<span class="mk-updt"></span></span>WL内核新增程序集信息获取访问器  \n<span class="mk-dt">20.10.22<span class="mk-updt"></span></span>CommentLake回复功能现可用(技术验证型)  \n<span class="mk-dt">20.10.22<span class="mk-dbg"></span></span>修复了浏览器宽度变化不能触发响应式的问题  \n<span class="mk-dt">20.10.21<span class="mk-dbg"></span></span>修复了评论列表在昵称宽度不够时会发生文字溢出的问题  \n<span class="mk-dt">20.10.21<span class="mk-dbg"></span></span>修复了CommentLake评论提交滑条在ajax异步加载后无效的问题  \n<span class="mk-dt">20.10.20<span class="mk-bug"></span></span>登记问题：CommentLake评论提交滑条在ajax异步加载后无效  \n<span class="mk-dt">20.10.20<span class="mk-updt"></span></span>CommentLake评论提交系统现可用(技术验证型)  \n<span class="mk-dt">20.10.14<span class="mk-dbg"></span></span>修复了因为错误的URL映射导致站点首页卡死的恶性bug  \n<span class="mk-dt">20.10.14<span class="mk-updt"></span></span>集中解决了WL1.16.5的一系列问题，提升了内核稳定性  \n<span class="mk-dt">20.10.11<span class="mk-updt"></span></span>为进一步功能化MySQL控制器，删除了WL对外部连接的控制支持  \n<span class="mk-dt">20.10.10<span class="mk-updt"></span></span>截至此时WL1.16.5已经节约代码200行，并新增功能十余项  \n<span class="mk-dt">20.10.10<span class="mk-updt"></span></span>删除了数据库的3个函数/存储过程  \n<span class="mk-dt">20.10.10<span class="mk-updt"></span></span>简化了啪啦系统的结构和初始化流程  \n<span class="mk-dt">20.10.10<span class="mk-updt"></span></span>WL内核新增了更多泛型方法，用以替代传统文章查询方法并减少代码量  \n<span class="mk-dt">20.10.09<span class="mk-updt"></span></span>简化了SQL查询结构，优化了噼里啪啦系统初始化过程  \n<span class="mk-dt">20.10.09<span class="mk-updt"></span></span>优化了GetIndex()方法和GetPrimary()方法，二者现均支持泛型索引  \n<span class="mk-dt">20.10.09<span class="mk-dbg"></span></span>修复了GetIndex()方法返回值错误的问题  \n<span class="mk-dt">20.10.09<span class="mk-updt"></span></span>对GetList的6个重载进行了泛型重构，使参与匹配的键值能涵盖IKey的所有实现，使得在减少百余行代码的基础上功能不变  \n<span class="mk-dt">20.10.08<span class="mk-updt"></span></span>WL内核新增了GetList&lt;T&gt;()泛型方法，该方法能大幅度减少代码量和噼里啪啦的运行效率  \n<span class="mk-dt">20.10.08<span class="mk-updt"></span></span>WL内核新增了GetList()可变参数重载，该方法大幅度减少了以往方法对数据库资源的开销  \n<span class="mk-dt">20.10.08<span class="mk-updt"></span></span>丰富了WL内核中IKey接口的实现  \n<span class="mk-dt">20.10.08<span class="mk-updt"></span></span>修改了数据库中Index表和Primary表对时间的命名，增添了双表联合视图  \n<span class="mk-dt">20.10.05<span class="mk-bug"></span></span>登记问题：CommitList在用户名超出时，自动换行会导致排版错乱  \n<span class="mk-dt">20.10.05<span class="mk-bug"></span></span>登记问题：CommitBox的提交按钮不能显示圆角样式  \n\n## <span id="lzBEz5W7dPmG">PILIPALA 2009BETA8 LTS 先行测试1维护日志</span>[#](#lzBEz5W7dPmG)\n\n<span class="mk-dt">20.10.04<span class="mk-updt"></span></span>升级到WL1.16.4内核(B2步进)，此版本针对性能进行了优化  \n<span class="mk-dt">20.10.03<span class="mk-w"></span></span>修复了部分文章的样式问题  \n<span class="mk-dt">20.10.03<span class="mk-ui"></span></span>修改了评论相关样式  \n<span class="mk-dt">20.10.03<span class="mk-dbg"></span></span>修复了蓝线加载条在非首页处消失的问题  \n<span class="mk-dt">20.10.03<span class="mk-updt"></span></span>thaumy.cn解析现可用  \n<span class="mk-dt">20.10.03<span class="mk-updt"></span></span>升级到WL1.16.3内核(B1步进)，此版本完善了查询逻辑  \n<span class="mk-dt">20.10.02<span class="mk-updt"></span></span>CommentLake评论系统阅读功能现可用  \n<span class="mk-dt">20.10.02<span class="mk-ui"></span></span>提示条新样式现可用  \n<span class="mk-dt">20.10.01<span class="mk-dbg"></span></span>修复了夜间模式下AtBox的样式错误问题  \n<span class="mk-dt">20.09.29<span class="mk-ui"></span></span>CommentLake UI设计终了  \n<span class="mk-dt">20.09.16<span class="mk-updt"></span></span>添加了对随笔的Markdwon解析支持  \n<span class="mk-dt">20.09.15<span class="mk-dbg"></span></span>使用了后端化Markdown解析器，解决了文章概要中的预览bug和引用标记无法正确翻译的bug  \n<span class="mk-dt">20.09.15<span class="mk-ui"></span></span>调整了文章属性盒的样式  \n<span class="mk-dt">20.09.14<span class="mk-w"></span></span>维护了2篇归档文章（盘古型）  \n<span class="mk-dt">20.09.13<span class="mk-w"></span></span>维护了2篇归档文章（盘古型）  \n<span class="mk-dt">20.09.13<span class="mk-updt"></span></span>升级到WL1.16.2内核(A3步进)，此版本修复了已知问题并提升了稳定性  \n<span class="mk-dt">20.09.09<span class="mk-w"></span></span>维护了4篇归档文章（盘古型）  \n<span class="mk-dt">20.09.09<span class="mk-updt"></span></span>上载了pillipala beta8先行测试1  \n<span class="mk-dt">20.09.09<span class="mk-mtn"></span></span>记录了验证版本的已知问题，维护了相关样式  \n<span class="mk-dt">20.09.09<span class="mk-updt"></span></span>上载了pillipala beta8服务器技术验证版本  \n	2020-09-07 16:49:56	2021-08-30 17:09:54	2021-08-30 17:09:54	12	PB8维护日志	1001
12483	# Subtyping\n\n子类型化\n\n## 概要\n\n**子类型化**是类型多态的一种形式。\n\n## 介绍\n\n如果子类型（subtype）$S$ 存在有一个超类型（supertype）$T$，那么可记该关系为 $S<:T$ 或 $T:>S$，这意味着所有有（或需要） $T$ 存在的地方都可以由 $S$ 安全地代换 $^{*1}$ ，这便是Subtyping。注意不要将Subtyping与面向对象中继承（inheritance）的概念相混淆，因为Subtyping关注的是类型间的关系（更类似于接口）而继承关注的是从现有对象创建新的对象，这意味着Subtyping和Inheritance是正交（orthogonal）的，尽管它们有重合的地方 $^{*2}$。\n\n类型（Type）是由含有一系列的值组成的集合（Set）。为了描述该集合，我们可以枚举地写出类型的所有取值，也可以使用谓词（Predicate）来过滤某个域（Domain）中的取值。\n\n对于谓词表达的类型，我们认为谓词 $\\textbf{S}$ 和谓词 $\\textbf{T}$ 分别代表域 $D$ 上的相应类型，满足 $\\textbf{S}$ 和 $\\textbf{T}$ 的元素的集合分别记为 $S$ 和 $T$，对于同一域 $D$，Subtyping满足如下规则：\n\n* 如果 $S$ 中的每个元素在 $T$ 中都有对应，则 $\\textbf{T}$ 包含（subsumes） $\\textbf{S}$。\n* 类型 $\\textbf{T}$ 可以被一个或更多类型包含，即 $T$ 是这些类型的交集。\n* 如果 $\\textbf{S}<:\\textbf{T}$，那么 $\\textbf{T}$ 必将是 $\\textbf{S}$ 的一部分 $^{*3}$。\n* 如果有 $\\textbf{S}<:\\textbf{T}$ 且 $\\textbf{S}:>\\textbf{T}$，那么 $\\textbf{S}$ 与 $\\textbf{T}$ 等价。即Subtyping关系是反自反的。\n\n更对于函数类型的Subtyping有：\n\n* ${\\displaystyle T_{1}≤:S_1\\quad S_2≤:T_{2} \\over \\displaystyle S_1→S_2≤:T_1→T_2}$，即对于 $S_1→S_2$，输入 $S_1$ 是逆变的，输出 $S_2$ 是协变的 $^{*4}$。\n\n## Playground\n\nNothing to play with.\n\n---\n\n### 注解\n\n1. 由里氏代换原则（Liskov substitution principle）：\n   * 子类可以扩展超类的功能，但不能改变超类原有的功能。\n   * 子类可以实现超类的抽象方法，但不能覆盖超类的非抽象方法。\n   * 子类在实现超类抽象方法时，输入要更加宽松，而输出要更加严格。\n\n2. 即对于 $S$、$T$ ，下列任何情况都是可能的：  \n   * $S$ 既不是 $T$ 的子类型，也不由其派生。\n   * $S$ 是 $T$ 的子类型，但不由其派生。（考虑Float与Double\n   * $S$ 不是 $T$ 的子类型，但由其派生。（考虑对象上下文下的函数类型，即对于 $S$ 派生自 $T$，$S$ 的函数 $f$ 必定满足 $S→S≤:T→T$，而根据函数类型的Subtyping规则可以逆推得到 $T ≤: S$ 且 $S ≤: T$，这就意味着 $S$ 与 $T$ 等价。换句话说，是 $S→S≤:T→T$，而不是 $S≤:T$。\n   * $S$ 既是 $T$ 的子类型，又由其派生。\n\n3. 考虑谓词函数 $P_T$ 和 $P_S$，对于域 $D$ 上的 $\\textbf{S}<:\\textbf{T}$ ：  \n   $T=\\{\\ x∈D\\ |\\ P_T(x)\\ \\}$  \n   $S=\\{\\ x∈D\\ |\\ P_T(x)∧P_S(x)\\ \\}$  \n   显然，$\\textbf{T}$ 是 $\\textbf{S}$ 的一部分。\n\n4. 对于函数超类型 ${T_1→T_2}$，不难理解其子类型 ${S_1→S_2}$ 的输入参数应该更加“泛化”以容纳更多的输入，而输出类型应该更加“特化”以被更多的函数接受，因为只有这样才能做到 ${T_1→T_2}$ 可以被 ${S_1→S_2}$ 安全代换。\n	2021-12-15 22:57:50	2021-12-15 22:57:50	2021-12-15 22:57:50	12	Subtyping	1001
12369	<img src="https://cdn.thaumy.cn/old_post/arduino_clock2.jpg" width="100%">\n\n&emsp;&emsp;高中生活开始后，时间很是紧张，很少有机会接触程序了。因为宿舍没有闹钟的问题，忽然就想到了单片机开发。并希望借此过程学习一下单片机知识，客制化一个闹钟。那么故事就此展开。\n\n## 为什么选择<a href="https://baike.baidu.com/item/Arduino/9362389?fr=aladdin">Arduino</a>\n\n&emsp;&emsp;单片机的选择有很多种，但是我能耳熟能详的也就是51（<a href="https://baike.baidu.com/item/stc89c51/2895810?fr=aladdin" target="_blank">STC89C51</a>，以下简称51）和Arduino系列。经过详细查阅，发现51貌似需要更高的硬件基础（例如汇编一类），而Arduino则入门门槛较低。根据实际情况考虑，51的专业水平在目前的阶段我是不具备也是没有能力具备的，虽然选择51可能能让我更好的了解IC的运行机制与原理。最终考虑到学业和时间上的不允许，我购买了我的第一块Arduino开发板：Arduino UNO R3（一款基础型Arduino开发板）（以下简称UNO R3或UNO）。\n\n<img src="https://cdn.thaumy.cn/old_post/arduino_clock1.jpg" width="100%">\n\n## Arduino系列有开发板可供选择\n\n&emsp;&emsp;选择UNO R3时我经过了详尽考虑，在网上查阅资料得知UNO R3这款开发板有很多例程和项目，很适合初学者使用。知乎上的几位大佬也推荐使用UNO R3。相较于其他开发板，UNO的优点是它较为中庸的性能和配置（集成少，io定义合理），对于进一步学习其他型号的Arduino开发板能打下更好的基层经验。所以我选择了这款开发板（受到以前隔壁群的一位硬件大佬使用 MEGA2560 的影响，我一开始很想搞一块<a href="https://baike.baidu.com/item/Mega2560/973064?fr=aladdin">MEGA2560</a>来玩玩）。开箱之后，包装盒上的“我们热爱开源”字样深深地吸引了我（我也比较倾向于开源，并且想让自己做出的开源项目使大家受益），更加增益了我对Arduino的兴趣。拿到开发板，我的第一印象是UNO很小巧，大概比我预想的小了半倍。随之则是商家附加的一些入门原件：传感器、数码管、各色的发光二极管、面包板、光盘······虽然为数不多，但是对于我的入门探索已经是一个很广阔的空间了。\n\n## 再谈谈开发过程。\n\n&emsp;&emsp;由于对于单片机的不了解，我首先看了一些商家赠送的光盘例程。然后根据教程上机试验了一下程序，发现Arduino的开发并不像我想象中的那样困难。在掌握具体的原件针脚定义后，软件层面的代码编写简直如鱼得水。Arduino为开发者提供了多种开发方式，官方的ArduinoIDE使用C语言进行开发，并不需要涉及硬件底层知识。因为对C的接触有了一段时间，我并没有出现什么语言上的困难（这也是我选择Arduino的原因），反倒是一些电学的物理知识和各种排线的接法搞得我很头疼（在接四位数码管的时候我竟然接了半小时才成功）。虽然过程比较复杂，但是学起来还是很带劲的。Arduino把面向过程的C语言作为开发语言，同时又非常非常多的库文件支持，这都让单片机的开发过程相较于51而言更加容易，让人更容易专注于功能实现而非硬件调试，这让整个过程轻松而不失活力，也让我明白了有人把Arduino比作“电子积木”的原因。ArdunioIDE集成了许多基层的Arduino库，这使得你不需要涉及过多的底层代码，而专注于你的开发目标。不用涉及复杂的汇编和底层逻辑相信是很多硬件开发者的梦想，Arduino则很好的做到了这一点。扩大编程粒度、淡化细节过程的高级语言起到了关键性的作用，它为我们节省了大量的开发时间。硬件编程给我打开了新的思绪，它不像软件编程一样在解决某种程度上的bug时没有头绪。在这里更多的则是逻辑上的问题，将程序的运行过程在眼前实例化使我在调试中倍感轻松。\n\n&emsp;&emsp;Arduino在功耗方面还是十分优秀的(貌似这是单片机的共性，也可能是我以前从未接触过单片机而产生这样的误解。经过我的充电宝续航测试表名，Arduino单片机的功耗控制是低于我的预期的)，它相对强大的性能足以满足我现阶段的学习。上万的烧写次数在某种程度上给我节省了些许钱财（穷）。\n\n<img width="50%" src="https://cdn.thaumy.cn/old_post/arduino_clock3.jpg">\n\n文章的最后，我希望能把这块板子利用好，进一步提升我的知识层次。	2017-12-02 07:06:14	2018-04-14 22:52:19	2018-04-14 22:52:19	12	Arduino单片机开发体验	1001
12447	> 最近在了解网络层控制平面的一些东西，接触到了链路状态路由选择算法(LS)和距离向量路由选择算法(DV)。  \n\n&emsp;&emsp;**链路状态路由选择算法**(Link-Stage,LS)是OSPF的一种典型实现，它是全局式的，即通过接收来自各个节点的**链路状态广播**(Link state broadcast)来掌握完整的网络拓扑结构信息。\n\n在理解LS算法的基础上，尝试使用F#构建源节点u到目的节点z的路由选择模拟。\n\n考虑以下代码：\n\n<pre>F#<code class="fs">//Typical Internet node\ntype Node =\n    { Name: string\n      Neighbors: list&lt;C&gt;\n      mutable D: int\n      mutable p: string }\n\n//Cost from a node to node B\nand C = { B: string; cost: int }\n</code></pre>\n\n`Node`代表了一个路由器节点n，它具有：  \n\n* 路由器名(Name)\n* 一个邻居集合(Neighbors)\n* n到起始节点u的开销D(n)\n* 由n路由到z的上一个节点p(n)\n\n`C`代表由某节点n到节点B（B是n的邻居，即B和n是直连的）的开销cost，即c(n,B)。\n\n&emsp;&emsp;显而易见，由以上数据类型，我们能够构造出任意规模的网络拓扑结构，注意到以下事实是重要的：在真实的网络拓扑结构中，链路开销是有向的，即c(A,B)与c(B,A)在多数意义上并不完全等价。但这一简化的前提有助于我们了解LS算法的基本内容，仍具有一般性。\n\n<center><img style="width:60%;min-width:320px" src="https://cdn.thaumy.cn/md-img/模拟链路状态路由选择算法(LS)/图1d1.svg"></center>\n<center>图1.1 源u和目的地z所处的网络</center><br>\n\n&emsp;&emsp;为此，对于`图1.1`中给出的网络拓扑结构（注意到该结构是简化的现代网络拓扑结构），我们抽象出如下关系：  \n\n&emsp;&emsp;对于该网络拓扑结构**G=(N,E)**，任一路由**节点N**由若干**链路E**与其相连。任一链路E由**节点对(x,y)**组成，规定其链路开销为**c(x,y)**，称y为x的**邻居**。由x路由至y历经的节点序列称**路径**，如(x,y,z,w)就是一个由x路由至w的路径。\n\n考虑以下代码：  \n\n<pre>F#<code class="fs">let rec u =\n    { Name = "u"\n      Neighbors =\n          [ { B = "v"; cost = 2 }\n            { B = "x"; cost = 1 }\n            { B = "w"; cost = 5 } ]\n      D = 0\n      p = "Nil" }\n\nand v =\n    { Name = "v"\n      Neighbors =\n          [ { B = "u"; cost = 2 }\n            { B = "x"; cost = 2 }\n            { B = "w"; cost = 3 } ]\n      D = Int32.MaxValue\n      p = "Nil" }\n\nand w =\n    { Name = "w"\n      Neighbors =\n          [ { B = "u"; cost = 5 }\n            { B = "x"; cost = 3 }\n            { B = "v"; cost = 3 }\n            { B = "y"; cost = 1 }\n            { B = "z"; cost = 5 } ]\n      D = Int32.MaxValue\n      p = "Nil" }\n\nand x =\n    { Name = "x"\n      Neighbors =\n          [ { B = "u"; cost = 1 }\n            { B = "v"; cost = 2 }\n            { B = "w"; cost = 3 }\n            { B = "y"; cost = 1 } ]\n      D = Int32.MaxValue\n      p = "Nil" }\n\nand y =\n    { Name = "y"\n      Neighbors =\n          [ { B = "x"; cost = 1 }\n            { B = "w"; cost = 1 }\n            { B = "z"; cost = 2 } ]\n      D = Int32.MaxValue\n      p = "Nil" }\n\nand z =\n    { Name = "z"\n      Neighbors =\n          [ { B = "w"; cost = 5 }\n            { B = "y"; cost = 2 } ]\n      D = Int32.MaxValue\n      p = "Nil" }\n</code></pre>\n\n&emsp;&emsp;通过观察上述代码清单，容易了解到其表述了每个节点和相邻节点之间的关系。注意到节点之间是平等的，它们并不存在如上述代码中隐式表述的层级关系，即它们是**平等**的。因此，受限于具体的开发语言用例，我们无法在同一定义平面上制造一个对于节点之间的引用平等。可以替代的方案是，存储节点的名字(Name)，并通过如下访问器查找节点名字到具体的节点对象引用：\n\n<pre>F#<code class="fs">//Get neighbor node with node name string\nexception UnexpectedNode of string\n\nlet GetNodeByName name =\n    match name with\n    | "u" -> u\n    | "v" -> v\n    | "w" -> w\n    | "x" -> x\n    | "y" -> y\n    | "z" -> z\n    | _ -> raise (UnexpectedNode("Given node does not exist"))\n</code></pre>\n\n&emsp;&emsp;注意到使用此方法建立平等引用是*不优雅*的，因为基于字符串标识的对象查找为读者理解节点之间的查找增加了语义层面的难度。更好的一种实现方法是使用**延迟初始化**（即将对象之间相互的嵌套引用延迟到所有对象已在内存中准备完成时），我们在DV算法的模拟中使用这种方式。  \n&emsp;&emsp;同时，构造如下函数以计算相邻节点的链路开销c(A,B)和比较从源u到当前节点n的最小链路开销D：\n\n<pre>F#<code class="fs">//Cost between neighbor A and B\nlet c (A: Node) (B: Node) =\n    let mutable neighborCost = Int32.MaxValue\n\n    for c in A.Neighbors do\n        if c.B = B.Name then\n            neighborCost <- c.cost\n\n    neighborCost\n\nlet minD a b = if a > b then b else a\n</code></pre>\n\n&emsp;&emsp;节点集合N是一个包含`图1.1`中网络拓扑结构的完全列表，列表N'反映了当前已经被计算过的节点，NotInN'提供了一个仅存在于N中的节点列表，但其内部逻辑不应被看作是LS的一部分（注意到NotInN'是**动态**的，即在节点被陆续添加到列表N'时，NotInN'的每次调用结果是**不同**的）：\n\n<pre>F#<code class="fs">//init\nlet N = [ u; v; w; x; y; z ]\nlet N' = new List<Node>()\nN'.Add u\n\n//Nodes in N but not in N'\nlet NotInN' () =\n    [ for el in N do\n          let exist =\n              let mutable found = false\n\n              for it in N' do\n                  if el.Name = it.Name then\n                      found <- true\n                  else\n                      ()\n\n              found\n\n          if not exist then el ]\n</code></pre>\n\n&emsp;&emsp;由此，在LS算法的参与下，链路开销将被循环计算n(n+1)/2次，即在最差情况下（每循环查找都被完整进行，不存在优化），其时间复杂度为O(n^2)。注意到在LS算法的其他实现中（通常更加复杂），具有使用**堆**(Heap)对`*`处的最小值查找进行优化（将线性时间转换为对数时间）的用例，因而减小其时间复杂度。本文仅考虑最一般的LS实现(Dijkstra)：\n\n<pre>F#<code class="fs">for n in N do\n    if n.Name <> "u" then\n        for neighbor in n.Neighbors do\n            if neighbor.B = u.Name then\n                n.D <- c n u\n                n.p <- "u"\n\nwhile N.Length <> N'.Count do\n    let mutable minimumD = Int32.MaxValue\n\n    let mutable minimumNode =\n        { Name = "Nil"\n          Neighbors = []\n          D = Int32.MaxValue\n          p = "Nil" }\n\n    for n in NotInN'() do //*\n        if n.D < minimumD then\n            minimumD <- n.D\n            minimumNode <- n\n\n    N'.Add minimumNode\n\n    for n in minimumNode.Neighbors do\n        let Ni = GetNodeByName(n.B) //Ni is node instance\n        let oldNiD = Ni.D\n        //set Dn\n        Ni.D <- min Ni.D (minimumNode.D + c minimumNode Ni)\n        //set pn\n        if Ni.D <> oldNiD then\n            Ni.p <- minimumNode.Name\n\nfor n in N' do\n    Console.WriteLine $"D{n.Name} = {n.D.ToString()}  p{n.Name} = {n.p} "\n</code></pre>\n\n输出结果与实际最小开销路由完全一致：\n\n<pre>Console<code class="plaintext">Du = 0  pu = Nil\nDx = 1  px = u\nDv = 2  pv = u\nDy = 2  py = x\nDw = 3  pw = y\nDz = 4  pz = y\n</code></pre>\n\n即由u到z的路由选择为：u→x→y→z  \n\n&emsp;&emsp;其中，Dn的输出顺序在具有相同到源最小开销的节点之间并无意义（如v与y，它们到源u的最小开销D均为2），其顺序取决于列表N中v与y的先后顺序。  \n&emsp;&emsp;注意到尽管`图1.1`在论述中被表述为是一个**无向图**，但我们可以通过简单的修改使其轻易地扩展为一个**有向图**用例（通过建立节点间的不对等开销），但这种修改在本文的LS实现逻辑中的合法性并未经受论证，故其拟合性有待考量。  \n&emsp;&emsp;选择函数式语言实现该算法是基于其易于理解的语义考量，注意到我们并没有应用函数式高级特性以构建无副作用的实现也是由于这个原因。\n\n&emsp;&emsp;关于链路状态路由选择算法的模拟讨论到此为止，有关距离向量算法的讨论参见[模拟距离向量路由选择算法(LS)](./12448)\n	2021-03-21 01:33:45	2021-03-25 17:10:55	2021-03-25 17:10:55	12	模拟链路状态路由选择算法(LS)	1001
12387	\n喜欢写代码、与自己战斗、宅与简单纯粹的事情。\n\n## Social Media\n\n[Telegram](https://t.me/Thaumyy)  \n[Matrix](https://matrix.to/#/@thaum:matrix.org)  \n[GitHub](https://github.com/Thaumy)  \nDiscord Thaumy#0600\n\n乐意使用邮件交流：\n\nlove@thaumy.cn  \nthaumy@outlook.com\n\n## 目前可以公开的情报\n\n### [异次元履历](https://www.thaumy.cn/12492)  \n\n### [技术栈](https://www.thaumy.cn/12493)  \n\n### [书橱](https://www.thaumy.cn/12494)  \n\n### [句摘](https://www.thaumy.cn/12379)  \n\n### [线索](https://www.thaumy.cn/12495)  \n	2019-06-16 07:12:31	2022-04-29 08:10:59	2022-11-22 17:03:26	12	我	1001
12366	&emsp;&emsp;在上周进行网站优化和日常维护中，我发现ajax插件在一定程度上造成了我博客的臃肿，过于庞大的插件使我需要一个全新的方式载入文章。于是我查找了诸多文档，终于发现了更好的解决方案。值得注意的是，它适合绝大多数架构规范的网站，不仅仅局限于wordpress——这里是详细的解决方案。\n<ul>\n \t<li><span style="color: #ff9900;">准备工作</span></li>\n</ul>\n\n&emsp;电脑一台，十分钟的阅读时间和十分钟的部署时间。  \n&emsp;注意，这篇教程不面向前端零基础的读者，如果你连header.php都找不到，那么请使用插件达到目的。  \n\n<blockquote>\n<span style="color: #00ccff;">或许这篇文章更适合你：</span><br>\n<span class="wd-dt5 cur" onclick="up();showPost(12347)">AdvancedAjaxPageLoader插件实现全站ajax</span><br>\n<span style="color: #00ccff;">&lt;跳往博客文章的超链接↑&gt;</span></blockquote>\n<ul>\n \t<li><span style="color: #ff9900;">项目资源</span></li>\n</ul>\n\n<pre>JS<code>\nvar ajaxhome="您的站点地址";var ajaxcontent="被刷新的文章容器id";var ajaxsearch_class="searchform";var ajaxignore_string=new String("#, /wp-, .pdf, .zip, .rar, /goto");var ajaxignore=ajaxignore_string.split(", ");var ajaxloading_code="此处添加加载动画代码";var ajaxloading_error_code="此处添加超时代码";var ajaxreloadDocumentReady=false;var ajaxtrack_analytics=false;var ajaxscroll_top=true;var ajaxisLoad=false;var ajaxstarted=false;var ajaxsearchPath=null;var ajaxua=jQuery.browser;jQuery(document).ready(function(){ajaxloadPageInit("")});window.onpopstate=function(event){if(ajaxstarted===true&&ajaxcheck_ignore(document.location.toString())==true){ajaxloadPage(document.location.toString(),1)}};function ajaxloadPageInit(scope){jQuery(scope+"a").click(function(event){if(this.href.indexOf(ajaxhome)>=0&&ajaxcheck_ignore(this.href)==true){event.preventDefault();this.blur();var caption=this.title||this.name||"";var group=this.rel||false;try{ajaxclick_code(this)}catch(err){}ajaxloadPage(this.href)}});jQuery("."+ajaxsearch_class).each(function(index){if(jQuery(this).attr("action")){ajaxsearchPath=jQuery(this).attr("action");jQuery(this).submit(function(){submitSearch(jQuery(this).serialize());return false})}});if(jQuery("."+ajaxsearch_class).attr("action")){}else{}}function ajaxloadPage(url,push,getData){if(!ajaxisLoad){if(ajaxscroll_top==true){jQuery("html,body").animate({scrollTop:0},1500)}ajaxisLoad=true;ajaxstarted=true;nohttp=url.replace("http://","").replace("https://","");firstsla=nohttp.indexOf("/");pathpos=url.indexOf(nohttp);path=url.substring(pathpos+firstsla);if(push!=1){if(typeof window.history.pushState=="function"){var stateObj={foo:1000+Math.random()*1001};history.pushState(stateObj,"ajax page loaded...",path)}else{}}if(!jQuery("#"+ajaxcontent)){}jQuery("#"+ajaxcontent).prepend(ajaxloading_code);jQuery("#"+ajaxcontent).fadeTo("slow",0.4,function(){jQuery("#"+ajaxcontent).fadeIn("slow",function(){jQuery.ajax({type:"GET",url:url,data:getData,cache:false,dataType:"html",success:function(data){ajaxisLoad=false;datax=data.split("&lt;title>");titlesx=data.split("&lt;/title>");if(datax.length==2||titlesx.length==2){data=data.split("&lt;title>")[1];titles=data.split("&lt;/title>")[0];jQuery(document).attr("title",(jQuery("&lt;div/>").html(titles).text()))}else{}if(ajaxtrack_analytics==true){if(typeof _gaq!="undefined"){if(typeof getData=="undefined"){getData=""}else{getData="?"+getData}_gaq.push(["_trackPageview",path+getData])}}data=data.split('id="'+ajaxcontent+'"')[1];data=data.substring(data.indexOf(">")+1);var depth=1;var output="";while(depth>0){temp=data.split("&lt;/div>")[0];i=0;pos=temp.indexOf("&lt;div");while(pos!=-1){i++;pos=temp.indexOf("&lt;div",pos+1)}depth=depth+i-1;output=output+data.split("&lt;/div>")[0]+"&lt;/div>";data=data.substring(data.indexOf("&lt;/div>")+6)}document.getElementById(ajaxcontent).innerHTML=output;jQuery("#"+ajaxcontent).css("position","absolute");jQuery("#"+ajaxcontent).css("left","20000px");jQuery("#"+ajaxcontent).show();ajaxloadPageInit("#"+ajaxcontent+" ");if(ajaxreloadDocumentReady==true){jQuery(document).trigger("ready")}try{ajaxreload_code()}catch(err){}jQuery("#"+ajaxcontent).hide();jQuery("#"+ajaxcontent).css("position","");jQuery("#"+ajaxcontent).css("left","");jQuery("#"+ajaxcontent).fadeTo("slow",1,function(){})},error:function(jqXHR,textStatus,errorThrown){ajaxisLoad=false;document.title="Error loading requested page!";document.getElementById(ajaxcontent).innerHTML=ajaxloading_error_code}})})})}}function submitSearch(param){if(!ajaxisLoad){ajaxloadPage(ajaxsearchPath,0,param)}}function ajaxcheck_ignore(url){for(var i in ajaxignore){if(url.indexOf(ajaxignore[i])>=0){return false}}return true}function ajaxreload_code(){}function ajaxclick_code(thiss){jQuery("ul.nav li").each(function(){jQuery(this).removeClass("current-menu-item")});jQuery(thiss).parents("li").addClass("current-menu-item")};</code></pre>\n\n复制以上代码，在相关编辑器中新建一个js文件并拷贝进去，等待下一步指示。  \n\n### 你需要格式化以上代码才能正确阅读。\n\n接下来，我们需要修改代码中的某些部分，以保证代码在你的网站中能够达到您预期的效果。\n<br><br>\n\n<h3 style="color: #ff9900;">修改以下代码</h3>\n\n<pre>JS<code>var ajaxhome='http://www.thaumy.cn';</code></pre>\n您的站点地址，例如我的网站主页地址为 http://www.thaumy.cn ，那么这里就可以填写http://www.thaumy.cn\n<br><br>\n\n<pre>JS<code>var ajaxcontent = '被刷新的文章容器id';</code></pre>\n被刷新的文章容器id，指的是文章列表(postlist)的父级id。例如我的id是 Central ，那么这里就可以填写Central\n<br><br>\n\n<pre>JS<code>var ajaxsearch_class = 'searchform';</code></pre>\n搜索栏目的id，默认为 searchform ，一般不用更改\n<br><br>\n\n<pre>JS<code>var ajaxignore_string = new String('#, /wp-, .pdf, .zip, .rar, /goto');</code></pre>\n\n被屏蔽的加载项目，即不进行pjax加载的链接关键字，默认为 #, /wp-, .pdf, .zip, .rar, /goto ，一般不用更改\n<br><br>\n\n<pre>JS<code>var ajaxloading_code = '此处添加加载动画代码';&lt;br&gt;</code></pre>\n此处添加加载动画代码，使pjax加载时显示动画，例如我的蓝色线条加载动画，这里不过多解释\n<br><br>\n\n<pre>JS<code>var ajaxloading_error_code = '此处添加超时代码或一些文本';</code></pre>\n此处添加超时代码或一些文本，例如pjax请求失败时，文章容器所显示的内容  \n<br>\n\n<h3 style="color: #ff9900;">将以上代码修改完成后，复制修改好的代码，使用 &lt;script&gt;&lt;/script&gt; 标签把代码块插入到 header.php 的 &lt;/head&gt; 之前，然后就能实现网站的pjax加载了。</h3>\n\n虽然此方法能够完成需求，但是我并没有这样做，因为在 header.php 中插入大量的代码会让博客显得很臃肿。我的建议是把js做cdn加速，然后使用wordpress自带的函数进行注册排队后正确引用，该方法在wordpress大学有明确的帮助文档：<a href="https://www.wpdaxue.com/wordpress-include-jquery-css.html">wordpress大学</a></span>\n\n> 使用AdvancedAjaxPageLoader插件实现的全站ajax的教程文章已归档，该插件存在兼容性问题，已经不推荐使用。	2017-07-26 09:16:30	2018-04-14 22:53:20	2018-04-14 22:53:20	28	通用化站点pjax解决方案	1001
12429	IDBuilder是一款基于当前时间生成多种标识码的实用工具，开发的初衷是便于我快速生成GUID和为小文件命名。  \nIDBuilder3.1后续会于WindowsStore上线，目前可用的版本为3.0，使用UWP构建。	2020-09-10 17:54:20	2020-09-10 17:54:58	2020-09-10 17:54:58	28		1001
12489	# FAQ\n\n<details>\n  <summary>这是什么网站？</summary>\n  这是我的博客，我希望通过这种形式来向你讲述我所热爱的一切。\n</details>\n\n<details>\n  <summary>为什么我很长时间都无法看到文章更新？</summary>\n  记录生活是我生活的一部分，但不是全部。尽管让博客充满文章对我也很具有吸引力，但这丧失了真实。另一方面，我希望让每一篇文章都充满意义，如果最近无事发生，我是不会去更新博客的。\n</details>\n\n<details>\n  <summary>评论系统为什么会要求填写我的邮箱？</summary>\n  这是为回复通知功能设计的，但该功能尚不可用。如果你的评论被他人回复了，回复通知功能会以邮件的形式通知你。你的隐私权十分重要，我仅会检查邮箱格式是否合法，所以你大可编造一个假的邮箱填上去。如果你的邮件地址被滥用了，请联系我以解绑邮件通知。\n</details>\n\n<details>\n  <summary>为什么我无法评论？</summary>\n  请仔细检查你是否按照要求来填写评论框的信息。如果你想填写个人网站，请填写完整的URL，例如：https://www.thaumy.cn\n</details>\n\n<details>\n  <summary>为什么这个博客的设计给我了一种一成不变的感觉？</summary>\n  虽然本博客所采用的pilipala系统一直在持续演进，但这套界面风格（即主题）是保持了相当长的时间的。通常主题的更新周期要长一些。\n</details>\n\n<details>\n  <summary>这个网站有BUG。</summary>\n  这个网站仍处于开发阶段，我时不时地维护它以保持可用。但对于一些系统性缺陷，打补丁式的修补方式显然不是优雅的，于是我会在下个版本的设计中避免它们。而下个版本通常又会带来一些新的问题......\n</details>\n\n<details>\n  <summary>我能够在这里看到敏感话题吗？</summary>\n  目前看不到。但我不做保证以后不会讨论这些话题，因为我是一个言论自由的坚定支持者。虽然我对这些话题有独到的个人见解，但也希望在讨论这类问题时能够做到客观全面，因为我不希望让自己的发言显得很廉价。\n</details>\n\n<details>\n  <summary>我看到的博客是最新的吗？</summary>\n  无论从内容角度还是从技术角度来看，在你屏幕前展现的博客都不是最新的。有相当一部分内容需要按照计划公开，也有相当一部分技术特性被安置在了下一个系统版本。\n</details>\n\n<details>\n  <summary>如何了解本站的近期改动？</summary>\n  请查看维护日志，那里记录了本站点开设以来的所有事件。\n</details>\n\n<details>\n  <summary>这个网站不够安全。</summary>\n  对本站点的安全性考量基于如下方面：\n  \n* 达到比较高的安全性需要持续的经济开销\n* 许多功能尚处于开发阶段，引入的安全层随时都会随着版本更新而不可用\n* 此网站从未遭受攻击，而我有非常完备的恢复措施\n* 我对信息安全的经验不足\n\n  因而本站点仅作最基础的安全防护。\n  \n</details>\n	2021-12-17 14:15:18	2021-12-17 14:15:47	2021-12-17 14:15:47	12	FAQ	1001
12494	> 知识就是力量，\n\n|                ?                |   ?   |\n| :-----------------------------: | :---: |\n|          C Primer Plus          |  10%  |\n|         C#从入门到精通          |  80%  |\n|          C#6.0学习笔记          |  30%  |\n|       ASP.NET从入门到精通       |  25%  |\n|           高性能MySQL           |  99%  |\n|              三体               | 100%  |\n|    Python编程: 从入门到实践     |  43%  |\n|         Kotlin核心编程          |  99%  |\n|     JavaScript高级程序设计      |  20%  |\n|     计算机网络:自顶向下方法     |  99%  |\n|           异类的天赋            |  50%  |\n|              LYaH               |  99%  |\n|         精通正则表达式          |  58%  |\n| 数据结构算法与应用: C++语言描述 |  80%  |\n|           精通比特币            |  99%  |\n|          Rust程序设计           |  99%  |\n|       深入理解计算机系统        |  99%  |\n|            编译原理             |  20%  |\n|       深入理解Kotlin协程        |  99%  |\n|     计算机程序的构造和解释      |  99%  |\n|         Go语言核心编程          |  99%  |\n|         编程与类型系统          |  99%  |\n\n列表顺序按开始阅读时间由早到晚。\n\n> 但更重要的是运用知识的技能。\n	2022-02-08 12:56:48	2022-07-31 20:21:36	2022-07-31 20:21:36	12	书橱	1001
12496	# 每月评论\n\n> 每月评论 - 第九期\n\n* 受限于各类因素，每月评论将按需发行。\n\n---\n\n## 戒断反应\n\n最初喝咖啡是出于调节作息考虑。  \n&emsp;&emsp;由于最近几个月都非常忙，所以大概喝了三个月的咖啡，每天一到两杯，一直没停。但不幸的是，前几天咖啡喝完了，又没来得及买新的。。。于是我第一次体会到了咖啡的戒断反应：一天都没有精力、极度嗜睡和头痛。  \n虽然科学研究表明适量的咖啡摄入（每天三杯左右）对健康有益无害，但我觉得还是少喝为妙。  \n&emsp;&emsp;我可以不喝咖啡，但并不是人人都可以不喝咖啡。  \n&emsp;&emsp;那些勤劳的人们是否能够享受他们应有的回报，这既需要思考，又不需要思考。\n\n## 新学期马上开始\n\n这学期的课无聊透顶！  \n&emsp;&emsp;C#还用学？这句话并非产自傲慢，而是出于对教学质量的担忧。我敢肯定的是课程所教授的C#绝对还停留在6.0时代，操着那老旧的VS2013和狗都不用的.NET Framework，向学生们讲述一个“不如java”的语言的故事。  \n&emsp;&emsp;Java还用学？现在都是Kotlin的时代了，我真正需要了解的是JVM和它的生态，但学校一定不会多讲。  \n&emsp;&emsp;数据库的话，我可不想为了学这门课去装什么SQL Server，甚至是搞什么破解版的Oracle...教材中的数据库理论已经与现代化数据库特性产生了较大偏差，正处于十分尴尬的地位。\n\n体制内的学校是这样的。  \n&emsp;&emsp;学校的名次与政治相关，教师的晋升不需要开拓学新的知识领域，学生看不到知识的未来：大家都在这有限的资源里“精耕细作”，深入研究内卷的功效与心得，也深信大家都有美好的未来。\n\n## 《三体》\n\n> 不含有剧透内容，可放心阅读。\n\n当初打算在动画化之前都不会读完的，但我终究还是没熬得过艺画开天。\n\n我用近乎两年的时间看完了这本小说，并给予它极高评价。  \n&emsp;&emsp;为什么读了这么长时间？我对《三体》是极度珍视的，正所谓看一页就少一页，我秉持着“能不读就不读，如果读，一定要带着最大的期望和好奇去读”的原则去读这本书，让我的每一次阅读都尽可能地成为享受，而不是为了追剧情而读个通宵达旦，以至疲倦甚至“跳读”。\n\n当我以期待的目光翻到故事的下一页时，却发现一片空白。  \n&emsp;&emsp;《三体》就这样在我的阅读生涯中结束了，成为无价的回忆。\n\n特别感谢Nick，是他赠予了我《三体》三部曲的纸质书籍，将我引入如此浩瀚的宇宙图景。\n\n---\n\n&emsp;&emsp;人人生而平等。\n\n---\n\n<div align="right">\n\n每月评论 - 2202期(共9期)  \n撰稿&校对&审核：Thaumy\n\n</div>\n	2022-02-22 20:50:26	2022-02-22 20:51:10	2022-02-22 20:51:10	12	每月评论2202	1001
12485	# Type Constructor\n\n类型构造器\n\n## 概要\n\n类型构造器是一种用于构造类型的容器。类型构造器往往缺少一个至多个类型参数（Type Parameter），而通过传入这些类型参数，我们可以构造出具体类型（Specific Type）。\n\n## 区分类型构造器与值构造器\n\n在命令式语言中，类型构造器和值构造器（Value Constructor）的区分通常是难以理清的。\n\n例如`ArrayList<E>`：\n\n```Java\nArrayList<Integer> list = new ArrayList<Integer>() {{\n    add(1);\n    add(2);\n    add(3);\n}};\n```\n\n所谓的`ArrayList<Integer>`，是由类型构造器`ArrayList<E>`通过接收一个类型参数`Integer`而产生的具体类型，而`[1,2,3]`（伪代码）是这个具体类型的值。既然类型都有构造器，那值的构造器去哪了？  \n实际上值构造器被隐藏在`ArrayList<E>`的具体实现里了，也就是说`ArrayList<E>`的具体实现就是它的值构造器。\n\n更进一步地，对于相同的类型，它的类型构造器只能有一个，而值构造器可以有多个。不同的值构造器可以构造出不同的值，但这些值的类型都是其对应的类型构造器构造出的具体类型。\n\n这是什么意思呢？请看这个类型构造器`Tree`$^{*1}$：\n\n```Java\n//代码样例1\nclass Tree {}\nclass Node extends Tree {}\nclass Leaf extends Tree {}\n```\n\n`Node`和`Leaf`可以看作是类型构造器`Tree`的值构造器，它们可以构造出Node类型的值，也可以构造出Leaf类型的值，但这些值也都是Tree类型的。同样地，值构造器也可以具有参数（值参数），比如我们给Leaf的构造函数增加一个参数：\n\n```Java\n//代码样例2\nclass Leaf extends Tree {\n    public int val;\n    public Leaf(int val) {\n        this.val = val;\n    }\n}\n```\n\n我们可以构造代数（Algebra）的值构造器（如具有无参构造函数的Leaf），也可以构造函数的值构造器（如具有具参构造函数的Leaf）。\n\n## 更进一步的思考\n\n仔细想想，实际上值和函数没有什么区别，只不过前者是无参的，也是自调用（Self Invoking）的。  \n实际上函数和值构造器也没什么区别，因为它们都接收值，并且产生值。\n\n于是我们可以想象，值和值构造器（在某个层次上）应该也没有区别！\n\n```Java\nArrayList<Integer> list = new ArrayList<Integer>();\n```\n\n在以上代码中，我们用类型构造器`ArrayList<E>`和所需的类型参数`Integer`构造了类型`ArrayList<Integer>`，并用其对应的类型构造器构造了一个值（空列表）。\n\n那么对于`int i = 1;`，我们使用类型构造器`int`（只不过是无参的而已）构造了类型`int`，使用对应的值构造器构造了值`1`。而这个值`1`的值构造器实际上就是`1`，就像值`Leaf`的值构造器实际上就是`Leaf`一样（在构造函数无参的情况下）。\n\n显然值构造器和值在某种层面上是一致的，这个层面就是**类型**（Type）。类型是为了描述值$^{*2}$而存在的。\n\n甚至你可能有这样一种感觉：实际上类型构造器与函数也没什么区别，只不过它是类型层面上的函数而已。  \n如果把类型比作值，把类型构造器比作值构造器，那么我们也可以发现在某种层面上（例如无参的类型构造器）类型和类型构造器也具有一致性。\n\n这种一致性由**阶**（Kind）来描述。  \n\n对于一个具体的类型，它的阶是 $*$，而对于一个需要有一个类型参数才能构造完全的类型（如`ArrayList<E>`），它的阶是 $*→*$，以此类推。\n\n## 形式化的类型构造器\n\n类型构造器实际上是类型函数。\n\n对于类型构造器`ArrayList<E>`，我们认为它接受一个类型参数E并产生一个类型A：\n\n`ArrayList<E>`$\\ :=ΛE:*.\\ A:*→*$\n\n对于类型构造器`Integer`，它不具有类型参数，因而是具体类型：\n\n`Integer`$\\ :*$\n\n考虑恒等类型构造器 $ΛT:*.\\ T:*→*$，它接收一个类型参数T并产生类型T。\n\n## 高阶函数与高阶类型\n\n高阶函数是以函数为参数的函数，例如：  \n$λf:α→β.\\ λx:α.\\ f\\ x\\ :\\ (α→β)→β$\n\n高阶类型其实和高阶函数是统一的，只不过它站在Kind的层次上。  \n$ΛF:*→*.\\ ΛX:*.\\ F\\ X\\ :\\ (*→*)→*$\n\n比如在高阶类型那一章我们构造的（实际上它是一个值构造器）：\n\n```Java\npublic <T<_>> T<Integer> getIntegerContainer()\n{\n    return new T<Integer>();\n}\n```\n\n它的类型构造器是：$ΛT:*→*.\\ T\\ \\rm{Integer}\\ :\\ (*→*)→*$\n\n如果我们给它类型参数`ArrayList<E>`，那么首先它的类型构造器会构造出类型`ArrayList<Integer>`，接着该类型的值构造器将构造出一个值，它是一个可存放`Integer`的空列表。\n\n## 于Kind之上\n\n能否有事物能描述Kind的统一性？\n\n我们认为所有Kind都取自集合 $\\mathbb{K}$，而 $\\mathbb{K}=\\{*,\\ \\mathbb{K}→\\mathbb{K}\\}$。因而对于 $\\mathbb{K}$，其中所有的Kind都具有相同的“类型”，它就是 $□$ 。注意这个 $□$ 不是指Type的那个 $□$ 。\n\n于是：  \n$T:*\\ :\\ □$  \n$ΛA:*.\\ B:*→*\\ :\\ □$  \n$ΛF:*→*.\\ ΛX:*.\\ F\\ X:(*→*)→*\\ :\\ □$\n\n## In λ Cube\n\n在λ立方体中，类型构造器即为 $λ\\underline{ω}$（Weak Lambda Omega），在 $λ\\scriptsize{→}$ 的后面。\n\n|    系统\\特征     |   $→$   |  $Π$  |   $ω$   |  $2$  |\n| :--------------: | :-----: | :---: | :-----: | :---: |\n| $λ\\underline{ω}$ | $(*,*)$ |   ╳   | $(□,□)$ |   ╳   |\n\n$(□,□)$ 表示 $λ\\underline{ω}$ 允许由类型构造类型。\n\n---\n\n### 注解\n\n1. 可能通过Haskell描述能看地更加清楚一些：\n\n   ```Haskell\n   data Tree = Node | Leaf --对应代码样例1\n   ```\n\n   ```Haskell\n   data Tree = Node | Leaf Int --对应代码样例2\n   ```\n\n2. 广义的值，一切具有类型的东西，都是值。\n	2021-12-15 23:00:13	2021-12-15 23:00:13	2021-12-15 23:00:13	12	Type Constructor	1001
12480	# Reverse Polish Notation\n\n逆波兰表示法\n\n## 概要\n\n逆波兰表示法是一种将数学运算符后置的计算表达式，这种表示法省去了对括号的需要且算法实现极为简单，因而被广泛实现于商业计算器中。\n\n## 问题引入\n\n一般而言，我们的数学表达式会长成这个样子：$1+2+3$  \n\n但如果遇到减法运算，那么就不得不考虑运算顺序问题，因为减法是不符合交换律的，即：$(1-2)-3≠1-(2-3)$。\n\n相似的情况还有除法运算等。\n\n为了正确表达这种计算顺序，我们引入了括号来表示运算优先级，但是括号有一个问题，那就是如果括号的嵌套非常多，那么可读性会极大地降低，例如：\n\n$3-(1-(3-2)/3-(1+2))$\n\n此表达式中的任何一对括号均不可或缺，否则计算顺序将被改变。为计算该表达式，你首先需要找到最高优先级的运算并计算出结果，如此下去，直到没有运算符为止。  \n\n目前的情况还可以解决，但当括号数量达到成百上千时，你将难以找到括号的对应关系（相信大多富有编程经验的人都明白看到这样的括号会是什么感受：)))))))))))），而计算机在分析表达式时，将为多层级语法树结构的解析付出相当大的计算资源开销，显然在受限于成本的计算设备上这样的开销需求是不现实的。\n\n## RPN\n\n为解决该问题，波兰数学家扬·武卡谢维奇在1920年引入了逆波兰表示法（此后简称为RPN）。\n\n在RPN中，运算符被后置，形如 `1-(2-3)` 的表达式在RPN中将被改写为 `1 2 3 - -` 。计算方法是：从左至右阅读RPN表达式，当遇到运算符时，取其左最邻参数与该运算符进行结合并计算，重复该过程直到表达式中无运算符为止。\n\n于是我们先前的例子就被改写为：`3 1 3 2 - 3 / - 1 2 + - -`  \n如果加上括号那么它就长这样：`3 ((1 ((3 2 -) 3 /) -) (1 2 +) -) -`（显然更加麻烦了，且不必要）  \n\n该表示法最大的优点是可利用堆栈结构减少计算机内存访问，即解析计算表达式时，按照以下步骤（假定运算符的需要的操作数数量均为2）：\n\n* 若遇到操作数，将操作数压入栈中。  \n* 若遇到运算符，从栈顶弹出（pop）两个操作数与该运算符结合，并将计算结果压入栈中。\n\n下面的Haskell代码演示了一个RPN解析器，它计算了我们上面讨论的RPN表达式：\n\n```Haskell\nparser "+" (x : y : s) = (y + x) : s\nparser "-" (x : y : s) = (y - x) : s\nparser "*" (x : y : s) = (y * x) : s\nparser "/" (x : y : s) = (y / x) : s\nparser " " s = s\nparser x s = (read x) : s\n\ncalc e s = head $ foldl (\\acc x -> parser x acc) s (words e)\n\nmain = do\n  putStrLn . show . calc "3 1 3 2 - 3 / - 1 2 + - -" $ []\n```\n\n计算结果为 `5.333333333333333`，与预期完全一致。\n\n显然你不需要理解上述代码是如何运行的，我写出这个例子只是为了说明RPN很容易被算法实现。\n\n## Playground\n\n没作业。\n	2021-12-15 22:56:32	2021-12-15 22:56:32	2021-12-15 22:56:32	12	RPN	1001
12461	# Applicative Functor\n\n应用函子\n\n## 概要\n\n**应用函子**是函子的增强版本，它允许被容器包装的函数对容器的值进行变换，并新增了一个用于包装值的函数。\n\n## 接口表述\n\n所有的应用函子都是函子，也就是说，一个容器要想成为应用函子，那么它首先需要成为函子。我们使用如下接口构造应用函子：\n\n```Kotlin\ninterface Applicative<T : Kind<T, *>> : Functor<T> {\n    override fun <A, B> Kind<T, A>.fmap(f: (A) -> B): Kind<T, B> = this.ap(f.pure())\n\n    fun <A> A.pure(): Kind<T, A>\n    fun <A, B> Kind<T, A>.ap(af: Kind<T, (A) -> B>): Kind<T, B>\n}\n```\n\n其中，`pure`函数用于把一个`A`类型的值包装成`T<A>`类型的值，`ap`函数接收一个包装在容器`T`中的函数，并通过该函数将`T<A>`变换到`T<B>`。一旦有了`pure`和`ap`，那么`fmap`就是不必要的了，因为`pure`和`ap`能构造出`fmap`。可见，应用函子是函子的增强。\n\n回到之前`Box<V>`的例子，`BoxApplicative<V>`就可以抽象如下：\n\n```Kotlin\n@Suppress("unchecked_cast")\ninterface BoxApplicative<V> : Applicative<BoxApplicative<*>>, Kind<BoxApplicative<*>, V> {\n    override fun <A> A.pure(): Kind<BoxApplicative<*>, A> = Box<A>(this) as Kind<BoxApplicative<*>, A>\n\n    override fun <A, B> Kind<BoxApplicative<*>, A>.ap(af: Kind<BoxApplicative<*>, (A) -> B>): Kind<BoxApplicative<*>, B> {\n        val a = (this as Box<A>).value\n        val f = (af as Box<(A) -> B>).value\n        return Box<B>(f(a)) as Kind<BoxApplicative<*>, B>\n    }\n}\n```\n\n由于应用函子都是函子，所以`Box<V>`继承`BoxApplicative<V>`后仍是函子：\n\n```Kotlin\nobject WithBoxApplicative : BoxApplicative<Any>\nclass Box<V>(val value: V) : BoxApplicative<V>, Kind<BoxApplicative<*>, V>\n```\n\n现在就可以把函数包装在`Box`容器内进行链式调用了：\n\n```Kotlin\nval B2 = Box<(Int) -> String> { x -> "Result is ${x + 1}" }\nval B3 = Box<(String) -> String> { x -> "Hey! $x" }\n\nval result = WithBoxApplicative.run {\n    1.pure().ap(B2).ap(B3)\n}\nprintln((result as Box).value)//Hey! Result is 2\n```\n\n不过受限于Kotlin的函数不能Currying，这里的Applicative并不能实现更复杂的函数组合（Functor也是如此）。\n\n## Playground\n\n没有作业\n	2021-12-15 22:47:45	2021-12-15 22:47:45	2021-12-15 22:47:45	12	Applicative Functor	1001
12469	# Dependent Type\n\n依赖类型\n\n## 概要\n\n**依赖类型**指的是自身类型依赖于某种类型的特定取值的类型。\n\n## 什么是依赖类型\n\n目标类型取决于某种类型的特定取值，满足这一特性的所有类型都可称作是依赖类型。\n\n`int[114514]`就是一个依赖类型，类型`int[n]`的类型因`n`的取值而不同。注意`n`在这里是一个常量，即它是编译期决定的，我们把它称为编译时依赖类型，而如果是*VLA*$^{*1}$情况，则属于运行时依赖类型。\n\n但注意`ArrayList<Integer>`不是依赖类型，因为`ArrayList<E>`依赖于类型而不是类型的特定取值，即它是`Type → Type`的，而不是`Term → Type`的。\n\n某种程度上来讲，依赖类型很像是给一个集合标上了索引。\n\n## 形式化\n\n$λx:A.\\ B$ 表示 $B$ 类型依赖于 $A$ 类型的 $x$ 的取值。\n\n更加细分的依赖数据类型有以下两种，它们分别是对积类型与和类型的更为一般的抽象。\n\n### $Π$-类型\n\n**$Π$-类型**（Pi-Type），又被称为依赖乘积类型或依赖函数类型，它是对多态函数的抽象。  \n对于*全类*$^{*2}$ $\\mathcal {U}$ 中的某一类型 $A:\\mathcal {U}$，有一类型族 $B:A→\\mathcal {U}$，则可称该类型族 $B$ 为依赖函数类型，因为其值域是随着参数而变化的（这意味着它没有一个固定的*陪域*$\\ ^{*3}$），可记为：\n\n&emsp;&emsp;$Πx:A.\\ B(x)$\n\n特别地，当 $B$ 为常值函数，依赖函数类型将退化为一般函数（乘积）类型，即类型 $Πx:A.\\ B$ 与类型 $A→B$ 等价。  \n例如，将自然数映射到实数的函数 $Πx:\\mathbb{N}.\\ \\mathbb{R}$ 就是依赖函数类型的一个特例：函数的返回类型不因 $x$ 的类型而改变。\n\n### $Σ$-类型\n\n**$Σ$-类型**（Sigma-Type），又被称为依赖总和类型或依赖数对类型，它捕获了对有序数对的抽象。  \n相似地，对于 $\\mathcal {U}$ 中的某一类型 $A:\\mathcal {U}$，有一类型族 $B:A→\\mathcal {U}$，则可称该类型族 $B$ 为依赖总和类型，可记为：\n\n&emsp;&emsp;$Σx:A.\\ B(x)$\n\n$Π$-类型也可以表示为一个有序对 $(a,b)\\ :\\ Σx:A.\\ B(x)$，$b$ 的类型依赖于 $a$ 的值，即若 $a:A$ 则 $b:B(a)$。  \n特别地，当 $B$ 为常值函数，依赖总和类型将退化为一般乘积类型，即类型 $Σx:A.\\ B$ 与类型 $A→B$ 等价。\n\n> 我个人认为，在某种意义上，$Π$-类型是对依赖值的函数的抽象，而$Σ$-类型是对归纳数据类型（如Church Encoding下的自然数）的抽象。\n\n## 语言支持性\n\n由于依赖类型会给类型系统大大增加设计的复杂度$^{*4}$，所以多常见于面向证明（Proof Orinted）的语言中，如Agda、Coq、Idris、F*等。\n\n## In λ Cube\n\n在λ立方体中，依赖类型即为 $λ\\small{Π}$，居于 $λ\\scriptsize{→}$的右侧。\n\n|  系统\\特征   |   $→$   |   $Π$   |  $ω$  |  $2$  |\n| :----------: | :-----: | :-----: | :---: | :---: |\n| $λ\\small{Π}$ | $(*,*)$ | $(*,□)$ |   ╳   |   ╳   |\n\n$(*,□)$ 表示 $λ\\small{Π}$ 允许由项构造类型。\n\n---\n\n## 注解\n\n1. 变长数组（Variable Length Array，VLA）。\n2. 由全部类型构成的类型，可理解为类型的全集。\n3. 包含值域的任何集合。\n4. > 由于确定两个依赖于值的类型的等价性需要涉及具体的计算，若允许在依赖类型中使用任意值的话，其类型检查将会成为不可判定问题；换言之，无法确保程序的类型检查一定会停机。一些以证明辅助为主要目的的编程语言采用强函数式编程（total functional programming），这消除了停机问题，同时也意味着通过它们自身的核心语言无法实现任意无限递归，不是图灵完全的，如 Coq 和 Agda；另外一些依赖类型编程语言则是图灵完全的，如 Idris、由 ML 派生而来的 ATS 和 由 F# 派生而来的 F*。————Wikipedia\n	2021-12-15 22:52:21	2021-12-15 22:52:21	2021-12-15 22:52:21	12	Dependent Type	1001
12411	最近武汉的肺炎病毒好猖狂啊，希望能早日将疫情控制住，不要造成太大损失。。。	2020-01-24 11:23:38	2020-01-24 11:24:22	2020-01-24 11:24:22	28		1001
12393	## pilipala BETA6(1902)第7步进现已结束\n\n原定于七月更新的噼里啪啦BETA6第8步进由于我的懒惰，被搁置了...  \n其实第8步进没有什么特别的内容，无非发布几篇收尾文章，做做UI更新。  \n随着氛2近期的开发完成，氛1的UI更新也显得似乎不是那么必要了。  \n于是，BETA6超额完成了它4个月的设计寿命（2018.02‎-2018.07，实际使用了接近5个月）。  \n在第8步进中，我修正了维护日志，发布了此篇文章，备份了数据库。  \n\n### 感谢pilipala BETA6陪我走过的高二半年，到这里。\n### 迫于学业压力，BETA7工程很可能被搁置。\n不过以后我还会努力写代码的( •̀∀•́ )！就这样。	2019-08-08 22:12:04	2020-10-15 06:27:37	2020-10-15 06:27:37	28	BETA6的结束和BETA7的愿望	1001
12462	# Curry-Howard Correspondence\n\n柯里-霍华德对应\n\n## 概要\n\n**柯里-霍华德对应**，又称柯里-霍华德同构（Curry-Howard Isomorphism），是数学证明和计算机程序间的紧密联系：对命题的描述可以看作是计算机程序中的类型，而对命题的证明可以看作是计算机程序的语言构造。这种高度相似表明了形式逻辑系统和公式计算（computational calculus）在一定层次上是同构的，于是我们可以用程序来进行数学证明。\n\n## 命题即类型，证明即程序\n\n对于相继式 $a_1:A_1,a_2:A_2,a_3:A_3,...,a_n:A_n\\vdash E:B$，其前件可以看作是具有一系列类型的一系列值，而后件则可看作是具体的程序构造。由命题 $a_1:A_1,a_2:A_2,a_3:A_3,...,a_n:A_n$ 证明 $E:B$ 的过程同构于给定一系列具有特定类型的值而编写计算机程序的过程，即当 $a_1,a_2,a_3,...,a_n$ 分别具有类型 $A_1,A_2,A_3,...,A_n$ 时，程序 $E$ 的运行结果将具有类型 $B$。\n\n## 与形式化证明的关联\n\n柯里霍华德同构给出了证明和程序间的密切联系，证明和程序的等价性使得数学研究工作者们可以使用辅助证明器（ Proof Assistant）来解决一些人工难以证明的数学问题。常见的面向证明（Proof Orinted）的语言有Agda、Coq、F*、Idris、Lean等。\n\n比如，我们现在使用Coq证明任何一个数乘二都等于这个数与自身相加：\n\n```Coq\nFixpoint plus (a b : nat) :=\nmatch a with\n| O => b\n| S a' => S (plus a' b)\nend.\n\nFixpoint times (a b : nat) :=\nmatch b with\n| O => 0\n| S b' => plus (times a b') a\nend.\n\nTheorem t : forall a,\n  times a 2 = plus a a.\n  intros.\n  reflexivity.\nQed.\n```\n\nCoq中的自然数采用皮亚诺公理构造，即一个数要么是0要么是0的后继。首先我们据此构造了加法和乘法，然后我们提出一个命题：`times a 2 = plus a a`，对上下文进行变量引入并化简，最终完成了证明。\n	2021-12-15 22:48:24	2021-12-15 22:48:24	2021-12-15 22:48:24	12	CHC	1001
12491	# 每月评论\n\n> 每月评论 - 第八期\n\n* 受限于各类因素，每月评论将按需发行。\n\n---\n\n## 近日无事发生\n\n我是Thaumy，又一次连接到pilipala服务器。  \n\n本可以什么都不写，但我又觉得应该去写点什么。\n\n## 来回折腾的电脑\n\n&emsp;&emsp;本来买MBP是一件挺让我高兴的事情，但情况被完全搞砸了，新模具的品控果然有问题。刚上手的那一台（也就是我评测的那一台）的屏幕有划痕，于是使用了两周后我退货购买了M1 Pro的版本，一个月后到货时竟然发现这一台充满了使用痕迹（甚至D面螺丝都没上好）......果断退掉。  \n&emsp;&emsp;考虑到发货时间过长（如果第二台拿到手的话，都快过年了），我打算买台过渡机来使用，综合各方面考虑购买了R9000P，到手的第一台R9000P的屏幕有黑线...换了第二台就没有问题了（可见联想的品控也不怎样，我那台YOGA也有各种小毛病）。\n\n~~人生的第五台笔记本~~\n\n&emsp;&emsp;在显卡通胀的现况下，这种游戏本的贬值周期不会很短，挖挖矿什么的，等下一代MBP出来后换掉也不会亏很多。  \n&emsp;&emsp;装上了Ubuntu，用起来还算可以。\n\n## 期末与寒假\n\n嘿嘿，啊哈哈哈哈，我滴考试完成啦！（x\n\n&emsp;&emsp;突击下来总算完成了考试，也没有挂科。体制内教育的弊端早已让计科这个专业变得落后于时代了，于是我大多在通过看书学习知识。回顾这学期，我还算学的挺多的。从基于比特币的区块链原理到数据结构的大黑书，再到Rust和期末边复习边看的CS:APP，也算读完了很多书了。  \n&emsp;&emsp;寒假从开始到现在，计划之中的CS:APP已经读完了，尽管效率不如在学校的高，不过我也挺满意的，CPU现在对我来说已经不是魔法了（但我当然不算精通！），就像没读自顶向下前的网络一样。很多人把这本书奉为“神书”，由于我的计算机知识已经比较丰富了，于是从我这里倒没有这样的感觉（但我仍对第四章给予高度评价！）。  \n&emsp;&emsp;emmm...本来打算把编译原理和Kt的协程深入研究一番的，但我已经读了太多了，那么寒假剩下的时间就拿来写代码好了。（看看能不能把pilipala...咳咳...\n\n## init 2022\n\n莫名其妙的又过了一年（这一年真的很莫名其妙！），尽管仍对2020年有着不可言说的熟悉感。回顾这一年我干了些什么，我其实也没干什么。不知道什么时候我有了这样麻木的感觉，是因为天天沉迷代码的原因呢，还是我老了呢？嘛......这些都不重要了，2022年的我希望能够学到更多的技术，不为了过去和未来，只为了每一天都过的开心。\n\n---\n\n&emsp;&emsp;我带着美好的愿望来到这里，又带着美好的愿望离开。\n\n---\n\n<div align="right">\n\n每月评论 - 2201期(共8期)  \n撰稿&校对&审核：Thaumy\n\n</div>\n	2022-02-08 08:36:34	2022-02-08 08:28:18	2022-02-08 08:28:18	12	每月评论2201	1001
12493	> 无形的力量。\n\n|    Lang    | Level | Time  |                       //                        |\n| :--------: | :---: | :---: | :---------------------------------------------: |\n|     C#     | ⭐⭐⭐⭐  |  ?☕☕  |                                                 |\n|   Shell    |  ⭐⭐   |  ☕☕☕  |                                                 |\n|     F#     | ⭐⭐⭐⭐  |  ?☕   |                                                 |\n|   Kotlin   |  ⭐⭐   |  ☕☕   |                                                 |\n|  Haskell   |  ⭐?   |  ☕☕   |                                                 |\n|    SQL     |  ⭐⭐⭐  |  ☕☕☕  |                                                 |\n|    CSS     | ⭐⭐⭐?  |   ?   | <div class="sf5a3j">CSS IS AWESOME<div> |\n|    HTML    | ⭐⭐⭐?  |   ?   |                                                 |\n|    Rust    |  ⭐??  |       |                                                 |\n|     C      |  ⭐⭐   |  ☕☕   |                                                 |\n|    C++     |  ⭐⭐⭐  |  ☕☕   |                                                 |\n|     Go     |  ⭐⭐   |  ☕☕   |                    狗都不用                     |\n|   Python   |  ⭐⭐   |   ☕   |                                                 |\n|    Java    |  ⭐⭐   |   ☕   |                                                 |\n|   Scheme   |   ?   |       |                                                 |\n|   RegExp   | ⭐⭐⭐?? |  ☕☕   |                  ~~perl赛高~~                   |\n|    PHP     |   ?   |       |            ~~这是世界上最好的语言~~             |\n| JavaScript |  ⭐⭐   |  ☕☕☕  |                                                 |\n| TypeScript | ⭐⭐??  |  ☕☕☕  |                                                 |\n|   易语言   |  ??   |       |                  ~~入坑语言~~                   |\n\n### 注解\n\n* 3? = 1⭐\n* 3☕ = 1?\n\n<style>\n.sf5a3j{\nfloat:right;\nmargin-right:-33px;\n}\n</style>\n	2022-02-08 12:55:06	2022-07-27 21:48:46	2022-07-27 21:48:46	12	技术栈	1001
12439	# 什么是vsFTPd？\n\n> 以下写为vsftpd\n\n**vsftpd是一款可运行在linux环境下的FTP服务器系统，全称为"very secure FTP daemon"，意为“非常安全的FTP守护神”（微软翻译的别问我为什么......）。**\n\n## 背景\n\n&emsp;&emsp;在将pilipala迁移到Ubuntu2004环境时，为方便部署和管理，我打算使用vsftpd作为FTP服务器，为此也踩了无数的坑（Ubuntu2004环境下的教程几乎没人写过），终于摸索出了一套比较可行的部署方法。  \n&emsp;&emsp;在迁移过程中，为货比三家，我先后试用或购买了阿里云、腾讯云、UCloud的服务器产品，发现了不同服务商之间的部署会有细微差别，这里不作一一概述。本教程将使用一套较为通用的工作流来教你如何完成这项工作。  \n&emsp;&emsp;**在编写本文档时，Thaumy正在进行第四次vsftpd部署，所以本教程的所有内容均为Thaumy的实际工作流。**\n\n## 准备工作\n\n&emsp;&emsp;配有Ubuntu2004操作系统的云服务器、可用的网络连接与十足的耐心。\n\n---\n\n## 工作流\n\n**登入服务器，进入CLI（命令行界面）。**\n\n**为保证apt列表处于最新状态，我们首先更新一下apt：**\n\n&emsp;&emsp;`sudo apt-get update`  \n&emsp;&emsp;`sudo apt-get upgrade`\n\n**下一步，安装vsftpd：**\n\n&emsp;&emsp;`sudo apt-get install vsftpd`\n\n**安装完成后，我们需要为Ubuntu创建一个新的用户，专门用来管理FTP：**\n\n&emsp;&emsp;`sudo useradd ftp_user`\n\n**我们刚刚创建了一个名为`ftp_user`的用户，现在为其设置密码：**\n\n&emsp;&emsp;`sudo passwd ftp_user`  \n系统将要求你输入两次密码，若多次输入不一致，则会停止密码设置流程。\n\n<div style="text-align:center">\n<img style="width:100%;max-width:400px" src="https://cdn.thaumy.cn/md-img/如何在Ubuntu2004环境下配置vsftpd/set_pwd.png">\n</div>\n\n如果看到以上画面，那么密码就设置成功了。\n\n**下面，我们设置用户`ftp_user`不得登入操作系统，以防止被黑客盗用而操作除FTP以外的内容：**\n\n&emsp;&emsp;`sudo usermod -s /sbin/nologin ftp_user`\n\n**接下来，我们需要指定一个物理位置作为FTP服务器根目录。在这之前，我们需要创建它：**\n\n&emsp;&emsp;`sudo mkdir -p /home/ftp`\n\n**为方便管理，我们后续会将根目录设置为只读。因此，还需要在`/home/ftp`下另建一个文件夹，用于存储FTP文件：**\n\n&emsp;&emsp;`sudo mkdir -p /home/ftp/public`  \n我们新建了一个文件夹`public`。\n\n**现在分别赋予这两个文件夹刚刚所述的相应权限：**\n\n<pre>Command<code>sudo chmod a-w /home/ftp\nsudo chmod 777 -R /home/ftp/public\n</code></pre>\n\n**最后，设置用户`ftp_user`的登入目录为`/home/ftp`：**\n\n&emsp;&emsp;`sudo usermod -d /home/ftp ftp_user`\n\n---\n\n&emsp;&emsp;以上，我们安装了vsftpd并创建了一个用户用于管理FTP服务器的相应目录。接下来，我们需要设置vsftpd的配置文件，详细规定我们的FTP服务器需要按照哪些配置进行工作。\n\n---\n\n**编辑配置文件：**\n\n`sudo vi /etc/vsftpd.conf`\n\n> 在这里，我们使用vi作为文本编辑工具。对于如何使用vi/vim编辑文档，网上有很多非常不错的资源可供参考，这里将不作赘述（其实我也不怎么会）。\n\n&emsp;&emsp;由于我们添加的配置和原有的配置有所冲突，所以我们需要先将原有的冲突配置注释掉。\n这样做既保存了原有的默认配置，我们添加的配置也会生效。  \n&emsp;&emsp;为了醒目地标注冲突项，我们使8个井号(########)来将其注释掉，如下图橙色箭头标注所示：\n\n<div style="text-align:center">\n<img style="width:100%;max-width:600px;" src="https://cdn.thaumy.cn/md-img/如何在Ubuntu2004环境下配置vsftpd/config_1.png"></div>\n\n**接下来，我们在配置文件的末尾添加如下配置：**\n\n<pre>TEXT<code># 启用监听\nlisten=YES\n\n# 不允许监听ipv6\nlisten_ipv6=NO\n\n# 禁用匿名用户\nanonymous_enable=NO\n\n# 可写入\nwrite_enable=YES\n\n# 禁止切换根目录\nchroot_local_user=YES\n\n# 设置ftp根目录位置\nlocal_root=/home/ftp</code></pre>\n\n注意不要将原文档末尾的UTF-8设置项误删。保存退出。\n\n**由于我们设置用户`ftp_user`不允许登入操作系统，所以还需要更改相应的pam认证：**\n\n&emsp;&emsp;`sudo vi /etc/pam.d/vsftpd`  \n在编辑模式下，将文件末尾的`pam_shells.so`更改为`pam_nologin.so`\n\n---\n\n> &emsp;&emsp;按照传统配置的点到为止，vsftpd的配置就结束了，但是Ubuntu2004他是个年轻人，他不讲武德，来，骗，来，偷袭，我这个刚接触Linux的小同志，这好吗？这不好......\n\n&emsp;&emsp;事情还没完，Ubuntu2004缺少一个/etc/securetty文件。先不说这玩意是用来干甚么的，至少我们少了它，vsftpd是不能用的。如果你试图连接FTP服务器，将在vsftpd服务状态中看到以下错误：\n\n<img width="100%" src="https://cdn.thaumy.cn/md-img/如何在Ubuntu2004环境下配置vsftpd/no_secur.png">\n\n&emsp;&emsp;这个坑居然没有一个中文博客提到，我在苦苦搜索中，终于在<a href="https://askubuntu.com/questions/1239503/ubuntu-20-04-and-20-10-etc-securetty-no-such-file-or-directory">Stack Overflow</a>上找到了相应的解决方案。据采纳回答，/etc/securetty文件的内容取自Ubuntu1910，下面我贴出其内容：\n\n<details>\n<summary>展开（这玩意是真他妈的长）</summary>\n\n<pre>TEXT<code style="height:200px">\n# /etc/securetty: list of terminals on which root is allowed to login.\n# See securetty(5) and login(1).\n\nconsole\n\n# Local X displays (allows empty passwords with pam_unix's nullok_secure)\n:0\n:0.0\n:0.1\n:1\n:1.0\n:1.1\n:2\n:2.0\n:2.1\n:3\n:3.0\n:3.1\n#...\n\n\n# ==========================================================\n#\n# TTYs sorted by major number according to Documentation/devices.txt\n#\n# ==========================================================\n\n# Virtual consoles\ntty1\ntty2\ntty3\ntty4\ntty5\ntty6\ntty7\ntty8\ntty9\ntty10\ntty11\ntty12\ntty13\ntty14\ntty15\ntty16\ntty17\ntty18\ntty19\ntty20\ntty21\ntty22\ntty23\ntty24\ntty25\ntty26\ntty27\ntty28\ntty29\ntty30\ntty31\ntty32\ntty33\ntty34\ntty35\ntty36\ntty37\ntty38\ntty39\ntty40\ntty41\ntty42\ntty43\ntty44\ntty45\ntty46\ntty47\ntty48\ntty49\ntty50\ntty51\ntty52\ntty53\ntty54\ntty55\ntty56\ntty57\ntty58\ntty59\ntty60\ntty61\ntty62\ntty63\n\n# UART serial ports\nttyS0\nttyS1\nttyS2\nttyS3\nttyS4\nttyS5\n#...ttyS191\n\n# Serial Mux devices    (Linux/PA-RISC only)\nttyB0\nttyB1\n#...\n\n# Chase serial card\nttyH0\nttyH1\n#...\n\n# Cyclades serial cards\nttyC0\nttyC1\n#...ttyC31\n\n# Digiboard serial cards\nttyD0\nttyD1\n#...\n\n# Stallion serial cards\nttyE0\nttyE1\n#...ttyE255\n\n# Specialix serial cards\nttyX0\nttyX1\n#...\n\n# Comtrol Rocketport serial cards\nttyR0\nttyR1\n#...\n\n# SDL RISCom serial cards\nttyL0\nttyL1\n#...\n\n# Hayes ESP serial card\nttyP0\nttyP1\n#...\n\n# Computone IntelliPort II serial card\nttyF0\nttyF1\n#...ttyF255\n\n# Specialix IO8+ serial card\nttyW0\nttyW1\n#...\n\n# Comtrol VS-1000 serial controller\nttyV0\nttyV1\n#...\n\n# ISI serial card\nttyM0\nttyM1\n#...\n\n# Technology Concepts serial card\nttyT0\nttyT1\n#...\n\n# Specialix RIO serial card\nttySR0\nttySR1\n#...ttySR511\n\n# Chase Research AT/PCI-Fast serial card\nttyCH0\nttyCH1\n#...ttyCH63\n\n# Moxa Intellio serial card\nttyMX0\nttyMX1\n#...ttyMX127\n\n# SmartIO serial card\nttySI0\nttySI1\n#...\n\n# USB dongles\nttyUSB0\nttyUSB1\nttyUSB2\n#...\n\n# LinkUp Systems L72xx UARTs\nttyLU0\nttyLU1\nttyLU2\nttyLU3\n\n# StrongARM builtin serial ports\nttySA0\nttySA1\nttySA2\n\n# SCI serial port (SuperH) ports and SC26xx serial ports\nttySC0\nttySC1\nttySC2\nttySC3\nttySC4\nttySC5\nttySC6\nttySC7\nttySC8\nttySC9\n\n# ARM "AMBA" serial ports\nttyAM0\nttyAM1\nttyAM2\nttyAM3\nttyAM4\nttyAM5\nttyAM6\nttyAM7\nttyAM8\nttyAM9\nttyAM10\nttyAM11\nttyAM12\nttyAM13\nttyAM14\nttyAM15\n\n# Embedded ARM AMBA PL011 ports (e.g. emulated by QEMU)\nttyAMA0\nttyAMA1\nttyAMA2\nttyAMA3\n\n# DataBooster serial ports\nttyDB0\nttyDB1\nttyDB2\nttyDB3\nttyDB4\nttyDB5\nttyDB6\nttyDB7\n\n# SGI Altix console ports\nttySG0\n\n# Motorola i.MX ports\nttySMX0\nttySMX1\nttySMX2\n\n# Marvell MPSC ports\nttyMM0\nttyMM1\n\n# PPC CPM (SCC or SMC) ports\nttyCPM0\nttyCPM1\nttyCPM2\nttyCPM3\nttyCPM4\nttyCPM5\n\n# Altix serial cards\nttyIOC0\nttyIOC1\n#...ttyIOC31\n\n# NEC VR4100 series SIU\nttyVR0\n\n# NEC VR4100 series SSIU\nttyVR1\n\n# Altix ioc4 serial cards\nttyIOC84\nttyIOC85\n#...ttyIOC115\n\n# Altix ioc3 serial cards\nttySIOC0\nttySIOC1\n#...ttySIOC31\n\n# PPC PSC ports\nttyPSC0\nttyPSC1\nttyPSC2\nttyPSC3\nttyPSC4\nttyPSC5\n\n# ATMEL serial ports\nttyAT0\nttyAT1\n#...ttyAT15\n\n# Hilscher netX serial port\nttyNX0\nttyNX1\n#...ttyNX15\n\n# Xilinx uartlite - port\nttyUL0\nttyUL1\nttyUL2\nttyUL3\n\n# Xen virtual console - port 0\nxvc0\n\n# pmac_zilog - port\nttyPZ0\nttyPZ1\nttyPZ2\nttyPZ3\n\n# TX39/49 serial port\nttyTX0\nttyTX1\nttyTX2\nttyTX3\nttyTX4\nttyTX5\nttyTX6\nttyTX7\n\n# SC26xx serial ports (see SCI serial ports (SuperH))\n\n# MAX3100 serial ports\nttyMAX0\nttyMAX1\nttyMAX2\nttyMAX3\n\n# OMAP serial ports\nttyO0\nttyO1\nttyO2\nttyO3\n\n# User space serial ports\nttyU0\nttyU1\n\n# A2232 serial card\nttyY0\nttyY1\n\n# IBM 3270 terminal Unix tty access\n3270/tty1\n3270/tty2\n#...\n\n# IBM iSeries/pSeries virtual console\nhvc0\nhvc1\n#...\n#IBM pSeries console ports\nhvsi0\nhvsi1\nhvsi2\n\n# Equinox SST multi-port serial boards\nttyEQ0\nttyEQ1\n#...ttyEQ1027\n\n# ==========================================================\n#\n# Not in Documentation/Devices.txt\n#\n# ==========================================================\n\n# Embedded Freescale i.MX ports\nttymxc0\nttymxc1\nttymxc2\nttymxc3\nttymxc4\nttymxc5\n\n# LXC (Linux Containers)\nlxc/console\nlxc/tty1\nlxc/tty2\nlxc/tty3\nlxc/tty4\n\n# Serial Console for MIPS Swarm\nduart0\nduart1\n\n# s390 and s390x ports in LPAR mode\nttysclp0\n\n# ODROID XU4 serial console\nttySAC0\nttySAC1\nttySAC2\nttySAC3</code></pre>\n\n</details>\n\n**复制好上述内容，我们来造一个文件：**\n\n&emsp;&emsp;`sudo vi /etc/securetty`\n\n**将内容粘进去后保存，我们重启vsftpd：**\n\n&emsp;&emsp;`sudo service vsftpd restart`\n\n**查看vsftpd的状态：**\n\n&emsp;&emsp;`sudo service vsftpd status`\n\n<div style="text-align:center">\n<img style="width:100%;max-width:600px" src="https://cdn.thaumy.cn/md-img/如何在Ubuntu2004环境下配置vsftpd/success.png"></div>\n\n**如果你看到了上图内容，那么说明vsftpd的配置应该是没有问题的，接下来让我们验收一下：**\n\n在此我使用工具`FlashFXP`登入我们刚刚部署的FTP服务器，具体配置如下：\n\n<div style="text-align:center">\n<img style="width:100%;max-width:400px" src="https://cdn.thaumy.cn/md-img/如何在Ubuntu2004环境下配置vsftpd/flashfxp.png"></div>\n\n用户名和密码均为上述设置项，地址填写云服务器的公网IP，FTP模式设置为`主动模式(PORT)`，其他选项均为默认。\n\n**若成功连接到FTP服务器，你将看到根目录下有一个`public`文件夹，由于我们的权限设置，根目录下的内容为只读，但`public`的内部是读写自由的。**\n\n~~好了，现在您可以尽情地向您的FTP服务器里塞垃圾文件了233。~~\n\n<div style="text-align:right">希望本文能对你有所帮助。</div>\n<div style="text-align:right">或者，节约几个小时？</div>\n	2020-12-14 22:02:31	2020-12-15 15:04:36	2020-12-15 15:04:36	12	为Ubuntu2004环境配置vsftpd	1001
12466	# Continuation Passing Style\n\n续体传递风格$^{*1}$\n\n## 概要\n\n**续体传递风格**是一种编程风格，它通过显式地使用函数来接管上一函数的结果来实现控制流$^{*2}$，在异常处理、协程、异步编程和编译等领域中有着非常广泛的应用。以下简称CPS。\n\n## 应用序与正则序\n\n在命令式编程中，语句的编写顺序即为控制流，比如：\n\n```JavaScript\nlet a = 1\nlet b = 2\nlet c = 3\nconsole.log(a + b + c)//6\n```\n\n上述代码如何执行？当然是先计算`a`，再计算`b`，然后计算`c`，最后执行`console.log`。  \n这种先计算再展开的求值策略（Evaluation Otrategy）被称为**应用序**（Applicative Order），它实现于绝大多数的编程语言中。\n\n函数式语言普遍采用被称为**正则序**（Normal Order）的求值策略。在正则序中，表达式被先展开再求值，这就使得`console.log`会被放在第一位执行，然后再计算需要的数据。换句话说，不到万不得已，程序不会对任何表达式求值，这就是**惰性求值**（Lazy Evaluation）。\n\n由于惰性求值这种不确定的求值顺序，如果按照常规方式（即控制流由语句编写顺序决定）构造控制流则很可能会导致执行顺序与预期不一致，于是就需要一种方法来约束表达式的求值顺序以实现正确的控制流，使用CPS就可以实现这个目的。\n\n## CPS变换\n\nCPS变换指的是将一般风格的控制流转换成CPS风格的控制流。\n\n上文代码经CPS变换后如下：\n\n```JavaScript\nlet a = (x, y) => y(x)//y is a callback function\nlet b = (x, y) => y(x)\nlet c = (x, y) => y(x)\n\nconsole.log(\n    a(1, a => \n    b(2, b => \n    c(3, c => a + b + c))))//6\n```\n\n在CPS风格下，函数具有一个被称为**计算续体**（Continuation）的回调函数（Callback Function），计算续体负责接管当前函数的计算结果并将其传递至下一次计算。如果对上述代码进行展开，那么应该类似于这个样子（伪代码）：\n\n```JavaScript\n[a-> [b-> [c-> a+b+c ](3) ](2) ](1)\n```\n\n可以看到，在正则序下，求值顺序被约束到了函数的嵌套顺序中，从而避免了由于惰性求值导致的乱序执行问题。\n\n由于CPS的写法比较难以阅读，所以有些基于正则序的语言提供了一些语法糖来帮助你编写CPS风格的代码，Haskell中的`do`表示法就是一个例子：\n\n```Haskell\nmain = \n  pure 1 >>= (\\a -> \n  pure 2 >>= (\\b -> \n  pure 3 >>= (\\c -> \n  putStrLn . show $(a + b + c))))\n\nmain = do\n  a <- pure 1\n  b <- pure 2\n  c <- pure 3\n  putStrLn . show $ a + b + c\n```\n\n两种写法完全等价。\n\n## Playground\n\n没作业。\n\n---\n\n### 注解\n\n1. 另有其他的翻译形式：延续过渡风格/续延传递风格/后续传递风格...\n2. 计算机执行一个程序中语句的顺序。（引用自MDN）\n	2021-12-15 22:50:22	2021-12-15 22:50:22	2021-12-15 22:50:22	12	CPS	1001
12464	# Calculus of Constructions\n\n构造演算\n\n## 概要\n\n构造演算是融合了项到项($λ\\scriptsize{→}$)、项到类型($λ\\small{Π}$)、类型到类型($λ\\underline{ω}$)、类型到项($λ\\small{2}$)的高阶有类型 $λ$ 演算。CoC为 $λ$ 演算带来了十分强大的类型系统，这极大地增强了语言的描述能力。\n\n## 回顾\n\n$λ\\scriptsize{→}$ 引入了一个简单的类型系统，使得 $λ$ 演算被正则化了：\n\n自然数：$n:=λf:α→α.\\ λx:α.\\ f^{○n}\\ x$  \n布尔值：$true\\ \\ :=λa:α.\\ λb:α.\\ a$  \n\n$λ\\small{Π}$ 允许由项构造类型，使得依赖类型成为可能：$λn:nat.\\ λf:α→α.\\ λx:α.\\ f^{○n}\\ x\\ :\\ Πn:nat.\\ B(n)$ $^{*1}$\n\n$λ\\underline{ω}$ 引入了类型构造器，我们可以由类型构造类型了：$Λα:*.\\ β\\;:\\;*→*$\n\n$λ\\small{2}$ 形式化了参数多态，于是有了泛用型函数：$Λα.\\ λx:α.\\ x\\ :\\ ∀α.\\ α→α$（Identity）\n\n## 组合\n\n我们将 $λ\\small{Π}$ 与 $λ\\underline{ω}$ 组合得到 $λ\\small{Π}\\underline{ω}$，这是允许类型构造器的依赖类型系统：  \n$Λα:*.\\ λn:nat.\\ λf:α→α.\\ λx:α.\\ f^{○n}\\ x\\ :\\ Πn:nat.\\ B(n)$\n\n我们将 $λ\\small{Π}$ 与 $λ\\small{2}$ 组合得到 $λ\\small{Π2}$，这是允许参数多态的依赖类型系统：  \n$Λα.\\ λn:nat.\\ λf:α→α.\\ λx:α.\\ f^{○n}\\ x\\ :\\ ∀α.\\ Πn:nat.\\ B(n)$\n\n我们将 $λ\\underline{ω}$ 与 $λ\\small{2}$  组合得到 $λω$，它同时具有类型构造器和参数多态：  \n$Λα.\\ Λβ:*→*.\\ λx:α.\\ λg:α→β\\,α.\\ g\\,x\\ :\\ ∀α.\\ β\\,α$  \n（举个例子，$g$ 可为 $Λγ:*.\\ λz:γ.\\ z\\ :γ→γ\\ :\\;*→*$，即 $β$ 是 $Λγ:*.\\ γ$）\n\n$而λ\\small{Π}\\underline{ω}$、$λ\\small{Π2}$与$λω$的组合便是构造演算，例如：\n\n$Λα.\\ Λβ:*→*.\\ λn:nat.\\ λg:α→β\\,α.\\ λf:α→α.\\ λx:α.\\ f^{○n}\\ (g\\,x)\\ :\\ ∀α.\\ Πn:nat.\\ B(n)$\n\n## In λ Cube\n\n在λ立方体中，CoC即为 $λ\\small{Πω}$（或$λ\\small{C}$），居于最右上角，具有整个立方体中最强的表达能力。\n\n|   系统\\特征   |   $→$   |   $Π$   |   $ω$   |   $2$   |\n| :-----------: | :-----: | :-----: | :-----: | :-----: |\n| $λ\\small{Πω}$ | $(*,*)$ | $(*,□)$ | $(□,□)$ | $(□,*)$ |\n\n---\n\n### 注解\n\n1. nat：自然数。\n	2021-12-15 22:49:35	2021-12-15 22:49:35	2021-12-15 22:49:35	12	CoC	1001
12499	# 噼哩啪啦新版本前瞻\n\n经过长达一年的探索和开发，噼哩啪啦将在今年暑期发布以第一个正式版本。\n\n这篇文章用以介绍新版本噼哩啪啦目前已经实现的重要特性，我将持续编辑。\n\n## 高性能数据库API\n\n新开发的异步数据库API从一开始就针对高并发场景进行设计。现在，噼哩啪啦具备经过基准测试的并发安全性，并带来超过三倍的性能提升。这让本就快速的噼哩啪啦再次全面提速。\n\n## 真正意义上的插件系统\n\n噼里啪啦现具备高扩展性，全新的架构使得完备的插件系统成为可能。相较于原有设计，噼哩啪啦的插件系统拥有了更大的调度权和灵活性。你可以通过编写插件来介入噼哩啪啦的任何过程，这甚至让原来集成自噼哩啪啦的一些功能得以解耦为插件提供的内容。\n\n## 访问控制\n\n基于角色的访问控制系统（RBAC）为噼哩啪啦带来了前所未有的安全性。权限控制系统经过精心设计，从而让不同级别下的资源隔离成为可能。每个用户能够做什么、站点的运行模式等，均由访问控制系统进行隔离。\n\n## 服务与高性能日志\n\n新提供的服务系统让噼哩啪啦为外界提供了远超以往的API数量和可扩展性，通过开发和访问服务，你可以定制任何与噼哩啪啦的交互过程。高性能日志贯穿整个系统，允许各种类型的日志记录，这让对噼哩啪啦的调试和分析变得更加容易。\n\n## 多重集成方案\n\n得益于噼哩啪啦内核的完全独立性，你可以基于它开发任何衍生系统，例如基于噼哩啪啦的跨平台应用程序、gRPC等。你甚至可以将其与现有的SPA系统集成，或是开发高度定制的主题系统。\n\n## 由语言提供的安全性\n\n新的噼哩啪啦内核完全采用F#编写，这允许内核在更高的层次上进行抽象，同时带来了一部分函数式语言特有的安全性。得益于F#，噼哩啪啦内核仅使用了50%的代码量，却提供了远超原有内核的先进功能特性，同时更加安全。\n	2022-06-25 00:07:52	2022-07-31 21:52:26	2022-07-31 21:52:26	12	噼哩啪啦新版本前瞻	1001
12465	# Combinatory Logic\n\n组合子逻辑\n\n## 引言\n\n如果你十分惊奇于λ演算的唯常量编程，那么组合子逻辑就更为惊奇了：这玩意居然连常量都不需要依赖即可满足图灵完备性，它是比λ演算更为简洁的编程语言。\n\n## 概要\n\n组合子逻辑是一种符号系统，它可以消除数理逻辑中对变量的需要。组合子（Combinator）在本质上是一系列高阶函数，它捕获了计算本质的很多特征，可看作是λ演算的一种变体。\n\n## $I$ 组合子\n\n$I$ 组合子是最简单的组合子，其定义为：$(I\\ x) = x$  \n显然，$I$ 组合子的λ表示为 $λx.x$，对于任何输入 $x$，该组合子均返回 $x$\n\n$I$ 组合子被称作恒等组合子。\n\n## $K$ 组合子和 $S$ 组合子\n\n$K$ 组合子：$(K\\ x\\ y)=x$  \n对于组合子$K$，始终得到第一个变量 $x$，因而可用于制造常函数。\n\n$S$ 组合子：$(S\\ x\\ y\\ z)=x\\ z\\ (y\\ z)$  \n对于组合子 $S$，它将函数 $x$ 与 $y$ 分别应用到变量 $z$ 上，随后将两个结果进行应用操作。\n\n你可能注意到，$I$ 组合子和 $S$ 组合子和某些λ函数是等价的。是的，不仅它们是等价的，而且这两种组合子具有完备性，即它们的组合可以导出任意类型的λ项。\n\n考虑使用组合子 $S$、$K$ 导出组合子 $I$：  \n$((S\\ K\\ K)\\ x)=(S\\ K\\ K\\ x)=(K\\ x\\ (K\\ x))=x$\n\n称 $(S\\ K\\ K)$ 和 $I$ 是**外延相等**的。\n\n## 使用组合子消除变量依赖$^{*1}$\n\n提出变换 $T[\\quad]$，可以转换任意λ项到组合子，定义如下：\n\n1. $T[E]\\qquad\\qquad⇒E$\n2. $T[E_1\\ E_2]\\qquad\\ ⇒T[E_1]\\ T[E_2]$\n3. $T[λx.E]\\qquad\\ \\ ⇒K\\ T[E]$，且 $¬(x→E)$\n4. $T[λx.x]\\qquad\\ \\ \\ ⇒I$\n5. $T[λx.λy.E]\\quad\\ ⇒T[λx.T[λy.E]]$，且 $x→E$\n6. $T[λx.(E_1\\ E_2)]\\ ⇒S\\ T[λx.E_1]\\ T[λx.E_2]$\n\n于是，我们尝试转换 $λx.λy.(y\\ x)$ 为组合子：\n\n$\\quad T[λx.λy.(y\\ x)]$  \n$=T[λx.T[λy.(y\\ x)]]$（通过5）  \n$=T[λx.(S\\ T[λy.y]\\ T[λy.x])]$（通过6）  \n$=T[λx.(S\\ I\\ T[λy.x])]$（通过4）  \n$=T[λx.(S\\ I\\ (K\\ x))]$（通过3）  \n$=(S\\ T[λx.(S\\ I)]\\ T[λx.(K\\ x)])$（通过6）  \n$=(S\\ (K\\ (S\\ I))\\ T[λx.(K\\ x)])$（通过3）  \n$=(S\\ (K\\ (S\\ I))\\ (S\\ T[λx.K]\\ T[λx.x]))$（通过6）  \n$=(S\\ (K\\ (S\\ I))\\ (S\\ (K\\ K)\\ T[λx.x]))$（通过3）  \n$=(S\\ (K\\ (S\\ I))\\ (S\\ (K\\ K)\\ I))$（通过4）\n\n至此，我们消除了变量依赖。\n\n## Playground\n\n尝试理解以下归约过程：  \n\n$\\quad(S\\ (K\\ (S\\ I))\\ (S\\ (K\\ K)\\ I)\\ x\\ y)$  \n$=(K\\ (S\\ I)\\ x\\ (S\\ (K\\ K)\\ I\\ x)\\ y)$  \n$=(S\\ I\\ (S\\ (K\\ K)\\ I\\ x)\\ y)$  \n$=(I\\ y\\ (S\\ (K\\ K)\\ I\\ x\\ y))$  \n$=(y\\ (S\\ (K\\ K)\\ I\\ x\\ y))$  \n$=(y\\ (K\\ K\\ x\\ (I\\ x)\\ y))$  \n$=(y\\ (K\\ (I\\ x)\\ y))$  \n$=(y\\ (I\\ x))$  \n$=(y\\ x)$\n\n---\n\n### 注解\n\n1. 指一个`量`到`名`的绑定依赖。和λ演算一样，组合子中的量依然是不可变的，「变量依赖」的使用，是约定俗成的缘故。\n	2021-12-15 22:50:00	2021-12-15 22:50:00	2021-12-15 22:50:00	12	Combinatory Logic	1001
12460	# Algebraic Data Type\n\n代数数据类型\n\n## 概要\n\n**代数数据类型**是一种**复合类型**（Composite type），这种数据类型允许你以代数的形式将所需要的数据类型表示出来，在函数式编程中有着广泛的应用。\n\n## 何为代数\n\n代数在数学中无处不在，你一定对它非常熟悉，只不过出现在这里让你感到困惑罢了。代数就是符号化，通过把一些具体的数字以字母或符号代替，来表达更为普遍的或更加抽象的关系，这里沿用了数学上的概念。\n\n对于代数，我们只关心它们的性质或彼此之间的关系，而并不关心它们具体是什么。\n\n正是因为代数这种抽象十分重要，越来越多的编程语言提供了对代数的抽象，这种抽象的实际体现便是代数数据类型（此后简称ADT）。\n\n## 和类型和积类型\n\n**和类型**（Sum type）和**积类型**（Product type）是ADT的两大组成，要了解ADT就要先理解这两种类型。\n\n### 枚举是和\n\n比如C语言中的枚举类型，就是和类型：\n\n```C\nenum Alphabet {A, B, C};\nAlphabet foo = B;//foo只能是A, B, C中之一\n```\n\n之所以称之为和类型，是因为其取值类型可以用求和的方式得出，比如`Alphabet`类型的取值有3种，这是通过求和得出的。\n\n我们再来考察和类型的另一种表现形式：\n\n```Java\nclass Alphabet {}\nclass A extends Alphabet {}\nclass B extends Alphabet {}\nclass C extends Alphabet {}\nAlphabet foo = new B();//foo只能是A, B, C中之一\n```\n\n这里更多地强调的是一种子类和父类的派生关系，而不是实现上的复用，是*子类型化*（Subtyping）的一种体现。\n\n### 结构体是积\n\nC语言中的结构体是一种积类型：\n\n```C\nstruct Bar {\n    int a;\n    int b;\n};\nstruct Bar foo;\nfoo.a = 1;\nfoo.b = 2;\n```\n\n之所以称之为积类型，是因为其的取值范围是各组成部分取值范围之积，本例中的`Bar`类型的取值数是`a`和`b`的取值数的乘积。\n\n## ADT\n\nADT是由和类型和积类型组成的复合类型，我们可以拿ADT来作很多事情，比如实现一个二叉树$^{*1}$：\n\n```Java\nclass BinTree {}\nclass Empty extends BinTree {}//空节点\nclass Node extends BinTree {//非空节点\n    int value;//节点值\n    BinTree L;//左树\n    BinTree R;//右树\n}\n```\n\n然后我们就可以如此构造一棵二叉树了（可能有点难看）：\n\n```Java\nBinTree t = new Node() {{\n    value = 1;\n    L = new Node() \n        {{value = 2; \n        L = new Empty();R = new Empty();}};\n    R = new Node() \n        {{value = 3; \n        L = new Empty();R = new Empty();}};\n}};\n```\n\nHaskell对ADT的支持则更完善一些，实现起来也更加优雅：\n\n```Haskell\ndata BinTree = Empty | Node BinTree Int BinTree\nt = Node (Node Empty 2 Empty) 1 (Node Empty 3 Empty)\n```\n\n对ADT具有良好支持的语言不仅仅可以享受到构造ADT的精简语法，同时还能受益于类型安全带来的一系列优点。\n\n## Playground\n\n没作业。\n\n---\n\n### 注解\n\n1. 在Java15中可以使用密封类来保证ADT的类型安全，这里没有演示。（本例中基类BinTree不是封闭的，这意味着它可能被非法派生。）\n2. 可以简单地认为：子类型化是接口上的继承，而面向对象中的继承更多地强调实现上的复用（即“实现”上的继承）。\n	2021-12-15 22:47:20	2021-12-15 23:05:09	2021-12-15 23:05:09	12	ADT	1001
12350	<img src="<{cdn_root}>/old_post/StdLib1.06宣传画(压缩).jpg" width="100%"/>\n\n<span style="color: #ff9900;">StdLib1.06#public</span>\n\n&emsp;&emsp;经过一周的研究和一周的开发，我对高级算法的理解能力并没有取得多少长进，所以本次S1.06p的更新使用的是我自己研究的算法，我将它成为动下标错位判等算法，其实现原理很简单：\n\n<pre>C#<code>\nfor (int path = 0; path &lt; a.Length; path++)\n{\n    for (int i = 0; i &lt; a.Length; i++)\n    {\n        if (i + 1 &lt; a.Length)\n        {\n            int tmp = 0;\n            if (a[i] &gt; a[i + 1])\n            {\n                tmp = a[i];\n                a[i] = a[i + 1];\n                a[i + 1] = tmp;\n            }\n        }\n    }\n}\n</code></pre>\n\n<span style="color: #ff6600;">这里是调用：</span>\n\nLSS算法测试\n\n<pre>C#<code>\nint[] a = { 1, 65, 6, 723, 847, 5874, 884, 041, 6, 76, 1, 847, 3, 79, 715, 09, 46, 235, 886, 45, 87, 122, 98, 15, 01, 4 };\n\nforeach(int p in Class_LSS.Main_LSS(a))\n{\n    Console.WriteLine(p);\n}\n</code></pre>\n\n&nbsp;\n接着是ANSW2Dcode的更新，ANSW是我在2016年暑假期间写的图像识别模块，不够稳定的它不乏创新性。经过我一个周末的修改，ANSW的实体化程序更正完成，现已集成到1.06中，识别具有特定组织方式的BMP图像，进行解码和编码。其调用规则如下：\n\nANSW测试\n\n<pre>C#<code>\nClass_ANSW aw = new Class_ANSW();\n\n//region ANSW解码测试\nConsole.WriteLine(aw.DeANSW(@"L:\\C#项目开发\\StdLib1.06\\answ"));\n\n//ANSW转码测试\nBitmap bp = aw.ToANSW("4869212069206c6f76652074686520776f726c6421", @"L:\\C#项目开发\\StdLib1.06\\source");\nImage i = bp;\ni.Save(@"L:\\C#项目开发\\StdLib1.06\\answ.bmp");\n\n//注意：\n//在ANSW解码中，输入流可以为有.bmp后缀的文件名或无后缀的文件名\n//在ANSW转码中，输入与解码规则相同，输出分两种情况如下：\n//1.流错误输出所指定的流必须带.bmp后缀\n//2.正常输出所指定的流可以为有.bmp后缀文件名或无后缀文件名\n</code></pre>\n\n另外还增加了一个很实用的结构体用于初始化XmlCreater的各种静态方法，其结构如下：\n\n<pre>C#<code>\npublic struct XmlInf\n{\n    //结构私有属性\n\n    private string Path;\n    private string InStream;\n    private string FileName;\n    private string XmlName;\n    private string RootName;\n    private string NodeName;\n    private string AttName;\n    private string AttValue;\n    private string InnerText;\n    private string Type;\n\n    //属性访问器\n\n    //节点地址，如父节点、实节点、子节点的地址，用于XmlCreater类中除reStream、CreateXml方法外的所有方法\n    public string path\n    {\n        get { return Path; }\n        set { Path = value; }\n    }\n    \n    //被读取的Xml文档文件流，在初始化时使用，用于XmlCreater类的reStream方法\n    public string inStream\n    {\n        get { return InStream; }\n        set { InStream = value; }\n    }\n    \n    //被创建的Xml文档的文件地址，用于XmlCreater类的CreateXml方法\n    public string fileName\n    {\n        get { return FileName; }\n        set { FileName = value; }\n    }\n    \n    //被创建的Xml文档的文件名，用于XmlCreater类的CreateXml方法\n    \n    public string xmlName\n    {\n        get { return XmlName; }\n        set { XmlName = value; }\n    }\n    \n    //被创建的Xml文档的根元素名，用于XmlCreater类的CreateXml方法\n    public string rootName\n    {\n        get { return RootName; }\n        set { RootName = value; }\n    }\n    \n    //节点名，可表示子节点、父节点、新建空\\实节点名，用于XmlCreater类的AddRealNode、AddEmptyNode、RemoveNode方法\n    public string nodeName\n    {\n        get { return NodeName; }\n        set { NodeName = value; }\n    }\n    \n    //节点的属性名，用于XmlCreater类的AddRealNode、ReadAtt方法\n    public string attName\n    {\n        get { return AttName; }\n        set { AttName = value; }\n    }\n    \n    //节点的属性值，用于XmlCreater类的AddRealNode方法\n    public string attValue\n    {\n        get { return AttValue; }\n        set { AttValue = value; }\n    }\n    \n    //节点的子文本，用于XmlCreater类的AddRealNode方法\n    public string innerText\n    {\n        get { return InnerText; }\n        set { InnerText = value; }\n    }\n    \n    //读取类型，可选值有"_name"、"_value"，用于XmlCreater类的ReadNode方法\n    public string type\n    {\n        get { return Type; }\n        set { Type = value; }\n    }\n}\n</code></pre>\n\n&emsp;&emsp;这样，在使用XmlCreater类的各种方法时，都可以传递该结构体作为第二重载执行，极大的提升了代码的可读性和维护性，同时也降低了程序的耦合度。  \n\n&emsp;&emsp;注意：我们把所有命名空间装入了一个名为StdLib1_16的命名空间，这样提升了版本间的辨识度。所以在使用1.06时除了引用该dll以外，应先引用主"StdLib1_16"命名空间，再引用子空间。如下：\n\n<pre>C#<code>\nusing StdLib1_16;\nusing StdLib1_16.StdEct;\nusing StdLib1_16.StdDal;\n</code></pre>\n\n&emsp;&emsp;我在StdLib的编写过程中遵循的是两个发行版一兼容的模式，例如从1.03开始，1.04与1.05相兼容，1.06与1.07相兼容。这样有利于每个版本的大更新与小更新，及偶数版本更新内容，奇数版本增加优化。\n\n> 文章的封插画是我的旧方正电脑的主板，为什么使用它作为插画是因为在清明节的时候我本应该着手1.06版本的开发，可是遭遇了数据丢失，而该主板帮我拯救了数据并恢复了系统。	2017-04-21 23:05:03	2017-07-23 14:23:10	2017-07-23 14:23:10	28	StdLib1.06#public更新日志	1001
12498	# HHKB\n\nHappy Hacking Keyboard\n\n---\n\n> 本来这是要作为每月评论的一部分的，但由于写的太长了，也比较有价值，所以我决定单独开一篇文章来写。\n\n我从未有过如此统一的输入体验。\n\n## 先聊聊我的键盘史\n\n&emsp;&emsp;我还记得我最初接触编程的那些童年时光，一个潮热的夏夜，我小心翼翼地敲着键盘，每一次按下的声音都巨大无比，足以吵醒正在睡觉的父母然后被他们骂一顿。这是把与惠普电脑配套的薄膜键盘，近十年的使用早已把它外壳与手掌接触的部分磨损出塑料最原始的颜色，排排缝隙之间藏污纳垢，某些食物残渣之类的东西时而会渗入到薄膜与银触点之间的空隙中，让按键失灵。\n\n<div style="width:100%;text-align:center"><img style="min-width:320px;width:60%;" src="https://cdn.thaumy.cn/post/评测/HHKB/res/HPKB.jpg"></br><em>我最初使用的键盘</em></div>\n\n&emsp;&emsp;在初中毕业的那个暑假，我得到了一些零用钱，便精打细算地在淘宝上浏览，想换一把键盘。有限的预算让我不得不放弃了那些花里胡哨的东西，最终选择了IKBC C87。这是一把没有背光、采用樱桃茶轴的87配列机械键盘。它陪伴了我近五年时光，我用它学会了盲打，换上了喜欢的键帽，每当大家讨论键盘时我都要把它拿出来炫耀一番，那是非常快乐的时光。\n\n<div style="width:100%;text-align:center"><img style="min-width:320px;width:60%;" src="https://cdn.thaumy.cn/post/评测/HHKB/res/C87.jpg"></br><em>半无刻的C87</em></div>\n\n&emsp;&emsp;我曾在C87上使用了长达两年的全无刻键帽，以强迫自己掌握盲打。但最终还是把符号键给换成有刻了，因为我实在是背不下来。\n\n## 对效率的思考\n\n&emsp;&emsp;作为一个写代码的，我常常不停地按动方向键来切换到不同的行、列。我有过思考，为什么不设置一些快捷键来快速定位到行首、行尾或是文档的某个位置？显然是有的，但各个文本编辑器的设定并不统一，我也曾了解过vim，但受限于使用场景和那陡峭的学习路线，我的vim水平一度停留在`i:wq`。\n\n&emsp;&emsp;上个月的某一天，当我再度厌倦那种在键盘和鼠标之间往复所带来的“臃肿”感后，决心要学习vim。至于为什么没有选emacs，是由于先入为主，但vim也确实好用。  \n\n&emsp;&emsp;但我很快就发现了键盘的不便之处。  \n\n&emsp;&emsp;由于vim需要频繁使用<kbd>esc</kbd>，而对于常规布局来说，<kbd>esc</kbd>是需要抬动手掌的按键，这个过程带来了重新定位手掌的“开销”。这种开销不但会影响打字的连贯性，也会让思维停顿，类似的开销也出现在<kbd>del</kbd><kbd>bs</kbd><kbd>enter</kbd>上。  \n\n&emsp;&emsp;第二种不便是布局的不合理。例如，<kbd>ctrl</kbd>是一个需要扭动手掌的按键，但对于某些按键组合来说，这种扭动让一些字母难以定位，例如<kbd>t</kbd><kbd>g</kbd><kbd>b</kbd>。当左手需要按下<kbd>ctrl</kbd>而右手正预备进行下一步操作时（例如<kbd>enter</kbd>），这种“别扭”会被进一步强化，因为这意味着你不能利用右手来触碰到左手难以按下的按键。对于一些符号按键也是如此，例如方括号键。  \n\n&emsp;&emsp;第三种不便是使用习惯的“转换”开销。对于不支持vim的文字场景（例如在浏览器搜索，排除采用vim插件的可能），你无法使用vim上的一些特性。其中影响最大的就是使用<kbd>h</kbd><kbd>j</kbd><kbd>k</kbd><kbd>l</kbd>来进行光标定位，为此，你不得不切换大脑上下文，转而使用那远离字母区域的方向键。这种切换带来的开销比移动手掌还大，尤其发生在频繁切换浏览器和IDE的时候，以至于我经常在搜索框中输入一大堆h或是l。\n\n&emsp;&emsp;虽然对调某些按键位置能够解决一些问题（例如<kbd>ctrl</kbd>和<kbd>caps</kbd>）， 但这并不是优雅的做法。一方面它步骤繁琐，另一方面它难以在系统间转移，而又有很多兼容性问题（我曾对调过<kbd>esc</kbd>和<kbd>~</kbd>，但仍会在一些场景失效，我使用Ubuntu操作系统），至于更改vim配置也是同样的道理。\n\n## 优雅\n\n&emsp;&emsp;时隔多年，当我再次打算购买键盘时，发现市面上的键盘仍旧是那么没有特色可言。无非是换几种配色、多几种轴体、亦或是去掉几个不常用的按键。如果综合我的需求，那就更没几款键盘适合我了。\n\n&emsp;&emsp;以前从未奢望HHKB的我，第一次感受到购买它的必要性，因为我找不到第二把采用相同配列的键盘（即使配列相同，也没有新款HHKB所具备的按键自定义功能）。如果进行客制化，若比较起成本和做工，还不如去买HHKB。\n\n&emsp;&emsp;于是，我从咸鱼购买了这把白色的HHKB Professional Hybrid Type-S。同城面交，据卖家描述它处于仅开封的状态，实际看来也确实是这样（毕竟生产日期为22年1月，属实新到不能再新了）。卖家人很好，送了我HHKB原厂的胡桃木掌托与亚克力防尘罩，共计2300元。可以说是相当实惠了。  \n\n<div style="width:100%;text-align:center"><img style="min-width:320px;width:80%;" src="https://cdn.thaumy.cn/post/评测/HHKB/res/HHKB.jpg"></br><em>我的HHKB</em></div>\n\n&emsp;&emsp;很多人都好奇静电容的手感，我的直观感受是：从按下到触发的感觉就好比攀山，在快要到到达山顶时加力，越过山顶后马上坠落到山谷。相较而言，樱桃茶的手感更像是一条线，线的中间有一点，在手指越过这个点时会感到“咯噔”一下，这是机械轴体的段落感所在。静电容的段落感来自四面八方，而机械轴的段落感则来自一个方向，这是胶碗和单侧机械卡槽的区别所在。两者的手感各具特色，我都很喜欢。\n\n&emsp;&emsp;相较于机械轴的咔咔声，静电容的声音类似于用指关节扣击桌面，而又没有那么清脆。它还会发出一种其他键盘都没有的“沙沙”声，这种声音只会在快速打字时才能感受到，我猜是推杆的摩擦声。由于内置硅胶静音圈，现在我写代码时完全不用担心吵到舍友睡觉，这很棒。\n\n&emsp;&emsp;Hybrid型HHKB支持几乎全键的自定义（仅保留了几个按键用于设置和切换模式，但可玩性仍然很强），这也是我选择它最重要的原因，这解决了我以上的所有使用问题。\n\n<img style="min-width:320px" width="50%" src="https://cdn.thaumy.cn/post/评测/HHKB/res/HHKB_map_L1.png"><img style="min-width:320px" width="50%" src="https://cdn.thaumy.cn/post/评测/HHKB/res/HHKB_map_L2.png"></br><div style="width:100%;text-align:center"><em>这是我目前的映射，可以看出还有很多位置没有使用。我现在可以不用思考地盲打任何标点符号，这已经成为我肌肉记忆的一部分。</em></div>\n\n&emsp;&emsp;作为一款无线键盘，HHKB是合格的。蓝牙很灵敏，开机秒连，感受不到延迟，也没有断连问题。支持多设备切换。两节5号电池能用两三个月左右的样子，如果你没有蓝牙或是电池没电了，也可以切换到有线连接模式。我现在甚至可以躺着写代码XD，完全不用担心布线问题。\n\n&emsp;&emsp;不过作为一款面向市场的产品，HHKB再完美也终究会存在不足之处。最重要的一点就是**太贵**，产品**做工不差但仍有欠缺**（“抛光”痕迹和空格晃动）而对不起这个价格（这点可以学学苹果）。剩下的缺点就只能算建议了（我当然希望产品更能迎合我的使用需求）：\n\n* 全域45g对我来说有点沉，希望能推出35g的版本（静电容是不太容易像线性轴那样被误触的，更轻的克数意味着手指更少的压力负担）。\n* 右侧的FN键不实用，希望能够改到左边或者变成自定义按键。\n* 希望左手区更多的按键能够自定义而与键盘设定不冲突，例如<kbd>q</kbd><kbd>w</kbd><kbd>z</kbd><kbd>x</kbd>。这些按键很容易被按到，仅留作设置使用就太可惜了，相信把这些功能改到<kbd>\\[</kbd><kbd>\\]</kbd><kbd>-</kbd><kbd>=</kbd>这些难以按到的位置会更好。\n* 按键的自定义比较有限，只能将按键映射到实际存在的按键，而不能映射到单独的字符（例如，你只能将<kbd>A</kbd>映射到<kbd>$_4^\\$$</kbd>，而不能映射到单独的<kbd>$</kbd>）。这意味着某些经过自定义的按键仍需采用与原来相同的触发方式，这显得很繁琐。\n\n## 没有“银弹”\n\n&emsp;&emsp;HHKB终究只是一把键盘，而且是仅为程序员设计的键盘。即便如此，它也并不适合所有程序员。其实HHKB本身也有很多局限性，这是它小众的原因。  \n\n&emsp;&emsp;另外，我并不支持类似于“极客只用键盘”的观点。在图形化交互普遍应用的今天，鼠标一类的设备也占据了非常重要的地位，有时候也是更加方便的。不存在什么“键盘代替鼠标”或是“键盘比鼠标好用”一类的说法，这样的观点早就过时了。\n\n&emsp;&emsp;工具只是提升效率的手段，总有更新迭代的时候。或许未来会出现很多HHKB的替代品，或许我某一天也会选择其他键盘。每个人都乐意使用他们喜爱的产品，也并不总是一成不变。\n\n&emsp;&emsp;至于HHKB能否成为我值得信赖的“马鞍”，这需要时间来给出答案。\n\n<div align="right">\n\n使用HHKB编写并发布。\n\n</div>\n	2022-06-05 23:45:00	2022-06-05 23:47:03	2022-06-05 23:47:03	12	HHKB	1001
12376	## 阅读说明\n\n<div style="display:grid;grid-template-columns: 50% 50%;">\n<div style="display:inline-grid">\n<span class="mk-dt">19.04.05<span class="mk-mtn"></span></span>我是日常维护标签<br>\n<span class="mk-dt">19.04.05<span class="mk-dbg"></span></span>我是错误修复标签<br>\n<span class="mk-dt">19.04.05<span class="mk-bug"></span></span>我是发现错误标签<br>\n</div style="inline-grid">\n<div style="display:grid">\n<span class="mk-dt">19.04.05<span class="mk-w"></span></span>我是文案更新标签<br>\n<span class="mk-dt">19.04.05<span class="mk-ui"></span></span>我是界面更新标签<br>\n<span class="mk-dt">19.04.05<span class="mk-updt"></span></span>我是系统更新标签\n</div>\n</div>\n\n## 日志列表\n\n<div class="log_card cur" onclick="up();showPost(12425)">\n  <span class="log_card_title">PB8维护日志</span>\n  <div class="log_ico">查看</div>\n</div>\n<div class="log_card cur" onclick="up();showPost(12400)">\n  <span class="log_card_title">PB7维护日志(已归档)</span>\n  <div class="log_ico">查看</div>\n</div>\n<div class="log_card cur" onclick="up();showPost(12401)">\n  <span class="log_card_title">PB6维护日志(已归档)</span>\n  <div class="log_ico">查看</div>\n</div>\n<div class="log_card cur" onclick="up();showPost(12402)">\n  <span class="log_card_title">PB5-1维护日志(已归档)</span>\n  <div class="log_ico">查看</div>\n</div>\n<div class="log_card cur" onclick="up();showPost(12398)">\n  <span class="log_card_title">WP_public日志(已归档)</span>\n  <div class="log_ico">查看</div>\n</div>\n<div class="log_card cur" onclick="up();showPost(12399)">\n  <span class="log_card_title">WP_beta日志(已归档)</span>\n  <div class="log_ico">查看</div>\n</div>\n<style>\n  .log_card {\n    background-color: rgba(128,128,128,0.1);\n    margin-top: 6px;\n    margin-bottom: 6px;\n    padding: 4px;\n    height: 60px;\n    border-radius: 3px;\n  }\n  .log_card_title {\n    font-size: 20px;\n  }\n  .log_ico {\n    margin-left: 20px;\n    font-size: 16px;\n  }\n  .log_ico::after {\n    font-size: 14px;\n    align-self: center;\n    margin-right: 3px;\n    font-family: 'field-icon';\n    content: "\\e3013";\n  }\n</style>	2019-03-09 19:23:39	2020-09-07 16:54:11	2020-09-07 16:54:11	12	维护索引	1001
12442	&emsp;&emsp;最近一直在研究有关网络的东西。考虑到服务器的运营成本不菲，我期望以一种更实惠的方式挂载我的服务。由于IPV4地址已在2019年分配完毕，我几乎不可能要求运营商为我分配公网IPV4地址，所以我考虑采用IPV6对本地服务器入网。  \n&emsp;&emsp;我的运营商为联通，所用光猫型号为F477V2，由中兴制造，运营商默认为路由模式且不提供管理员密码。我需要获取管理员密码进入后台以更改光猫为桥接模式。这一光猫的版本较新，网上几乎没有破解的教程可以参考（但还是有零星信息可供组装的）。我尽可能地尝试了所有软破解的方法，均无果（某宝报价40可破，但不提供教程）。无可奈何，只能TTL强攻了。\n\n### 准备\n\n~~有手就行~~  \n必备：中兴F477V2光猫、RJ45双公网线、螺丝刀、TTL转USB模块（此处使用CH340）、电脑  \n可选：电烙铁、焊料若干、杜邦线若干、电工胶布\n\n### 实践\n\n&emsp;&emsp;拆下光猫（注意不要损坏光纤），拆除其背面的两颗螺丝(有一颗螺丝在贴纸下面)，小心地打开光猫，注意不要扯坏内部相连的光纤和WLAN同轴线。  \n\n<div align='center'><img style="width:100%;max-width:700px;" src="https://cdn.thaumy.cn/md-img/获取F477V2光猫的管理员密码/pin.jpg"></div>\n<center><em>如图为目标TTL接口的正反面，方形焊盘为VCC。</em></center>\n\n取几条杜邦线，拆除其公头塑料外壳，弯曲一定角度后依次焊入为TTL预留的焊盘（注意先清除焊盘预留锡）。  \n\n<div align='center'><img style="width:100%;max-width:700px;" src="https://cdn.thaumy.cn/md-img/获取F477V2光猫的管理员密码/welding_complete.jpg"></div>\n<center><em>这花了我不少时间。</em></center>\n\n现在将引出的TTL线接入预先准备的TTL转USB模块。  \n其引脚关系为：  \n\n| F477V2 |          /           | CH340 |\n| :----: | :------------------: | :---: |\n|   TX   |          →           |  RX   |\n|   RX   |          ←           |  TX   |\n|  GND   |          -           |  GND  |\n|  VCC   | 缺省，由光猫内部供电 |  VCC  |\n\n<div align='center'><img style="width:100%;max-width:700px;" src="https://cdn.thaumy.cn/md-img/获取F477V2光猫的管理员密码/ttl_mod.jpg"></div>\n<center><em>为便利后续调试，我在光猫上开了一个口子用于引出排线。</em></center>\n\n---\n\n&emsp;&emsp;电脑连接模块，并将光猫LAN1接入电脑。打开串口调试工具（随便下一个就行），选择模块对应的COM，波特率调至`115200`，其他默认，打开串口发送几个回车，等待消息。  \n\n<pre><code>F477V2\nLogin:</code></pre>\n\n出现上述字样后，输入root，随后出现的Password也输入root，如下即登录成功。\n\n<pre><code>F477V2\nLogin: root\nPassword:\nJan 1 00:10:15 1ogin[1368]: root login on 'ttyp0'\nBusyBox v1.17.2 (2020-07-01 02:33:34 CST) built in shell(ash)\nEnter 'help' for a list of built -in comm ands.\nroot@F477V2:~ #\nroot@F477V2:~ #</code></pre>\n\n---\n\n现在打开tftp32软件（自行下载），选择192.168.1.2监听。\n\n在串口工具中依次发送命令：  \n\n1. `cd /userconfig/cfg`//切换到配置文件所在目录  \n2. `tftp -p -l db_user_cfg.xml 192.168.1.2`//向tftp32发送配置文件  \n\n随后即可在tftp32中发现被传回的`db_user_cfg.xml`文件。  \n\n---\n\n由于该xml文件处于加密状态，需使用offzip解密。  \n\n自行下载offzip，将offzip.exe放置在`C:\\Windows\\System32`内，在Ternimal(cmd也行)内应用以下命令：  \n`offzip -a src_path C:\\f477v2_crack 0`//注意末尾的0不要漏掉  \n其中，`src_path`需替换为`db_user_cfg.xml`的所在路径。  \n\n最后，进入`C:\\f477v2_crack`，可以发现有很多个dat文件，我们用文本编辑工具打开后逐个进行查找，即可获得管理员密码明文。\n\n<img style="width:100%;max-width:300px;" src="https://cdn.thaumy.cn/md-img/获取F477V2光猫的管理员密码/admin_pwd.jpg">\n\n管理员密码的标记形式因固件版本而异，这是我的信息位置。\n\n\n---\n\n有关光猫路由转桥接的部分在这里就不介绍了，网上有非常丰富的资料可供参考。\n	2021-01-27 22:30:06	2021-01-27 22:27:50	2021-01-27 22:27:50	12	获取F477V2光猫的管理员密码	1001
12437	# 每月评论\n\n> 考虑到本博客有时候会没东西写，我打算搞一个每月评论，记录一下每月发生的大事。\n\n* 每一刊每月评论将在当月的月末发行，同时也会伴随博客的版本更新。\n\n## Windows10 20H2\n\n&emsp;&emsp;在上上上周，我可怜的VS又犯了病，在卸载重装无效的情况下，我选择了最直接了当的方法：重装系统。（以前我也是这样干的）  \n&emsp;&emsp;然而重装后VS还是会崩溃，反复控制变量检查原因后，我发现这原来是项目中的一段代码引起的。（只要在编辑器一输入这段代码，VS就会崩溃，你甚至都不用编译它！）  \n&emsp;&emsp;不得不说VS还是够烂的，一两个月下来总能出现一些奇奇怪怪的小毛病。  \n&emsp;&emsp;经过一个周的恢复，我的开发环境已经完全恢复，并且更加重视了环境保护（现在有广告和附加的应用基本都被我扔虚拟机了）。  \n&emsp;&emsp;20H2相比上一个版本2004，最直观的就是开始菜单图标透明化。  \n\n<img width="50%" src="https://cdn.thaumy.cn/md-img/每月评论/2011/2004.jpg"><img width="50%" src="https://cdn.thaumy.cn/md-img/每月评论/2011/20H2.jpg">\n\n&emsp;&emsp;在配置环境变量时我还发现，右键此电脑的属性会直接跳转到系统信息，而不是老版本的界面。  \n&emsp;&emsp;20H2内置了新版Edge，而2004则需要另下载。  \n&emsp;&emsp;本次更新变化不大...没什么好看的（我很希望微软能好好改一改通知的样式）。\n\n## <a href="http://www.gxhsoulstar.cn/">Soulstar的博客</a>\n\n&emsp;&emsp;在我的极力劝说下，Soulstar也使用了pilipala，并给出了较高的评价。  \n&emsp;&emsp;从他反馈的结果和我自身的体会来看，噼里啪啦目前的不足主要表现在如下几个方面：\n\n* 叽里咕噜后台缺少评论管理\n* 部署很困难\n* 客制化程度低\n* 一些小毛病，比如如果疯狂请求后台，系统会卡死。\n\n## 苹果发布会\n\n<img width="100%" src="https://cdn.thaumy.cn/md-img/每月评论/2011/mac.jpg">\n\n> 两点起来看发布会真的是挺困的...\n\n&emsp;&emsp;在本月11日，苹果发布了新一代Mac Mini、Macbook Air和Macbook Pro 13。  \n&emsp;&emsp;三款产品都采用了苹果自研的M1芯片，产品的细节我就不多讲了。  \n&emsp;&emsp;M1的表现非常出色。根据测试结果来看，M1的单核性能直接吊打所有移动端CPU，而原生应用下的视频处理性能也一度让PC望尘莫及。  \n&emsp;&emsp;但是我期待的Macbook Pro 16并没有发布，这又要等了。  \n&emsp;&emsp;综合所有因素来看，我认为现阶段还不适合购买苹果的电脑产品。  \n&emsp;&emsp;我很期待M系列芯片的后续，也更希望英特尔能在新制程上有所突破。\n\n> 本月末我又去了一次Apple Sotre零售店，苹果还是那个苹果，产品做工真的没得说。看到5千多的iPhone12 Mini的那一瞬间时我感觉：哇塞，好便宜！...我绝对是疯了。\n\n---\n\n### 聊斋志异\n\n> 本板块专门记录一些月内发生的奇怪有趣的事情。\n\n* 模特猫\n\n<img style="width:100%;max-width:400px;" src="https://cdn.thaumy.cn/md-img/每月评论/2011/cat.jpg">\n\n---\n\n<div align="right">\n\n每月评论 - 2011期(共1期)  \n撰稿&校对&审核：Thaumy\n\n</div>\n	2020-11-30 15:17:37	2020-11-30 15:15:02	2020-11-30 15:15:02	12	每月评论2011	1001
12428	<style>p{text-indent: 2em; /*首行缩进*/}</style>\n\n<blockquote>\n坠吼的版本！\n</blockquote>\n\n### 自pilipala Beta7发布，历经了五个测试迭代，其功能得到不断完善，顺利地完成了整整一年的博客运行任务。  \n\n在运维过程中，发现了许多问题让BETA7变得愈发难以维护。比如三分表设计和基于三层架构的代码设计，如今的噼里啪啦正变得越来越多元化、模块化，现有的情况要得到必要改变。\n\n_我们重新构建了噼里啪啦的组件化底层内核 "WaterLibrary" ，这是噼里啪啦有史以来最强悍的核心。同时，噼里啪啦的默认主题Field，也为全新版本。_  \n\n### <font color="DarkTurquoise">下面让我们一览pilipala beta8先行测试1的新特性：</font>\n\n使用WaterLibrary1.16内核 "Magallan"  \n* 相较于前几代版本，WL1.16不再以三层架构的方式构建，而按功能划分。  \n* 移除了对类库版本检查、XML操作的支持。  \n* 相较于WL1.15，WL1.16已参照C#命名规范重构。  \n* 对pl数据库进一步精简，由原来的三分表改为二分表，提高了可维护性，简化了数据库函数及其命名，简化了表命名。  \n* 针对数据库更改，对WL1.16进行了相应调整。  \n* 修复了WL1.15的cookie操作问题。  \n* 对WL1.15中PaRoot进行了改进优化。  \n* 以操作类型重构噼里啪啦系统内核，对多数代码进行了优化，并提升了安全性。  \n* 新增了文章注册方法、副本添加方法，并对表联合提供安全验证支持。  \n* 删除了MySQL管理类中主命令行（HCommand）的繁杂概念，规范了方法命名，并删除了不必要的检查机制以提升性能。  \n* 删除了啪啦系统中大量的冗余代码，优化了大量循环结构、并将安全可靠的参数化查询应用于所有操作数据库的方法。  \n* 优化了单行查询和单值查询。  \n* 提供了对新增文章、修改文章、删除文章、设置状态的相应支持。  \n* 大幅度提升了代码复用率，使得增添更多功能的同时类库码量小于先前版本。  \n* 在各基层代码单位重新考量了报错弹出机制，简化debug流程。  \n* 优化了代码结构，提高了资源利用效率。\n\n使用氛V3主题 "Field V3"  \n\n使用组件化噼里啪啦beta8系统框架  \n\n### <font color="DarkTurquoise">随着时间推进，后续版本还会包含更多计划内容。</font> \n\n<blockquote>\n目前可以公开的情报：\n</blockquote>\n\nCommentLake  \n\nP#  \n\n叽里咕噜	2020-09-10 07:59:21	2020-09-10 08:00:54	2020-09-10 08:00:54	12	噼里啪啦BETA8!	1001
12473	# Higher-Kinded Type\n\n高阶类型\n\n## 概要\n\n高阶类型是类型阶数大于一阶的类型的统称，它是一种高度抽象的类型。\n\n## 介绍\n\n我们平常接触到的类型大多都是零阶的，即不需要传入类型参数即可得到具体类型。\n例如：\n\n```C++\nint x = 1;\n```\n\nx是int类型的。\n\n## 类型构造器\n\n类型构造器是指构造类型的一种容器，你需要传入其需要的类型参数以构造出完整的类型。\n\n如果你学过C++，那么你应该了解`vector<T>`，它是一种可变数组，由于该数组存储的数据类型不确定，所以它需要有一个类型参数`T`来指定，例如：\n\n```C++\nvector<int> x;\n```\n\n`vector`就是一种类型构造器。\n\n在这里我们为类型构造器`vector`传入了一个类型参数`int`，于是得到了具体类型`vector<int>`，所以`vector<T>`就是一阶类型。注意类型的阶数和类型参数无关，假定我们有一个`type<T1,T2>`，那么它仍然是一阶的，只不过是一个二元一阶类型。\n\n那么二阶类型长什么样子？\n\n## 二阶类型\n\n由于C++不支持高阶类型的语法，所以二阶类型不好表示，如果硬要表示的话，他应该长成这个样子（无法通过编译）：\n\n```C++\ntype<T<_>>\n```\n\n等等，这是什么情况？\n\n相信聪明的人已经发现，类型构造器其实也是一种类型，只不过这种类型不完整，需要我们传入类型参数罢了。那么`type<T<_>>`就很好懂了：type的类型参数是一个类型构造器。  \n由于`T`是一个类型构造器，那么作为二阶类型的类型参数的前提是它不能被构造完全，如果构造完全，那么就意味着它变成了一个具体类型而不是类型构造器了，所以我们用`T<_>`来表示类型构造器`T`具有一个类型参数，其尚未被构造完全。\n\n## 高阶类型\n\n高阶类型是对大于一阶的类型构造器的统称，所以二阶类型就是一种高阶类型。由于大于二阶的类型太过于抽象，目前编程的抽象水平还远不够，所以我们见到的高阶类型大多都是二阶的。\n\n## 有什么用\n\n人们对编程的抽象追求是无穷尽的。由于用纸带打孔写程序太麻烦，于是我们发明了汇编语言。这还不够，于是就产生了如C语言之类的编程语言，显然面向过程的语言在软件更加复杂的时候还不够用，于是产生了如C++、Java之类的语言......这还不够！于是有了各种设计模式啊、各种架构策略之类的抽象思路。\n\n显然，高阶类型是有用的，只不过你不清楚罢了。\n\n考虑以下Java代码：\n\n```Java\npublic ArrayList<Integer> getIntArrayList()\n{\n    return new ArrayList<Integer>();\n}\npublic HashSet<Integer> getIntHashSet()\n{\n    return new HashSet<Integer>();\n}\n```\n\n上面的两个方法分别能够返回空的`ArrayList<Integer>`和`HashSet<Integer>`对象，但是如果我们需要更多类似于这样的函数，都要求它们能够返回一个包裹`Integer`的对象，例如`LinkedList<Integer>`、`TreeSet<Integer>`......显然我们不能写一一百个这样的不同名方法来支持这一百个不同类型的返回值类型，这太麻烦了，而且代码可读性不见得会很好。\n\n高阶类型能解决这一问题。\n\n```Java\npublic <T<_>> T<Integer> getIntContainer()\n{\n    return new T<Integer>();\n}\n```\n\n现在，你只需要传入类型构造器即可获得相应的对象了：\n\n```Java\nvar arrayList = getIntContainer<ArrayList>();//此处借鉴了C#的语法\nvar linkedList = getIntContainer<LinkedList>();\nvar hashList = getIntContainer<HashSet>();\nvar treeList = getIntContainer<TreeSet>();\n...\n...\n```\n\n由于Java也不支持高阶类型，所以上述写法也是行不通的。\n\n当然这里只是举个例子，实际上不用高阶类型也能解决这个问题（例如使用Object放弃类型检查）。但显然高阶类型更为优雅。\n\n实际上，解决代码冗余只不过是高阶类型的副产物罢了，高阶类型是类型安全的，这意味着使用高阶类型的代码能够在编译器被检查出错误，而不是运行期。高阶类型在函数式编程中无处不在，那才是它发挥作用的地方......\n\n## Playground\n\n本节没有作业。\n	2021-12-15 22:54:07	2021-12-15 22:54:07	2021-12-15 22:54:07	12	HKT	1001
12433	<center>\n10月24日！一个属于程序员的节日。<br>\n<img class="bRds bSha" width="16%" style="margin-top:6px" src="https://cdn.thaumy.cn/表情包/kimo_bench.jpg">\n<span style="color:rgba(106,153,85)" >//2020-1024=996</span>\n</center>	2020-10-24 16:13:05	2020-10-24 16:12:05	2020-10-24 16:12:05	12		1001
12445	新年快乐~！ヾ(≧▽≦*)o	2021-02-15 08:08:21	2021-02-15 08:08:49	2021-02-15 08:08:49	12		1001
12448	> 有关链路状态路由选择算法模拟的讨论参见[模拟链路状态路由选择算法(LS)](./12447)\n\n&emsp;&emsp;**距离向量路由选择算法**(Distance-Vector,DV)，著称Bellman-Ford算法，是求解单源最短路径问题的一种经典算法。它提供了一种分布式、异步和迭代的路由选择方式，通过对节点间的交互式通告完成对整个系统的路由求解，在计算机网络中有广泛的应用，如BGP对自治系统(AS)间的路由选择实现。  \n\n&emsp;&emsp;它基于著名的Bellman-Ford方程：\n\n&emsp;&emsp;$d_x(y) = min_v\\{c(x,v)+d_v(y)\\}$\n\n&emsp;&emsp;其中，$d_x(y)$ 表示由源 $x$ 至目的地 $y$ 的最小开销，它通过计算源经各个邻居到达目的地 $y$ 的最小开销比较得出，该方程是**递归**的。\n\n一致性起见，本文将讨论的距离向量路由选择算法与前文LS的讨论将基于同一网络结构，如下所示：\n\n<center><img style="width:60%;min-width:320px" src="https://cdn.thaumy.cn/md-img/模拟链路状态路由选择算法(LS)/图1d1.svg"></center>\n<center>图1.2 源u和目的地z所处的网络</center><br>\n\n考虑以下代码：\n\n<pre>F#<code class="fs">//A very big number to represent the maximum value, it's unreachable\nlet BigNumber = 114514\n\n//Typical Internet node\ntype Node(name) =\n    let mutable _D = new List&lt;C&gt;()\n    let mutable _Neighbors = new List&lt;C&gt;()\n    member this.Name : string = name\n\n    member this.Neighbors\n        with get () = _Neighbors\n        and set (value) = _Neighbors <- value\n\n    member this.D\n        with get () = _D\n        and set (value) = _D <- value\n\n    //While received a D\n    member this.ReceiveD(D: List&lt;C&gt;) =\n        let mutable isChanged = false\n\n        for thisD in this.D do\n            //chose a destination\n            let mutable minD = thisD.cost\n            let dest = thisD.B //y\n\n            for neighbor in this.Neighbors do\n                for d in D do\n                    //if this->neighbor->d->dest was selected\n                    if neighbor.B = d.A && d.B = dest then\n                        if (neighbor.cost + d.cost) < minD then\n                            minD <- (neighbor.cost + d.cost) //c(this,B)+DB(y)\n                            isChanged <- true\n\n            thisD.cost <- minD\n\n        if isChanged then\n            for neighbor in this.Neighbors do\n                neighbor.B.ReceiveD this.D\n\n//Cost from node A to node B (B is A's destination)\nand C = { A: Node; B: Node; mutable cost: int }\n</code></pre>\n\n如果你了解有关计算机网络的的距离向量路由选择算法，你应当理解以下构造：\n\n同样地，`Node`代表了一个路由器节点n，它具有：  \n\n* 路由器名(Name)\n* 邻居集合(Neighbors)\n* n到它的所有可达路由器节点的最小开销列表(D)\n* 接收外界通告的函数(ReceiveD)\n\n注意到以下事实是重要的：  \n&emsp;&emsp;同上次的LS节点构造不同，路由器名`Name`在本用例中并不用作路由器节点的标识，而仅为后续演示提供字符串：即`Name`实际上并不是`Node`构造（有意义）的一部分。  \n&emsp;&emsp;新增的ReceiveD函数用于接收来自其他路由节点的最小开销列表`D`。\n\n相似地，`C`代表由某节点A到任意可达节点B的开销cost，即c(A,B)。注意到B仅仅对于A是**可达的**（即它们并不存在前文所述的邻居关系，且A对于B并不一定是可达的）。\n\n同时引入如下运算：\n\n<pre>F#<code class="fs">//Cost between neighbor A and B\nlet c (A: Node) (B: Node) =\n    let mutable cost = BigNumber\n\n    for neighbor in A.Neighbors do\n        if neighbor.B = B then\n            cost <- neighbor.cost\n\n    cost\n\n//Mininum cost between node A and B\nlet d (A: Node) (B: Node) =\n    let mutable cost = BigNumber\n\n    if A <> B then\n        for node in A.D do\n            if node.B = B then cost <- node.cost\n\n        cost\n    else\n        0\n</code></pre>\n\n运算规则`c`，它接收一对*邻居*节点(A,B)，它用于计算任意节点A到它的邻居B的开销。  \n运算规则`d`，它接收一对*任意*节点(A,B)，计算任意节点A到任意节点B的最小开销。\n\n由综上抽象，构造`图1.2`中经简化网络拓扑关系是容易的：\n\n<pre>F#<code class="fs">let u = Node("u")\nlet v = Node("v")\nlet w = Node("w")\nlet x = Node("x")\nlet y = Node("y")\nlet z = Node("z")\n\n//Set every node's neighbors\nu.Neighbors <-\n    new List&lt;C&gt;(\n        [ { A = u; B = v; cost = 2 }\n          { A = u; B = x; cost = 1 }\n          { A = u; B = w; cost = 5 } ]\n    )\n\nv.Neighbors <-\n    new List&lt;C&gt;(\n        [ { A = v; B = u; cost = 2 }\n          { A = v; B = x; cost = 2 }\n          { A = v; B = w; cost = 3 } ]\n    )\n\nw.Neighbors <-\n    new List&lt;C&gt;(\n        [ { A = w; B = u; cost = 5 }\n          { A = w; B = x; cost = 3 }\n          { A = w; B = v; cost = 3 }\n          { A = w; B = y; cost = 1 }\n          { A = w; B = z; cost = 5 } ]\n    )\n\nx.Neighbors <-\n    new List&lt;C&gt;(\n        [ { A = x; B = u; cost = 1 }\n          { A = x; B = v; cost = 2 }\n          { A = x; B = w; cost = 3 }\n          { A = x; B = y; cost = 1 } ]\n    )\n\ny.Neighbors <-\n    new List&lt;C&gt;(\n        [ { A = y; B = x; cost = 1 }\n          { A = y; B = w; cost = 1 }\n          { A = y; B = z; cost = 2 } ]\n    )\n\nz.Neighbors <-\n    new List&lt;C&gt;(\n        [ { A = z; B = w; cost = 5 }\n          { A = z; B = y; cost = 2 } ]\n    )\n</code></pre>\n\n如上，我们不仅构建了所有节点，还借助*延迟初始化*的思想在各个节点上模拟了引用平等的关系。相较于LS的用例，该方法省去了由字符串到节点实例的映射表。\n\n&emsp;&emsp;在路由选择的初始阶段，需经历一个*初始化*过程。在本用例的初始化阶段，我们将节点地图添加到各个节点的开销表D中并应用已知开销（即计算节点与邻居的开销，并将非邻居节点开销应用为**BigNumber**），稍后对其邻居节点进行开销更新通告。\n\n<pre>F#<code class="fs">//All nodes\nlet NodeMap = [ u; v; w; x; y; z ]\n\n//init the mininum cost to each other\nfor nodeA in NodeMap do\n    for nodeB in NodeMap do\n        if nodeA <> nodeB then\n            nodeA.D.Add(\n                { A = nodeA\n                  B = nodeB\n                  cost = c nodeA nodeB }\n            )\n\n//Advertise neighbor nodes\nfor node in NodeMap do\n    for neighbor in node.Neighbors do\n        neighbor.B.ReceiveD node.D\n</code></pre>\n\n容易想到`NodeMap`是包含所有节点的集合。\n\n`findPath`函数用于递归查找源S至目的地D的最小开销路径（节点列表）：\n\n<pre>F#<code class="fs">//find a path from S to D\nlet rec findPath (S: Node) (D: Node) : List&lt;Node&gt; =\n    let mutable path = new List&lt;Node&gt;()\n    let mutable minCostNeighbor = u.Neighbors.[0]\n\n    if S <> D then\n        let mutable minCost = BigNumber\n\n        for neighbor in S.Neighbors do\n            if (neighbor.cost + d neighbor.B D) < minCost then\n                minCost <- (neighbor.cost + d neighbor.B D)\n                minCostNeighbor <- neighbor\n\n        path.Add minCostNeighbor.B\n        path.AddRange(findPath minCostNeighbor.B D)\n        path\n    else\n        path\n</code></pre>\n\n&emsp;&emsp;该函基于Bellman-Ford方程构造，它持续查找源S的邻居列表以找出具有到达目的地D的最低开销邻居（更加准确的表述是源S到其某邻居的开销和该邻居到目的地D的开销之和为最小），并在该邻居节点上继续应用该查找逻辑，直到抵达目的地D为止。\n\n至此我们完成了对DV算法的简单用例构建，不妨通过测试代码简单地观察该实践是否正确：\n\n<pre>F#<code class="fs">//show all nodes with updated cost\nfor node in NodeMap do\n    Console.WriteLine $"{node.Name} :"\n\n    for d in node.D do\n        Console.Write $"{d.B.Name}:{d.cost} "\n\n    Console.WriteLine "\\n"\n\n//Calculate the path and show\nlet path = findPath u z\n\nfor n in path do\n    Console.Write $"→{n.Name}"\n</code></pre>\n\n<pre>Console<code class="plaintext">u :\nv:2 w:3 x:1 y:2 z:4\n\nv :\nu:2 w:3 x:2 y:3 z:5\n\nw :\nu:3 v:3 x:2 y:1 z:3\n\nx :\nu:1 v:2 w:2 y:1 z:3\n\ny :\nu:2 v:3 w:1 x:1 z:2\n\nz :\nu:4 v:5 w:3 x:3 y:2\n\n→x→y→z\n</code></pre>\n\n如上的输出结果很好地验证了综上所述的DV模拟情况。\n\n&emsp;&emsp;如同我们在有关LS收尾的讨论中表述的那样，同样地，我们可以通过简单的修改使该用例扩展为一个有向图用例（通过建立节点间的不对等开销），但这种修改在本文的DV实现逻辑中的合法性并未经受论证，故其拟合性有待考量。\n\n&emsp;&emsp;尽管本文成功构建了简单的DV算法，但其健壮性仍有待考量。本文的代码逻辑中并未包含路由震荡或是路由选择环路问题的解决方案。\n	2021-03-25 17:03:41	2021-03-26 07:48:12	2021-03-26 07:48:12	12	模拟距离向量路由选择算法(DV)	1001
12471	# Functor\n\n函子\n\n> 为阅读本节，你需要掌握：Kotlin入门\n\n## 概要\n\n**函子**是对一类容器的抽象，该类容器存储一个值，并且对于这个值，该容器规定了它的变换方式。\n\n## 引导\n\n在实践中，我们经常会遇到需要包装一个值的情况，比如：\n\n```Kotlin\nclass Box(val value: Int)\n```\n\n这里有一个`Box`类型，它存储一个`Int`类型的值。  \n但仅这样并不够，因为通常我们需要多种类型的`Box`来装不同的东西。现对`Box`容器进行改造：\n\n```Kotlin\nclass Box<A>(val value: A)\n```\n\n现在`Box`可以装任何类型的东西了。  \n现在我们想改变`Box`内部的值（这包括类型），考虑到避免使用变量可能带来副作用，所以对于`Box`，我们给出一个高阶函数`fmap`用于产生一个新的`Box`来实现以上需求：\n\n```Kotlin\nclass Box<A>(val value: A) {\n    fun <B> fmap(f: (A) -> B) = Box<B>(f(value))\n}\n```\n\n有了`fmap`，我们只需要传入函数`f`（它规定了如何将`A`类型转换为`B`类型），我们就能实现任意`Box<A>`到`Box<B>`的变换。\n\n## 函子\n\n考虑到这种容器十分普遍，所以我们抽象出这类容器的特征，这便是函子的接口表述：\n\n```Kotlin\n/* 由于Kotlin不支持高阶类型，于是我们构造了一个Kind来模拟。\n 此处，Kind<T,V>表示一个具有 一个 类型参数V的类型T */\ninterface Kind<T, V>\n//此处的泛型约束保证了T是有 一个 类型参数的类型\ninterface Functor<T : Kind<T, *>> {\n    fun <A, B> Kind<T, A>.fmap(f: (A) -> B): Kind<T, B>\n}\n```\n\n`Box`现在实现`Functor`接口：\n\n```Kotlin\nobject WithBoxFunctor : BoxFunctor<Any>\nclass Box<V>(val value: V) : BoxFunctor<V>, Kind<BoxFunctor<*>, V>\n\n@Suppress("unchecked_cast")\ninterface BoxFunctor<V> : Functor<BoxFunctor<*>>, Kind<BoxFunctor<*>, V> {\n    override fun <A, B> Kind<BoxFunctor<*>, A>.fmap(f: (A) -> B): Kind<BoxFunctor<*>, B> {\n        val fa = this as Box<A>\n        val fb = Box<B>(f(fa.value))\n        return fb as Kind<BoxFunctor<*>, B>\n    }\n}\n```\n\n其中，单例`WithBoxFunctor`用于导出`BoxFunctor`中的`fmap`方法（通过`WithBoxFunctor.run{}`）以允许`Box<V>`类型调用`fmap`。而`BoxFunctor<V>`是对所有符合Functor特征的`Box<V>`的统一抽象（因为**不管Box这个容器装的是什么**，它都是Functor），类型参数`V`其实是为了满足`Functor<T>`的泛型约束`T:Kind<T,*>`而添加的，即`V`是一个**幻影类型**（Phantom Type）。\n\n虽然这里使用了类型检查屏蔽注解，但由于`fmap`是在`Kind<BoxFunctor<*>, A>`上拓展的，而`Box<V>`恰好就是`Kind<BoxFunctor<*>, A>`，所以仍然是类型安全的。\n\n让我们测试一下：\n\n```Kotlin\nval B1 = Box<Int>(1)\nval result = WithBoxFunctor.run {\n    B1.fmap { x -> "Result is ${x + 1}" }\n}\nprintln((result as Box).value)//Result is 2\n```\n\nAwesome，`Box<Int>`成功地被变换为了`Box<String>`。\n\n## Playground\n\n没有作业\n\n---\n\n### FAQ\n\n* A：为什么在众多语言中选用Kotlin来表述用例？\n* Q：出于易于理解的考虑，本文最初打算使用Java来编写，但由于Java类型擦除式的泛型实现，我对于严格约束的高阶类型和Typeclass始终没有优雅的解决方案。随后我选用了C#进行改写，但很快发现C#对于泛型的约束过于严格（没有类型通配）而难以优雅地实现对instance的抽象，而且C#的拓展方法语法过于繁琐复杂（且无法实现静态扩展！），于是就选用了在以上特性都非常完善的Kotlin。\n\n* A：为什么不借助Kotlin的类型推导而显示地声明类型参数？\n* Q：出于易于理解的考虑，本文会对一些可能难以一步看出的类型显示地声明类型参数，同时部分地借用类型推导功能以方便读者理解哪些类型参数在此处是不必要的。\n	2021-12-15 22:53:26	2021-12-15 22:53:26	2021-12-15 22:53:26	12	Functor	1001
12484	# System F\n\n系统F\n\n## 概要\n\n系统F是一种多态化的 $λ$ 演算，它形式化了编程语言中参数多态的概念。它在 $λ\\scriptsize{→}$ 类型系统的基础上引入了类型参数的概念，允许由类型构造项（即`Type → Term`）。系统F又被称为*二阶 $λ$ 演算*$^{*1}$。\n\n## 有关参数多态\n\n严格意义上的参数多态是指不完整的项（如函数）在构造时不指明具体的类型，而将这部分缺失的类型信息作为参数使用（类型参数），以使得该构造能广泛地适用于各种具体类型。\n\n注意参数多态是对于**项**（Term）而言的，不是对于**类型**（Type）而言的，因此它关注的是如何构造项，而不是如何构造类型。关注如何构造类型的系统称为类型构造器，它是 $λ\\underline{ω}$（Weak Lambda Omega）的组成部分。\n\n系统F可以看作是参数多态的理论依据。\n\n## 形式化表述\n\n相较于 $λ\\scriptsize{→}$，系统F在每个 $λ$ 项前引入了一个类型参数来实现参数多态，比如这个恒等函数：\n\n$Λα.\\ λx:α.\\ x\\ :\\ ∀α.α→α$\n\n在 $λ^{→}$ 中我们是这样定义恒等函数（$I$ 组合子）的：\n\n$λx:α.\\ x:α→α$\n\n但注意到 $α$ 是一个**具体类型**（我在 $λ\\scriptsize{→}$ 那章的末尾提到过），要想覆盖所有类型的恒等函数，我们就要这样做：\n\n$λx:α.\\ x$  \n$λx:β.\\ x$  \n$λx:γ.\\ x$  \n$...$\n\n像极了我们在无泛型语言中的行为：\n\n```C\nint id_int(int a){ return a; }\nfloat id_float(float a){ return a; }\ndouble id_double(double a){ return a; }\n...\n```\n\n但有了系统F，我们的代码就升级成了这样：\n\n```C++\ntemplate<typename T>\nT id(T a) {\n    return a;\n}\n```\n\n即 $ΛT.\\ λa:T.\\ a\\ :\\ ∀T.\\ T→T$ 。\n\n> 请注意！**系统F不是泛型（或模板）**，后者更贴切于*系统Fω*$^{*4}$，因为它具有类型构造器。\n\n虽然 $T$ 被量化了，但是我们不能要求 $T$ 是一个不完整的类型（带类型参数的类型构造器），比如说：\n\n$ΛT.\\ λa:T.\\ a\\ :\\ ∀T:*→*.\\ T→T\\ int$\n\n翻译成C++就是这样：\n\n```C++\ntemplate<typename T<_>>//这里要求T必须是含有一个类型参数的类型构造器，如vector<T>。\nT<int> &getIntContainer() {\n    return *new T<int>();\n}\n```\n\n要实现对T的约束，我们必须引入类型构造器，以下是 $λ\\underline{ω}$ 的表述：\n\n$ΛT:*→*.\\ λa:T.\\ a\\ :\\ T\\ int$\n\n## In λ Cube\n\n在λ立方体中，系统F即为 $λ\\small{2}$，居于 $λ\\scriptsize{→}$的上方。\n\n|  系统\\特征   |   $→$   |  $Π$  |  $ω$  |   $2$   |\n| :----------: | :-----: | :---: | :---: | :-----: |\n| $λ\\small{2}$ | $(*,*)$ |   ╳   |   ╳   | $(□,*)$ |\n\n$(□,*)$ 表示 $λ\\small{2}$ 允许由类型构造项。\n\n---\n\n### 注解\n\n1. 之所以称之为二阶 $λ$ 演算（$λ\\small{2}$），是因为在柯里-霍华德同构下系统F对应于二阶逻辑$^{*2}$。\n2. 相较于一阶逻辑$^{*3}$，二阶逻辑允许量化谓词。如 $∀a,b(a=b→∀P(P(a)↔P(b)))$：对于每个 $a$ 和 $b$，如果 $a$ 等于 $b$，那么对于任意性质 $P$，$P(a)$ 当且仅当 $P(b)$。\n3. 又称谓词逻辑，如 $∀a({\\text{Phil}}(a)→{\\text{Schol}}(a))$：对于每个 $a$，若 $a$ 为哲学家，则 $a$ 为学者。\n4. 即 $λω$，是系统F与类型构造器（$λ\\underline{ω}$）的结合。\n	2021-12-15 22:59:56	2021-12-15 22:59:56	2021-12-15 22:59:56	12	System F	1001
12458	# Bloom Filter\n\n布隆过滤器\n\n## 概要\n\n布隆过滤器是一种基于哈希函数的过滤器，用于过滤一个集合中符合特定哈希特征的元素。通过调整布隆过滤器的相应参数，可以控制过滤的精确程度。\n\n## 技术原理\n\n布隆过滤器由**M**个哈希函数和大小为**N**的二进制数组组成。\n\n大体如下：\n\n<img style="background:white;" src="https://cdn.thaumy.cn/post/技术/瓜计导/Bloom Filter/res/bloom_filter1.svg" width="400px">\n\n其中，每个哈希函数的算法是不同的，但它们均能接受任意字符串的输入，并产生范围为<b>[0,N-1]</b>的输出。\n\n在应用布隆过滤器时，将一个字符串按照固定次序输入每个哈希函数。假定M=3，我们能得到3个输出，它们分别来自这3个不同的哈希函数。在二进制数组（N=12）中寻找与输出相同的下标并将其标志为1$^{*1}$，我们便得到了该字符串（即一个*模式*）的一组哈希特征。\n\n大体如下：\n\n<img style="background:white;" src="https://cdn.thaumy.cn/post/技术/瓜计导/Bloom Filter/res/bloom_filter2.svg" width="400px">\n\n当然，我们可以选择更多的哈希函数和更大的二进制数组来调整布隆过滤器的精确程度。当哈希函数的数量M增加时，会在二进制数组上留下更多的标记，这相当于更详细地描述了模式$^{*2}$。当二进制数组的大小N增加时，我们将得到更大的哈希空间来描述模式，也提高了过滤的精确性。通过调整M与N的大小，我们便可以控制过滤的精确程度。\n\n通过对一个数据集中的所有数据依次应用布隆过滤器并与目标二进制数组进行比对，我们就能过滤到一组符合要求的数据，其中可能含有我们想要的模式。\n\n## 实现\n\n本例使用C++实现一个简单的布隆过滤器。\n\n```C++\n//通过传入num来构造不同的哈希函数\nint hashf(int range, int num, const string &mode) {\n    int i = 0;//最好使用size_t\n    for (auto c:mode) {\n        i += (int)//让结果随机\n                (abs(c - 7) * 7.37 * (c + 128) * (c + num));\n    }\n    return abs(i) % range;//取绝对值是为了防止溢出\n}\n\nint *bloom_filter(int M, int N, int *arr, const string& mode) {\n    int range = N;\n    for (; N > 0; --N) {//初始化arr\n        arr[N - 1] = 0;\n    }\n    for (; M > 0; --M) {//标记哈希位\n        arr[hashf(range, M, mode)] = 1;\n    }\n    return arr;\n}\n```\n\n设置哈希函数个数为8、二进制数组长度为36，对字符串`Good Morning!`应用布隆过滤器得到的结果如下：\n\n```text\n0 0 1 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0\n```\n\n## 应用\n\n布隆过滤器具有模糊查询的性质和很好的保密性，这两种特征使得它非常适合基于非安全信道的数据获取。在数字货币钱包中，通常使用布隆过滤器来向完全节点查询交易地址：通过将目标地址输入布隆过滤器，将得到的二进制数组发往完全节点，使得完全节点能够返回一组符合该数组的交易信息。通过这种方式，钱包能够避免目标地址被他人知晓从而造成安全问题。这就好比你想确认班级中是否的确有某人而不方便透露该人的姓名，于是让同学枚举所有同姓的同学一样。\n\n当然，在精度足够高的情况下，布隆过滤器也可以被当作精确索引使用，就像数据库中的哈希索引一样。\n\n---\n\n## 注解\n\n1. 可能出现多个哈希函数结果相同的情况，在这种情况下，标记位应当为1（只标记不撤销）。\n2. 当M过大时，会出现二进制数组重复置位逐渐增多直到全部置位的情况，在这种情况下，M的大小与过滤精确度是成反比的。\n3. 本代码仅仅用于演示目的，良好的哈希函数应将模式均匀地映射到哈希空间每一个位置。\n	2021-12-15 22:46:18	2021-12-15 23:02:51	2021-12-15 23:02:51	12	Bloom Filter	1001
12444	# 每月评论\n\n> 每月评论 - 第三期\n\n* 每一刊每月评论将在当月的月末发行，同时也会伴随博客的版本更新。\n\n---\n\n## 硬盘坏掉了\n\n陪伴了我六年的移动硬盘，它读不出来了！！！\n\n> 哼哼哼啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊~~（大声哭闹）\n\n<img style="width:100%;" src="https://cdn.thaumy.cn/md-img/每月评论/2101/element.jpg"><div style="width:100%;text-align:center">我的硬盘</div>\n\n&emsp;&emsp;这块硬盘是我初三的时候买的，它也是我真正意义上购买的第一个电子产品，现如今已经陪伴我度过了六年的光辉岁月。这六年间我对它写入了无数的数据并产生了无尽的价值，是最令我满意的电子产品。  \n&emsp;&emsp;但是就在本月的第五天，它 读 不 出 来 了 ！起初电脑提示我分卷出现问题需要修复（大约是一周前），后来，读写速度时而突然将为零，并伴随着磁头反复启动的声音，最终整块硬盘都无法识别。于是我使用DiskGenius扫描了所有柱面，共计346个柱面完全损坏，覆盖了约30GB的空间。大部分损坏发生在起始柱面和终止柱面，分布的还算均匀，具有屏蔽的可能。于是我冗余了130GB在这些分散的柱面上建立了Windows不识别的EXT4分区以起屏蔽作用。\n\n<center><img style="width:230px;" src="https://cdn.thaumy.cn/md-img/每月评论/2101/114514.jpg"><div style="width:100%;text-align:center">一个恶臭柱面</div></center>\n\n&emsp;&emsp;屏蔽后的硬盘剩余800GB可用，它将继续产生价值。\n\n## 第一寒假准备！\n\n&emsp;&emsp;期末考试过后寒假便开始了，大学的放假流程还真是没有一丁点的拖泥带水。  \n&emsp;&emsp;订好了高铁票，从青岛直达荣成，方便极了。  \n&emsp;&emsp;快要到站时被邻座老太太打听旅店的地址，原来她是来看天鹅的，还是从广东来的！我心里特别感激，没想到还真有人会不远万里来荣成看天鹅啊！荣成这个小地方，没想到还真是有人惦记的。如此拥挤堵塞的社会，愿意跋山涉水只为追寻心中美好的人真的不多了。\n\n<img width="100%" src="https://cdn.thaumy.cn/md-img/每月评论/2101/swan.jpg">\n<center><div style="width:100%;text-align:center">“白色的雅子”</div></center>\n\n&emsp;&emsp;出成绩了，及格赛高！多一分浪费~~\n\n立个Flag单子，看看三月评论能不能实现吧......\n\n|         项目列表         | 难度系数 |\n| :----------------------: | :------: |\n|    至少读完两本箱底书    |  ?????   |\n| 三体第三部看完前三分之一 |   ???    |\n|    新头像绘制(设定陆)    |   ???    |\n|     每天都要写代码！     |    ??    |\n|         补番3部          |    ??    |\n\n## HiRes没有了！\n\n> 要知道我的AKG才用了两年啊！ <img height="50px" src="https://cdn.thaumy.cn/md-img/每月评论/2101/Nooo.jpg">\n\n<img width="100%" src="https://cdn.thaumy.cn/md-img/每月评论/2101/akg.jpg">\n\n&emsp;&emsp;其实我这耳机很久以前就坏过了，刚买不到一个月，线材就有部件脱落，考虑到可以换线我也没顾忌什么。到后来，左右导管相继脱落，正逢过年无售后可修，我于是无奈地用502给粘上。粘好后的耳机还有偏音，只得通过补偿左右声道的音量和换用不同的耳机套解决。再后来，线材老化......不得不说AKG的质量真是让人感动啊。  \n&emsp;&emsp;被三星收购后的AKG我实在是不敢恭维了，在以耐用性为主的挑选标准下，我买了条碧SoraLight。\n\n<center><img width="80%" src="https://cdn.thaumy.cn/md-img/每月评论/2101/sora.jpg"></center>\n\n&emsp;&emsp;日本厂商也没少玩噱头啊，这宣传的陶瓷单元也不过就个给动圈嘛......不过无所谓啦，对于我这种木耳来说，像个样的HIFI塞子都听起来都差不多啦...或许，我想听到的天籁之音也只能靠EQ了吧。耳机这种东西，还是太烧钱了。\n\n<img height="100px" src="https://cdn.thaumy.cn/md-img/每月评论/2101/vido.jpg">早知道，还是原道！<img height="100px" src="https://cdn.thaumy.cn/md-img/每月评论/2101/hires.gif">\n\n---\n\n往事随风。\n\n---\n\n<div align="right">\n\n每月评论 - 2101期(共3期)  \n撰稿&校对&审核：Thaumy\n\n</div>\n	2021-02-08 20:29:03	2021-02-08 20:30:20	2021-02-08 20:30:20	12	每月评论2101	1001
12400	<span style="float:right;" class="wd-dt5 cur" onclick="up();showPost(12376)">点此返回索引根目录</span>\n\n## PILIPALA 1902BETA7 LTS Build3维护日志\n\n<span class="mk-dt">20.08.30<span class="mk-ui"></span></span>引入了Gitalk作为评论模块（测试版本）  \n<span class="mk-dt">20.08.02<span class="mk-ui"></span></span>进一步优化了分辨率兼容性  \n<span class="mk-dt">20.07.30<span class="mk-ui"></span></span>微调了ui部分栏目的间隔  \n<span class="mk-dt">20.07.30<span class="mk-ui"></span></span>优化了导航栏和文章栏的宽度比例，支持在较低分辨率的显示设备上显示更多内容，但对于超高分辨率(6K以上无缩放)会出现导航栏纵向间隔过大的情况。  \n<span class="mk-dt">20.05.09<span class="mk-updt"></span></span>CNZZ记录服务已恢复  \n<span class="mk-dt">20.05.09<span class="mk-ui"></span></span>修复了因githack错误而导致的mrks和wrds标记样式丢失的问题  \n<span class="mk-dt">20.04.30<span class="mk-updt"></span></span>氛：文章计划标签现可用  \n<span class="mk-dt">20.04.30<span class="mk-updt"></span></span>多文章状态属性现可用（例如归档、计划、隐藏、禁用等等）  \n\n## PILIPALA 1902BETA7 LTS Build2维护日志\n\n<span class="mk-dt">20.04.22<span class="mk-updt"></span></span>氛：文章归档标签现可用  \n<span class="mk-dt">20.04.04<span class="mk-ui"></span></span>首页欢迎图片改为A/Z ED，并使用随机显示  \n<span class="mk-dt">20.04.04<span class="mk-ui"></span></span>高考倒计时样式修改  \n<span class="mk-dt">20.04.02<span class="mk-ui"></span></span>春天来啦（都快夏天了好呗），博客不下雪了  \n<span class="mk-dt">20.03.31<span class="mk-updt"></span></span>应国务院要求，高考倒计时修改（大雾）  \n<span class="mk-dt">20.03.05<span class="mk-updt"></span></span>引入了GITTER聊天室，右下有个奇怪的东西~！  \n<span class="mk-dt">20.02.27<span class="mk-dbg"></span></span>便签文本不支持样式渲染的BUG已经修复  \n<span class="mk-dt">20.02.27<span class="mk-ui"></span></span>在置顶文章样式中添加了高考倒计时  \n<span class="mk-dt">20.02.27<span class="mk-ui"></span></span>更改了氛主题背景图  \n<span class="mk-dt">20.02.16<span class="mk-updt"></span></span>修复了因前后文章跳转按钮目标索引为空值而造成的内容页无法加载问题  \n<span class="mk-dt">20.02.14<span class="mk-updt"></span></span>内核升级到WL115_B5，在部分单项查询的函数上做了性能优化  \n<span class="mk-dt">20.02.12<span class="mk-updt"></span></span>修改了"到现在时间"的判定机制  \n<span class="mk-dt">20.02.08<span class="mk-updt"></span></span>将PaFn中通用性较差的函数移交到Basic服务  \n<span class="mk-dt">20.02.08<span class="mk-updt"></span></span>在内容页新增了文章字数显示功能  \n<span class="mk-dt">20.02.08<span class="mk-updt"></span></span>修复了文章概要函数无法使用的BUG  \n<span class="mk-dt">20.02.07<span class="mk-updt"></span></span>完成了基于RAZOR视图引擎的氛构建，这种构建方式利于简化开发流程  \n<span class="mk-dt">20.01.24<span class="mk-ui"></span></span>微调了主题的部分样式，以提升高DPI平板设备的观感  \n<span class="mk-dt">20.01.24<span class="mk-updt"></span></span>内核升级到WL115_B4，优化了部分查询性能，增添了一些新函数以支持文章迭代技术  \n<span class="mk-dt">20.01.24<span class="mk-updt"></span></span>修改了数据库结构，现支持文章版本迭代及历史恢复  \n\n## PILIPALA 1902BETA7 LTS Build1维护日志\n\n### 从本日志起，维护日志上载情况不作登记。这样做利于提升日志的目的性和维护效率\n\n<span class="mk-dt">20.01.17<span class="mk-ui"></span></span>增加了雪花飘落特效  \n<span class="mk-dt">19.12.04<span class="mk-updt"></span></span>内核版本现已升级至WL115_B1，优化了性能，新增多种数据类型以原生支持文章筛选输出  \n<span class="mk-dt">19.12.04<span class="mk-dbg"></span></span>修复了进入文章后文章封面图片消失的问题  \n<span class="mk-dt">19.12.04<span class="mk-dbg"></span></span>维护日志部分内容出现带有删除线的错误渲染的问题已修复  \n<span class="mk-dt">19.11.24<span class="mk-mtn"></span></span>现已支持文章置顶功能  \n<span class="mk-dt">19.11.23<span class="mk-mtn"></span></span>基于文章归档的列表输出函数现可用（评估阶段）  \n<span class="mk-dt">19.11.23<span class="mk-mtn"></span></span>wd-dt5黄色强调标签现可用  \n<span class="mk-dt">19.11.17<span class="mk-mtn"></span></span>现已支持NOTE类型文章格式（评估阶段）  \n<span class="mk-dt">19.11.02<span class="mk-mtn"></span></span>WL内核的归档筛选函数现可用  \n<span class="mk-dt">19.11.02<span class="mk-mtn"></span></span>维护索引二级目录现可用  \n<span class="mk-dt">19.10.20<span class="mk-mtn"></span></span>正在申请GoogleAdsense服务  \n<span class="mk-dt">19.10.20<span class="mk-updt"></span></span>“文章概要现可根据内容自动生成(取前一段字符)” 的功能现已加入pala函数  \n<span class="mk-dt">19.10.20<span class="mk-bug"></span></span>由于服务器字符集问题，emoji表情暂不可用  \n\n\n## PILIPALA 1902BETA7 LTS 先行测试2维护日志\n\n<span class="mk-dt">19.10.19<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.10.19<span class="mk-updt"></span></span>修改了数据库字符集，现已支持emoji表情  \n<span class="mk-dt">19.10.19<span class="mk-ui"></span></span>主题现已支持列表样式  \n<span class="mk-dt">19.10.13<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.10.13<span class="mk-updt"></span></span>内核版本现已升级至WL115_A3  \n<span class="mk-dt">19.10.13<span class="mk-dbg"></span></span>友情链接样式失效问题现已解决  \n<span class="mk-dt">19.10.13<span class="mk-updt"></span></span>主题现已支持选择性显示归档和标签：若该文章无归档则不显示归档，标签同理  \n<span class="mk-dt">19.10.13<span class="mk-dbg"></span></span>日期属性和时间属性错位显示的问题现已解决  \n<span class="mk-dt">19.10.02<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.10.02<span class="mk-dbg"></span></span>时间显示错误的问题现已修复  \n<span class="mk-dt">19.10.02<span class="mk-updt"></span></span>时间文字现可用  \n<span class="mk-dt">19.10.01<span class="mk-updt"></span></span>文章概要现可根据内容自动生成(取前一段字符)  \n<span class="mk-dt">19.09.21<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.09.21<span class="mk-updt"></span></span>数据库信息从写死变更为读取Web.config以增进部署效率  \n<span class="mk-dt">19.09.21<span class="mk-updt"></span></span>数据库cover_url替换为before_html，现支持更多网页样式加入列表图片位置  \n\n## PILIPALA 1902BETA7 LTS 先行测试1维护日志\n\n### 从本日志起，文章的变更和发布将不做记录，相关内容移交后续更新。\n<span class="mk-dt">19.09.06<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.09.06<span class="mk-ui"></span></span>修改了维护日志标签样式  \n<span class="mk-dt">19.08.31<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.08.31<span class="mk-bug"></span></span>维护日志部分内容出现带有删除线的错误渲染  \n<span class="mk-dt">19.08.30<span class="mk-ui"></span></span>现点击菜单上的版权信息即可呼出关于博客页  \n<span class="mk-dt">19.08.29<span class="mk-dbg"></span></span>进行了备份替换，修复了时间数据错乱的问题  \n<span class="mk-dt">19.08.29<span class="mk-bug"></span></span>由于数据表时间戳逻辑有误，文章最后编辑时间全部错乱  \n<span class="mk-dt">19.08.28<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.08.28<span class="mk-updt"></span></span>文章识别码现可用  \n<span class="mk-dt">19.08.28<span class="mk-updt"></span></span>文章作者现可用  \n<span class="mk-dt">19.08.27<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.08.27<span class="mk-ui"></span></span>为主题图片加载进行了CDN优化  \n<span class="mk-dt">19.08.27<span class="mk-dbg"></span></span>解决了highlight.js在ajax第二次异步请求后无法对代码进行高亮显示的问题  \n<span class="mk-dt">19.08.27<span class="mk-ui"></span></span>为氛V2主题提供了响应式壁纸  \n<span class="mk-dt">19.08.26<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.08.25<span class="mk-updt"></span></span>数据表时间戳逻辑修改  \n<span class="mk-dt">19.08.24<span class="mk-w"></span></span>纠正了几个错别字，感谢<span class="wd-dt3">雅爱方雏</span>的支持  \n<span class="mk-dt">19.08.24<span class="mk-updt"></span></span>PILIPALA BETA7于生产环境部署，这包括：  \n\n* 采用Kaguya架构WaterLibrary1.15内核  \n* 采用Kaguya架构PILIPALA ASP.NET程序  \n* 为BETA7设计的MySQL数据库  \n* 为博客设计的氛V2主题  \n\n<span class="mk-dt">19.08.23<span class="mk-updt"></span></span>为WL1.15内核修复了若干问题  	2019-11-02 19:09:26	2020-08-30 21:51:17	2020-08-30 21:51:17	12	PB7维护日志	1001
12427	<blockquote>\n“ 漂亮到欠打 ”\n</blockquote>\n\n<center>\n<img style="width:100%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V3/强兼容.svg">\n\n## 强兼容\nField3可在720p至6k保持良好观感，这是Field2兼容范围的二倍。  \nField3针对移动平台的显示设备进行了特别优化，当你的显示器支持高ppi时Field3也能良好兼容。\n\n<br><br>\n\n<img style="width:30%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V3/黑白.svg">\n\n## 两种颜色模式\n是否觉得Field2过于耀眼？  \n现Field3支持暗色主题，你可以通过切换CSS的方式选择其一，或让噼里啪啦自我判断，实现自动切换。\n\n<br><br>\n\n<img style="width:100%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V3/键盘.png">\n\n## 专注于创作\n简单直观的设计理念贯彻Field系列主题的设计始终。  \n我们重新优化了主题的各项细节，应用了很多有益于交互的动画效果，每一颗像素的调整和每一毫时间的计算都经过精心考量。\n\n<br><br>\n\n<img style="width:10%;min-width:60px;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V3/Vue.svg">\n\n## Vue\nField3使用Vue渐进式构建，精简高效的运作方式让dom渲染瞬间完成。\n\n<br><br>\n\n<img style="width:70%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V3/许可证.svg">\n\n## 永久开源\nField3是完全免费公开的客制化主题，任何人都可以下载其源代码进行修改。  \n同时Field3也尊重大家的版权，当Field3引用相关作品时，也会在相应位置标明其出处。\n\n<br><br>\n\n<img style="width:70%;box-shadow:none;" src="https://cdn.thaumy.cn/md-img/氛V3/MKD.svg">\n\n## 经过改进的Markddown\nField3延续了倍受好评的Markddown文档支持，允许各位艺术家们把更多的精力投入到内容创作，而非烦恼于格式设定。  \n同时，Field3应用了更加先进的Markddown解析引擎，高效快速的解析引擎是制胜的关键所在。  \n同时，我们对Markdown样式也进行了深度定制，在最大限度上为可读性效力。\n\n<br><br>\n\n<pre>C#<code>public void HelloField()\n{\n    Console.WriteLine("Field，V3!");\n}</code></pre>\n\n## 优化的代码高亮系统\n与Field2不同，Field3的代码高亮显示更加简洁明了。  \n现更支持`块状代码显示`。\n\n</center>	2020-09-10 07:51:29	2020-10-01 22:15:36	2020-10-01 22:15:36	12	氛V3	1001
12381	<span style="float:right;" class="wd-dt5 cur" onclick="up();showPost(12387)">转到“我”</span>\n\n# <span class="wd-heimu">孤僻内向的大病娇</span>\n\n> 此设定适用于《东联往事 · 卷Ⅱ : 人类量产计划》的前半部分章节，设定不适用于所有量产阶段的Thaumy。\n\n## <span class="wd-dt4">P1</span> <span style="color:#48D1CC">基本设定</span>\n\n很少和陌生人交谈来往。  \n对于他人的主动接触显得十分敏感（尤其异性），不会主动透露自己的兴趣爱好（如果不被主动询问或者有特殊情况的话）。  \n好胜心极强，与更优秀的人接触时有极强的阴谋论心理（自动将对方的一切行为脑补成与自己敌对的战略举措），并且表现得极为冷漠。  \n心情不好时会发生黑化反应，将解决目前问题列为最高优先级，此期间会丧失基本人格。遇到高兴的事情时黑化会慢慢解除，表现为乐于或主动和较为熟悉的人交流（陌生人介入的最佳时机）。\n\n## <span class="wd-dt4">P2</span> <span style="color:#48D1CC">设定详情</span>\n\n### <span style="color:#9ACD32">性格表征</span>\n\n适用于基于ThaumyNERVSYS的pH调节系统触发器：  \n当看到比自己优秀的人的时候，Thaumy倾向于表现出批判面，认为该人一无是处（并认为其擅长的方面没有应用价值），并造成Thaumy体内的氢离子浓度上升。  \n\n心情不好时会降低做任何事情的积极性，且懒于说话。主动回避与自己作风完全相反的人（必须是很完全时才会触发）。  \n\n不乐意在他人面前展示自己优秀的一面，但是如果对其进行主动试探，Thaumy绝对会毫不保留的把他知道的全告诉你。。。  \n\n> 社交准则1：由于 A.T. FIELD 的作用，和Thuamy进行谈话时必须表现出主动。Thaumy表现出的冷淡是他想继续交流的最好证明。（该社交准则不适用于于Thaumy性格匹配度低于30%的人）\n\n> 行为学表征1：当持续进行Thaumy极感兴趣的话题时，Thaumy会表现出身体发抖，感觉很冷的症状。\n\n### <span style="color:#CC3300">履历&档案</span>\n\n代号：Thaumy  \n<span class="wd-dt4">C31识别码：17A2EF1G1C0536</span>\n\n事务机构：  \n\n### A&M（阵方互联）\n<img width="300px" src="<{cdn_root}>/md-img/am_logo_1810.svg">\n\n### H2OMSOCIE（水瓜社）\n<img  width="300px" src="<{cdn_root}>/md-img/h2om_logo_1907.svg">\n\n### Community31（31学社）\n<img  width="300px" src="<{cdn_root}>/md-img/c31_logo_1802.svg">\n\n### 生理学采样报告：未公开  \n\n来自水瓜社的数据：\n水瓜标准基金委员会成员  \n水瓜常任委员会成员  \n\n来自阵方互联的数据：  \n此项目需要K1级别读取权限。您的设备不具备该许可级别。  \n来自C31的数据：  \n此项目需要F1级别读取权限。您的设备不具备该许可级别。  \n\n### <span style="color:#FF8C00">兴趣爱好</span>\n\n画画  \n打代码  \n某些设计  \n听歌（ACG）  \n\n# SP：其他属性\n\n### <span style="color:#48D1CC">十分差劲的全栈</span>\n\n在建模、板绘、视频、音乐、编程、硬件、艺术设计等领域都有不同程度的涉猎，<span class="wd-heimu">有了搜索引擎的支持</span>，Thaumy可以短时间内在任何一方面按需做出自己满意的作品。<span class="wd-heimu">某孙子王也是</span>\n\n### <span style="color:#48D1CC">与生俱来的强迫症</span>\n\n即使一个像素点的差别，Thaumy也会尽可能地考虑到它出现的合理性。这样的性格特点让使得Thaumy过分地注重细节，宁可用过低的时效比换取自己满意的成果。\n\n### <span style="color:#48D1CC">我是一位艺术家</span>\n\nThaumny总是有着独到的见解。丰富的想象力和大胆的尝试让理想和现实达成共识。\n>编程是门艺术，而我，是艺术家————Thaumy\n\n### <span style="color:#48D1CC">24x7x365宅</span>\n\n说到宅，没人能比得上Thaumy。————不应过多解释，这是公认的事实。  \n但是基于最新的数据表明Thaumy貌似想要出去看看这个世界。	2019-04-13 23:51:04	2020-11-28 13:13:54	2020-11-28 13:13:54	28	Thaumy人设	1001
12424	PaLang  \n一门用于维护噼里啪啦数据库的简单查询语言。  \n缩为P#，灵感来自微软。\n\n考虑到全局更新数据库的操作困难和后台系统尚未开发完成，我想到了用命令操作噼里啪啦系统，实现对文章的更新，这和最原始的操作系统非常相近，区别在于前者是用来管理文档资源的。  \n\n受限于技术和时间，这一切还停留在构想之中。  \n语法启发自SQL，但SQL中一些符号也是很让我头疼的问题。  \n我想避免命令中出现转义字符，让这个语言不那样让人感到“专业化”...  \n\nupdate  \n该命令支持增量更新文章数据库。  \n其中，更新时间由解释器自动生成。\n\n<pre>P#<code>\nupdate by id with  \ntitle = "",  \ncontent = "",  \nsummary = "",  \narchiv = "",  \n...\ntag = "";\n</code></pre>\n\nreg  \n该命令可注册一个文章。  \n其中，创建时间、更新时间、id、guid自动生成。\n<pre>P#<code>\nreg by id with \ntitle = "",  \ncontent = "",  \nsummary = "",  \narchiv = "",  \n...\ntag = "";\n</code></pre>\n\nsearch  \n该命令输出相关查询到的文章信息。  \n\n<pre>P#<code>\nsearch title/id/guid/summary/content/archiv/tag/createTime/changeTime by title/id/guid；\n</code></pre>\n\ndelete  \n用于注销文章  \n<pre>P#<code>\ndelete reg by id 12345;  \n</code></pre>\n删除文章副本  \n<pre>P#<code>\ndelete post by guid 51c2acd9-eb72-4c8f-9e4a-37f78b34e68a;  \n</code></pre>\n\n停留于构想的计划。  \n虽然一门新语言的构造需要功课大量难题，但我并不打算让P#变成高可用性和强兼容的查询语言，就像SQL那样，这可能让任务变得简单。目前我需要完成的是如何正确解析字符串，使其能够完成相应的任务。  \n这里仍然有许多问题，使用命令并不直观，也不见得比图形界面更加高效，考量它的存在意义也是其中之一。	2020-07-28 19:38:00	2020-09-08 09:35:30	2020-09-08 09:35:30	12	PaLang概要	1001
12443	&emsp;&emsp;我的域名最近被扫到了，于是云服务器提供商那边要求我备案后再解析。众所周知啊，有关部门的工作效率是相当感人的。我在1月20号提呈的备案申请至今仍处于审核状态，博客又不能一直这么掉着，于是就探索一下绕过备案的方式吧。  \n&emsp;&emsp;未经备案的国内服务器会被封锁80和443端口，分别对应HTTP和HTTPS协议。所以我们要使用别的端口进行映射，这里我使用81端口作HTTP协议。  \n&emsp;&emsp;其实绕过备案的方法有很多种啦，这里我使用CDN来绕过备案。首先国内的CDN服务是不能用的，因为也需要备案，所以我们使用国外的CDN提供商<a href="https://console.nodecache.com/">Nodecache</a>作内容分发。Nodecache是国外的一家云服务提供商，由于节点目前尚少，所以CDN的速度可能稍逊些（但这足够让我度过这段无聊透顶的审核期了）。Nodecache对新用户提供了500G且为期一个月的试用流量，可使用重复注册的方法白嫖。\n\n### ~~最佳实践~~\n\n&emsp;&emsp;首先注册，进入CDN页，创建服务。\n<center><img style="width:100%;max-width:700px" src="https://cdn.thaumy.cn/md-img/利用CDN绕过备案/new_serv.jpg"></center>\n<center><em>省略了原图中不影响教学的内容</em></center>\n\n&emsp;&emsp;服务名称随便填，加速域名填写网站地址，勾选全站加速，回源协议按需选择（我临时使用HTTP，于是勾选了HTTP），配置类型为IP，线路配置栏中的原站地址填写你的主机IP，端口除了80和443随便填（但也要注意不要和主机上的已有服务端口冲突，我在此选用81），加速区域勾选中国优化，确认创建。\n\n<center><img style="width:100%;max-width:700px" src="https://cdn.thaumy.cn/md-img/利用CDN绕过备案/hy_host.jpg"></center>\n\n&emsp;&emsp;第二步，配置刚刚创建的服务，进入回源管理：在回源Host内填入你的主机IP（和上一步中相同）。\n\n&emsp;&emsp;接下来捣鼓我们的服务器，由于我的服务器内部署了多个Web站点，所以使用了Nginx做转发服务。  \n编辑Nginx的conf配置文件，将Web应用转发至81端口即可：\n<pre><code>server {\n    listen 81;#也可改用其他端口\n    server_name localhost;\n\n    location / {\n        proxy_pass http://localhost:114514;#这是目标Web应用地址\n    }\n}</code></pre>\n\n&emsp;&emsp;好。现在你的网站就能绕过备案被正常访问啦！\n\n---\n\n&emsp;&emsp;不过还是建议把备案做了，海外CDN这种方法虽然可用，但想得到正常的访问速度还是需要金钱为代价的。此举让我博客的响应速度从1s下降至10s+，体验还是很差的。\n	2021-01-28 22:09:50	2021-01-28 22:10:38	2021-01-28 22:10:38	12	利用CDN绕过备案	1001
12486	# Type Inference\n\n类型推导\n\n## 概要\n\n类型推导是编程语言的一种特性，它允许程序员不显示(Explicit)地写出变量的类型而声明变量，这使得程序员省去了不必要的工作，也提升了键盘的使用寿命（大雾）。类型推导是强类型的，因而具有类型安全性，应当注意到其与弱类型的区别。\n\n## 简单的类型推导\n\n许多语言支持类型推导，只是类型推导的程度不同，例如C++11中的`auto`关键字：\n\n```C++\nauto x = 1;\n```\n\n虽然未指明`x`的类型，但编译器会根据值`1`而自动推导出`x`为`int`类型。\n\n同样的还有Java或C#中的`var`关键字等，这都是最简单的类型推导。类型推导不限于元类型，泛型推导也属于类型推导。\n\n## Kotlin中的增强型类型推导\n\n由于Kotlin借鉴了函数式语言中的许多特性，所以Kotlin具有很强的类型推导能力，下\n面是一些例子（并不局限于此！）：\n\n```Kotlin\n//例1\nfun f(x: Int) = x //返回值类型自动推导，f(x)的返回值类型为Int\n```\n\n```Kotlin\n//例2\nfun <T> f1(): MutableList<T> {\n    return mutableListOf<T>()\n}\nfun <T> f2(): MutableList<T> {\n    return f1<T>()//<T>是可以去掉的，在这里被推导了\n}\n```\n\n另外Java的后向推导也能实现这种功能，但其前向推导是部分功能缺失的（比如你不能用`var x = f1<T>();`这种写法），而C#则缺失了后向推导的部分功能，例2就是C#不能做到的，之所以称Kotlin是增强的，是因为其在前后推导上都很完善。\n\n虽然Kotlin使用了增强型类型推导，但其仍有局限性，例如返回值类型推导不能推导递归函数，如：\n\n```Kotlin\nfun fib(x:Int) = if (x>0) { x * fib(x-1) } else { 1 }\n```\n\n该计算斐波那契数列函数不能推导出自己的返回值类型。\n\n## 函数式语言中的类型推导\n\n通常，函数式语言具有极强的类型推导能力，甚至强到把显式类型声明作为逻辑约束的存在（类型约束，类似于泛型约束）。你甚至不需要显示声明泛型，这种能力被称作自动泛化：\n\n```Haskell\nf g x = g x\n```\n\n编译器会自动推导出`g`为函数，而`x`为符合`g`的参数的值，但`g`和`x`具体是什么类型的呢？它们自动泛化的，即所有满足以上特征的`g`和`x`均可被作为f的参数，同时f的返回值类型也被自动推导。\n\n你可能觉得这种类型推导的自由度太高了，如果运用不当，会造成程序错误而无法发现，就像C++中的函数模板或JavaScript中的弱类型一样。其实正是由于强大的类型推导能力，Haskell中的类型错误在编译期就能得到发现，而不是遗留到运行期。\n\n## Playground\n\n今天没有作业。\n	2021-12-15 23:00:28	2021-12-15 23:00:28	2021-12-15 23:00:28	12	Type Inference	1001
12497	# 每月评论\n\n> 每月评论 - 第十期\n\n* 受限于各类因素，每月评论将按需发行。\n\n---\n\n## 和平与战争\n\n最近俄罗斯与乌克兰在打仗。有些人支持俄罗斯，有些人支持乌克兰。那些支持俄罗斯的人声称乌克兰违反了什么新明斯克协议，乌克兰意图加入北约不利于世界和平之类。而那些支持乌克兰的人则说俄罗斯的军事行动是对一个主权国家赤裸裸的侵略。\n\n>后藤先生，作为警察官，作为自卫官，我们应该守护的到底是什么？上次战争已是半世纪前的往事了，之后出生的你和我都从未经历过战争。和平、我们本应该守护的和平......但这个国家、这座城市所享受的和平到底是由什么构成的？曾经的总体战和其之败北、美军的占领政策、直到最近建立在核威慑之上的冷战和其代理战争......如今世界大半仍然困陷的内战......民族冲突、武力纷争......通过无数战争所创造的需求而建立支撑起来的、粘满鲜血的经济繁荣，这就是构成我们和平的东西。由对战争的恐惧而驱动，不在乎一切的和平；以它国之战争为正当代价，对其苦难熟视无睹的非正义的和平。  \n>\n>--这也许是丑陋的和平......  \n--但我们的使命就是去守护它。  \n--就算是非正义的和平，也要好过正义的战争。  \n>\n>我理解你为何厌恶所谓“正义的战争”，毕竟在过去叫嚣这东西的都不是什么好家伙。民众听信了这些人的谗言并最终为此付出惨痛代价，历史的图书馆里满是这样的例子。但你也该知道：正义的战争、非正义的和平，两者之间的分界线并不是那么清晰。当和平的言语沦为了骗子口中的正义后，我们便也不再相信那和平了。正如战争会带来和平......和平也会带来战争。  \n>单以“不是战争”为其定义的消极空虚的和平，最终只会变成与真实战争别无两样的东西。我们坐享着战争所带来的成果，将战争本身推到了电视屏幕的另一端。可却忘了这里其实也只是战场的后方......不，只是假装忘记而已。若继续这样自欺欺人下去，最大的惩罚总有一天会落到我们头上。\n>\n>--惩罚？  \n--谁会惩罚我们？  \n--神吗？\n>\n>在这座城里，所有人都仿佛是神。目睹世间一切可又足不出户，洞悉所有现实但却不用亲手触碰......袖手旁观的神。神不为者，人为之。迟早会见分晓的。\n\n上面一段对话取自机动警察剧场版2。俄罗斯的战争可能不是正义的，乌克兰的和平也可能是虚伪的，我们则是袖手旁观的神——坐在屏幕的另一端，把一场真实的、正在发生的战争当作茶余饭后的谈资。\n\n这一切的一切，都让我不再信仰和平，也不再厌恶战争了。人类的敌人终究是人类自己，所谓的和平与战争，都只不过是政客们所执棋牌的正反面，这是一场用活人下注的游戏。\n\n---\n\n## 形式与修正\n\n>同学，最近过的还好吗？  \n--老师，您就开门见山地说吧，今天找我来，是有什么事情？  \n我是找你来谈有关青年大学习的事情的。  \n--您是找我来学习青年大学习的内容呢？还是找我来完成青年大学习呢？  \n我是找你来完成青年年大学习的。  \n--如果我不做青年大学习对你的工作造成了影响，那我以后会去完成的。  \n不不不，我不是强制你去完成的，如果你不想做，那你以后也可不必去做。  \n...\n\n上面一段是我与辅导员的面谈对话。我不是共青团员，自然没有完成青年大学习的义务（但显然，团员也没有），于是我便向辅导员表态我不会再进行青年大学习。在谈话之后我才得知，那一段空缺时间的学习，是辅导员替我做的，想必也是对他的工作造成了影响。我理解辅导员的工作，也不愿为他造成额外的负担。但对于为什么必须要完成青年大学习这件事情，我既理解不了，也无法接受。\n\n最近我经常能听到这样的言语：“哇！某个大学的食堂是这么的便宜，仅几块钱就能吃上如此丰盛的菜肴！”，于是周围的人便附和起来：“我们学校的饭菜价格大抵是比不上的，真希望能够考入那所大学啊！”。每当听了这样的话语，我的内心便感到难过。如果某一所学校的食堂能够以极低的价格向学生提供餐饮，我是以此为耻的。因为中国还有很多吃不上饭、吃不饱饭的人，还有很多为了生计到处奔波的人。在我们的国家，不是每一个人都能够有享受如此廉价而丰盛的食物的权利吗？还是说，是我们把他们本应得的那一份最基本、最必须的食物给剥夺了呢？\n\n---\n\n&emsp;&emsp;我绝不会为我的信仰而献身，因为我可能是错的。\n\n---\n\n<div align="right">\n\n每月评论 - 2203期(共10期)  \n撰稿&校对&审核：Thaumy\n\n</div>\n	2022-04-24 23:19:17	2022-04-24 23:17:59	2022-04-24 23:17:59	12	每月评论2203	1001
12477	# Monoid\n\n幺半群\n\n## 概要\n\n给定集合 $S$，其上有二元运算 $○$ 满足：$S○S→S$ 。若 $○$ 满足结合律，即：$∀x,y,z∈S$，有 $(x○y)○z=x○(y○z)$，则称有序对 $(S,○)$ 为半群（Semigroup）。若 $∃e∈S$ 且 $∀x∈S$，有 $x○e=e○x=x$，那么称三元组 $(S,○,e)$ 为**幺半群**（Monoid）。其中，$e$ 被称为**幺元**$^{*1}$（Identity）。\n\n可见，幺半群比半群只多了一个幺元 $e$ 。\n\n## 举例\n\n自然数集$N$和其上的运算 $+$ 和幺元 $0$ 构成的三元组 $(N,+,0)$ 是一个幺半群。  \n自然数集$N$和其上的运算 $×$ 和幺元 $1$ 构成的三元组 $(N,×,1)$ 是一个幺半群。\n\n可以想到，Monoid与Semigroup一样，是对一类代数结构的抽象。与程序设计中的 “接口” 这一概念相似。\n\n## 编程语言表述\n\nMonoid这种代数结构无处不在，现在让我们从命令式语言的角度来看看Monoid。\n\n如果用Java，那么Monoid接口长这样：\n\n```Java\ninterface Monoid<T> {\n    Monoid<T> mempty();//幺元\n    Monoid<T> mappend(Monoid<T> mb);//二元运算\n}\n```\n\n下面我们来实现一个`SumMonoid`类型，它描述了Sum的应有的特征，实质上是对Monoid$(N,+,0)$的抽象：\n\n```Java\nclass SumMonoid implements Monoid<SumMonoid> {\n\n    public Sum mempty() {\n        return new Sum() {{value = 0;}};\n    }\n    \n    public Sum mappend(Monoid<SumMonoid> mb) {\n        var ma = this;\n        return new Sum() {{value = ((Sum) ma).value + ((Sum) mb).value;}};\n    }\n}\n```\n\n有了`SumMonoid`，那么`Sum`就满足了成为`Monoid`的要求：\n\n```Java\nclass Sum extends SumMonoid {public int value;}\n```\n\n可见，`Sum`满足结合律、左幺元和右幺元：\n\n```Java\nvar S1 = new Sum() {{value = 1;}};\nvar S2 = new Sum() {{value = 2;}};\nvar S3 = new Sum() {{value = 3;}};\n\n\nvar expr1 = S1.mappend(S2.mappend(S3));//Sum value=6\nvar expr2 = S3.mappend(S1.mappend(S2));//Sum value=6\n\nvar Sum = new SumMonoid();\nvar le = Sum.mempty().mappend(S1);//Sum value=1\nvar re = S1.mappend(Sum.mempty());//Sum value=1\n```\n\n## Playground\n\n$(N,-,0)$是一个幺半群吗？为什么？\n\n### 注解\n\n1. 其中，$e○x=x$ 中的 $e$ 被称作**左幺元**（Left identity），$x○e=x$ 中的 $e$ 被称作**右幺元**（Right identity）。\n	2021-12-15 22:55:40	2021-12-15 22:55:40	2021-12-15 22:55:40	12	Monoid	1001
12470	# First-Class Function\n\n第一类函数\n\n## 概要\n\n**第一类函数**是编程语言的一种特性，它允许将函数作为变量声明、传递和返回等，就像对待普通变量一样。在第一类函数语言中，函数是头等公民，享有和其他类型一样的地位。\n\n## 用高阶函数解决问题\n\n如果你有这样一种需求：你厌烦于每次输出后都要打一个`\\n`来换行。于是你实现了这样一个函数来节省工作量（尽管貌似并没有减少多少甚至增加了）：\n\n```C\nvoid printWithWarp(char *words) {\n    printf("%s\\n", words);\n}\n```\n\n某一天你突然发现不仅是换行，你还重复着大量的句号的键入工作，于是你又写了另一个函数：\n\n```C\nvoid printWithPeriod(char *words) {\n    printf("%s.", words);\n}\n```\n\n但糟糕的是，你突然发现还需要感叹号的版本！哦天哪，你不能总是重复编写这样的函数，于是你编写了这样一个函数来替代以上所有版本：\n\n```C\nvoid printWith(char *words, char *end) {\n    printf("%s%s", words, end);\n}\n```\n\n现在你可以实现任意字符（串）的跟随输出了。\n\n需求变化的很快，现在你需要根据业务逻辑来判断需要输出什么样的结尾，显然你不能每次都在需要输出的地方嵌入一大堆`if...else...`来改善你的生活。这时候一个会宏命令的程序员跳出来，帮你改了一下代码：\n\n```C\n#define OnePeriod() \\\n({char* tempFn() {return ".";} tempFn();})//可以在tempFn内添加对业务逻辑的判断\n#define TwoPeriod() \\\n({char* tempFn() {return "..";} tempFn();})\n#define ThreePeriod() \\\n({char* tempFn() {return "...";} tempFn();})\n\n...\n\nprintWithWarp("hello!", OnePeriod());\nprintWithWarp("hello!", TwoPeriod());\nprintWithWarp("hello!", ThreePeriod());\n```\n\n现在你的代码得到了高度复用，实现了逻辑分离，这太棒了。\n\n实际上这就是高阶函数的应用，但显然用C语言写起来并不优雅，因为宏命令无论是在可读性还是在易用性方面都没有原生语言来的方便，更何况很多文本编辑器对宏命令的高亮并不是那么友好。\n\n## 函数式接口和 $λ$ 表达式\n\n以Java语言为例，我们可以使用函数式接口和 $λ$ 表达式来简化以上语法：\n\n```Java\n...\npublic static void printWith(String words, Supplier<String> end) {\n    System.out.println(words + end.get());\n}\n...\nSupplier<String> end1=()->{return "."; };\nSupplier<String> end2=()->{return "..";};\n\nprintWith("hello!",end1);\nprintWith("hello!",end2);\nprintWith("hello!",()->{return "...";});\nprintWith("hello!",()->{return "....";});\n...\n```\n\n更进一步地，我们可以将函数式接口作为数据存储在任何我们想要的数据结构中。\n\n## 第一类函数\n\n第一类函数应支持以下特征：\n\n* 函数能够作为变量传递（高阶函数）或返回（偏函数（Partial Function））\n* 函数能够存储在数据结构中\n* 能为函数指定名称\n\n显然，Java虽然拥有第一类函数的特性（尽管是后来添加的），但其实现仍不优雅，我们来看看Haskell是怎么做的：\n\n```Haskell\nonePeriod p = if p then "." else "?"\ntwoPeriod p = ".."\nthreePeriod p = "..."\n\nprintWith words end = print $ words ++ end\n\nmain = do\n  printWith "hello!" $ onePeriod True\n  printWith "hello!" $ twoPeriod False\n  printWith "hello!" $ (\\p -> if p then "..." else "???") True\n```\n\n如果按照前面的写法来写就太简单了（甚至看起来和Python没什么区别），所以我增添了一个参数来充分体现Haskell的函数式语法。\n\n## Playground\n\nNothing to play with.\n	2021-12-15 22:53:04	2021-12-15 22:53:04	2021-12-15 22:53:04	12	First-Class Function	1001
12468	# Database Normalization\n\n数据库范式化\n\n## 概要\n\n**数据库范式化**是指将数据库设计成符合数据库范式的过程。在关系型数据库中，**范式**（Normal Form）是在数据库的库表关系上的一系列规范要求。满足这类规范要求的数据库将具有更少的数据冗余，有时也可能带来潜在的效率提升或拓展性$^{*1}$。常见有六大范式，它们分别是1NF、2NF、3NF、BCNF、4NF和5NF。\n\n本文仅概要性地介绍关系型数据库中各级范式的概念及关联。\n\n## 相关概念\n\n> 以所有字段为全集 $U$。\n\n### 函数依赖\n\n函数依赖（Functional Dependency）：对于 $U$ 上的关系模式 $R(U)$，若 $X,Y⊂U$，且对于 $x∈X,y∈Y,xRy$ 中 $x$ 的每一个取值都有唯一的 $y$ 与之对应，则称 $Y$函数依赖于$X$ 或 $X$函数决定$Y$，记作 $X→Y$。\n\n平凡函数依赖（Trivial Functional Dependency）：在 $X→Y$ 的前提下，$Y⊆X$，则 $X→Y$ 是平凡的函数依赖。  \n非平凡函数依赖（Non-Trivial Functional Dependency）：在 $X→Y$ 的前提下，$Y⊊X$，则 $X→Y$ 是非平凡的函数依赖。\n\n部分函数依赖（Partial Functional Dependency）：在 $X→Y$ 的前提下，$∃S⊂X,S→Y$，则称 $Y$部分函数依赖于$X$，记作 $X\\stackrel{P}\\longrightarrow Y$。  \n完全函数依赖（Full Functional Dependency）：在 $X→Y$ 的前提下，$∀S⊂X,S\\nrightarrow Y$，则称 $Y$完全函数依赖于$X$，记作 $X\\stackrel{F}\\longrightarrow Y$。  \n传递函数依赖（Transitive Functional Dependency）：在 $X→Y,Y→Z$ 的前提下（$Z⊂U$），若 $Z⊊Y,Y⊊X,Y\\nrightarrow X$ $^{*2}$，则称 $Z$传递函数依赖于$X$，记作 $X\\stackrel{T}{\\longrightarrow}Z$。  \n\n### 字段与键$^{*3}$\n\n字段：表的某一列。  \n记录：表的某一行。  \n候选键（Candidate Key）：若 $K⊂U,K\\stackrel{F}\\longrightarrow U$，则 $K$ 为候选键。  \n主键（Primary Key）：从多个候选键中任意挑选的一个，将其作为主键。主键是候选键的真子集。  \n主字段：所有参与构成候选键的字段。  \n\n## 1NF\n\n字段不可分。\n\n下面这个表不满足1NF，因为Index字段被拆分了。\n\n<table>\n<thead><tr>\n<th colspan = "2">Index</th><th>Fruit</th><th>Price</th>\n</tr></thead>\n<tbody>\n<tr><td>1</td><td>A</td><td>Apple</td><td>5$</td></tr>\n<tr><td>2</td><td>B</td><td>Berry</td><td>6$</td></tr>\n<tr><td>3</td><td>C</td><td>Cherry</td><td>7$</td></tr>\n</tbody>\n</table>\n\n关系型数据库均满足1NF。\n\n## 2NF\n\n满足1NF，且非主字段完全函数依赖于候选键。\n\n在下表中：\n\n|   DP   | Fruit  | Price |\n| :----: | :----: | :---: |\n| Sep.30 | Apple  |  6$   |\n| Oct.6  | Apple  |  6$   |\n| Oct.6  | Berry  |  6$   |\n| Oct.6  | Cherry |  7$   |\n| Oct.7  | Cherry |  7$   |\n\n$\\rm\\{DP,Fruit\\}$ 是候选键：对于DP和Fruit构成的集合 $\\rm\\{DP,Fruit\\}$，$\\rm\\{DP,Fruit\\}$ 的任一取值均有唯一的行与之对应，且其真子集均不能成为成为候选键$^{*4}$，所以 $\\rm\\{DP,Fruit\\}⊂U,\\{DP,Fruit\\}\\stackrel{F}\\longrightarrow U$ 成立。  \nPrice是非主字段：DP与Fruit为主字段是显然的，而 $\\rm\\{DP,Price\\}$ 与 $\\rm\\{Fruit,Price\\}$ 均不能成为候选键$^{*5}$。\n\nPrice部分函数依赖于 $\\rm\\{DP,Fruit\\}$：由于 $\\rm\\{DP,Price\\}→Price$，而 $\\rm\\{Fruit\\}⊂\\{DP,Fruit\\},\\rm\\{Fruit\\}→Price$ 成立，所以 $\\rm\\{DP,Fruit\\}\\stackrel{P}\\longrightarrow Price$ 。\n\n正因为 $\\rm\\{DP,Fruit\\}\\stackrel{P}\\longrightarrow Price$，所以上表不满足2NF。\n\n下二表是对上表进行*模式分解*$^{*6}$的结果，均满足2NF。\n\n<div><div style="display: inline-block">\n\n|   DP   | Fruit  |\n| :----: | :----: |\n| Sep.30 | Apple  |\n| Oct.6  | Apple  |\n| Oct.6  | Berry  |\n| Oct.6  | Cherry |\n| Oct.7  | Cherry |\n\n</div> <div style="display: inline-block">\n\n| Fruit  | Price |\n| :----: | :---: |\n| Apple  |  6$   |\n| Berry  |  6$   |\n| Cherry |  7$   |\n\n</div></div>\n\n## 3NF\n\n满足2NF，不允许任何非主字段传递函数依赖于候选键。\n\n这是一个不满足3NF但满足2NF的表：\n\n| Index（候选键） | Fruit（非主字段） | Price（非主字段） |\n| :-------------: | :---------------: | :---------------: |\n|        1        |       Apple       |        1$         |\n|        2        |      Banana       |        2$         |\n|        3        |       Berry       |        6$         |\n|        4        |       Berry       |        6$         |\n|        5        |      Cherry       |        7$         |\n\n它存在这样的关系：\n\n$\\rm Index→Fruit→Price,Fruit\\nrightarrow Index,Price⊊Fruit⊊Index$，即传递函数依赖 $\\rm Index\\stackrel{T}{\\longrightarrow}Price$ 。\n\n经模式分解后得到满足3NF的表：\n\n<div><div style="display: inline-block">\n\n| Index | Fruit  |\n| :---: | :----: |\n|   1   | Apple  |\n|   2   | Banana |\n|   3   | Berry  |\n|   4   | Berry  |\n|   5   | Cherry |\n\n</div> <div style="display: inline-block">\n\n| Index | Price |\n| :---: | :---: |\n|   1   |  1$   |\n|   2   |  2$   |\n|   3   |  6$   |\n|   4   |  6$   |\n|   5   |  7$   |\n\n</div></div>\n\n1NF、2NF、3NF是生产环境中常见的范式级别。\n\n## BCNF（Boyce Codd Normal Form）\n\n满足3NF，不允许任何字段完全函数依赖于不能构成候选键的字段集合。\n\n| Index（候选键） | Ranking（非主字段） | Fruit（非主字段） | Price（非主字段） |\n| :-------------: | :-----------------: | :---------------: | :---------------: |\n|        1        |          A          |       Apple       |        1$         |\n|        2        |          B          |      Banana       |        2$         |\n|        3        |          C          |       Berry       |        6$         |\n|        4        |          C          |       Berry       |        6$         |\n|        5        |          D          |      Cherry       |        6$         |\n|        6        |          C          |      Cherry       |        8$         |\n\n上表中，$\\rm\\{Fruit,Price\\}\\stackrel{F}\\longrightarrow Ranking$，因而不满足BCNF。\n\n经模式分解后满足BCNF：\n\n<div><div style="display: inline-block">\n\n| Index | Ranking |\n| :---: | :-----: |\n|   1   |    A    |\n|   2   |    B    |\n|   3   |    C    |\n|   4   |    C    |\n|   5   |    D    |\n|   6   |    C    |\n\n</div> <div style="display: inline-block">\n\n| Index | Fruit  | Price |\n| :---: | :----: | :---: |\n|   1   | Apple  |  1$   |\n|   2   | Banana |  2$   |\n|   3   | Berry  |  6$   |\n|   4   | Berry  |  6$   |\n|   5   | Cherry |  6$   |\n|   6   | Cherry |  8$   |\n\n</div></div>\n\n## 4NF\n\n满足BCNF，并消除多值依赖。\n\n多值依赖（Multivalued Dependency）：对于 $X,Y,Z⊂U$，若 $(X,Y)→Z,X\\rightarrow Z,Y\\nrightarrow Z$，则称 $Z$多值依赖于$X$，记作 $X→→Z$ 。  \n平凡多值依赖：$X→→Z$ 且 $Y=Ø$ 。  \n非平凡多值依赖：$X→→Z$ 且 $Y≠Ø$ 。\n\n对于下表，**规定**水果的价格仅与Index有关而与种类无关：\n\n| Index | Fruit  | Price |\n| :---: | :----: | :---: |\n|   1   | Apple  |  1$   |\n|   2   | Banana |  2$   |\n|   3   | Berry  |  6$   |\n|   4   | Berry  |  6$   |\n|   5   | Cherry |  6$   |\n|   6   | Cherry |  8$   |\n\n则存在多值依赖 $\\rm Index→→Price$，这不满足4NF。\n\n<div><div style="display: inline-block">\n\n| Index | Price |\n| :---: | :---: |\n|   1   |  1$   |\n|   2   |  2$   |\n|   3   |  6$   |\n|   4   |  6$   |\n|   5   |  6$   |\n|   6   |  8$   |\n\n</div> <div style="display: inline-block">\n\n| Index | Fruit  |\n| :---: | :----: |\n|   1   | Apple  |\n|   2   | Banana |\n|   3   | Berry  |\n|   4   | Berry  |\n|   5   | Cherry |\n|   6   | Cherry |\n\n</div></div>\n\n现满足4NF。\n\n## 5NF\n\n满足4NF，将表拆分到最简形式。\n\n对4NF案例中的最后结果进行5NF范式化如下：\n\n<div><div style="display: inline-block">\n\n| Index | Fruit  |\n| :---: | :----: |\n|   1   | Apple  |\n|   2   | Banana |\n|   3   | Berry  |\n|   4   | Berry  |\n|   5   | Cherry |\n|   6   | Cherry |\n\n</div> <div style="display: inline-block">\n\n| Index | Price |\n| :---: | :---: |\n|   1   |  1$   |\n|   2   |  2$   |\n|   3   |  6$   |\n|   4   |  6$   |\n|   5   |  6$   |\n|   6   |  8$   |\n\n</div> <div style="display: inline-block">\n\n| Fruit  | Price |\n| :----: | :---: |\n| Apple  |  1$   |\n| Banana |  2$   |\n| Berry  |  6$   |\n| Berry  |  6$   |\n| Cherry |  6$   |\n| Cherry |  8$   |\n\n</div></div>\n\n---\n\n### 注解\n\n1. 这不是严格的（注意到用语「潜在的」），一味地追求符合范式的库表结构很可能带来严重的性能缺陷。例如满足5NF的库表设计通常会使用大量的关联查询，很显然这类开销是不必要的（通常也很少见到满足5NF设计的库表结构）。\n\n   关于二者的比较（通常情况下）：\n    |    \\     | 范式化 | 反范式化 |\n    | :------: | :----: | :------: |\n    | 更新速度 |   +    |    -     |\n    | 数据冗余 |   -    |    +     |\n    | 关联成本 |   +    |    -     |\n    | 索引利用 |   -    |    +     |\n\n2. 对于理解传递函数依赖的条件：  \n    $Z⊄Y,Y⊄X$：对于任一字段 $X$，$X→X$ 是显然的。若 $Y⊂X$，那么 $X\\stackrel{P}\\longrightarrow Y$ 更是显然的，故要求 $Z⊄Y,Y⊄X$ 以保证 $X\\stackrel{P}\\longrightarrow Z$ 不成立。  \n    $Y\\nrightarrow X$：对于 $X→Y$，若 $Y→X$，那么 $X⇔Y$ 是显然的，因而在没有 $Y→Z$ 的“传递”时， $X\\stackrel{T}\\longrightarrow Z$ 也能成立。换句话来说，如果 $X→Y,Y→X$，那么传递是冗余的，$X$和$Y$中的一者也是冗余的。某些出处可能将这种情况下的函数依赖归为“直接函数依赖”。\n3. 字段=属性，键=码。我个人认为属性和码的叫法已经过时了，在不与现代的数据库名词对应的同时也易产生混淆。\n4. 因为存在同一生产日期（Oct.6）有不同的水果，所以生产日期（DP）不能成为候选键。  \n   因为存在同一水果（Cherry）有不同的生产日期，所以水果（Fruit）不能成为候选键。  \n   因为存在同一价格（6\\$）有不同的水果，所以价格（Price）不能成为候选键。\n5. 对于 $\\rm\\{DP,Price\\}$，其反例是(Oct.6, 6\\$)。  \n   对于 $\\rm\\{Fruit,Price\\}$，其反例是(Cherry, 7$)。\n6. 将原有的关系模式拆分，这种拆分的方式具有多样性，且要求拆分不损失原有的关系（即拆分后能够恢复到原有的关系，这被称作**无损连接**）。  \n   此外，受限于篇幅和举例的简易性，本文中对于不满足2NF、3NF、BCNF、4NF的案例进行模式分解后得到的结果由于形式简单（大多数为2列），可能形似于5NF（但并非5NF），读者应注意区分。\n	2021-12-15 22:51:09	2021-12-15 22:51:09	2021-12-15 22:51:09	12	Database Normalization	1001
12463	# Church Encoding\n\n邱奇编码\n\n## 概要\n\n邱奇编码是将数据和运算符嵌入λ表达式的一种方式，它通过把数据和运算符以λ表达式的形式表示出来，消除了对符号系统中基本项的需要。\n\n## 问题引入\n\n通过阅读 $Y$ 组合子那一章节，我们了解了如何将在不为λ表达式具名$^{*1}$的前提下表示递归，让我们回顾那个阶乘函数的例子：\n\n$fac=Y\\ (λx.λf.(if\\ x > 0\\ then\\ x*f(x-1)\\ else\\ 1))$\n\n其中，$Y$ 是一个高阶函数，如果展开，将变成这样：\n\n$fac=(λf.((λx.f(x\\ x))\\ (λx.f(x\\ x))))\\ (λx.λf.(if\\ x > 0\\ then\\ x*f(x-1)\\ else\\ 1))$\n\n我们使用 $Y$ 组合子很好地解决了λ演算中递归的具名问题。  \n但如果你是一个追求完美的人，相信你会有所质疑：这个 $if$ 表达式不也是有名字的么，为什么不把它也给去除掉？  \n如果你更加严苛：为什么不把大于号和减号也给去掉？  \n更进一步地：数字也是具名的！必须要把数字去掉！\n\n邱奇编码就是为此而生的。\n\n## 邱奇数及简单运算\n\n邱奇数是邱奇编码的一部分，它采用一系列函数来表示数字，这使得数字的名称不再是必要的，像这样：\n\n$0=λf.λx.\\ x$  \n$1=λf.λx.\\ f\\ x$  \n$2=λf.λx.\\ f\\ (f\\ x)$  \n$3=λf.λx.\\ f\\ (f\\ (f\\ x))$  \n$...$  \n$n=λf.λx.\\ f^{○n}\\ x$\n\n你会质疑：我的数字变成了一大堆函数，这样还怎么算数？  \n\n显然计算这样奇怪的数字需要更加奇怪的运算符来实现，为此，建立于邱奇数上的运算符表示为作用于邱奇数的一系列函数，下面是一些简单运算符的邱奇编码表达（并不局限于此！$^{*2}$）：\n\n加法 `m+n`：$plus\\quad ≡ λm.λn.λf.λx.\\ m\\ f\\ (n\\ f\\ x)$  \n乘法 `m*n`：$mult\\ \\ \\ ≡ λm.λn.λf.\\ n\\ (m\\ f)$  \n指数 `m^n`：$exp\\quad\\ ≡ λm.λn.\\ n\\ m$  \n前驱 `n--`：$pred\\quad ≡ λn.λf.λx.\\ n\\ (λg.λh.\\ h\\ (g\\ f))\\ (λu.\\ x)\\ (λu.\\ u)$  \n减法 `m-n`：$minus\\ ≡ λm.λn.\\ n\\ pred\\ m$\n\n其中，前驱函数 $pred$ 用于计算一个数的前一个数，减法函数基于 $pred$ 实现$^{*3}$。\n\n举个栗子，让我们计算 `1+2` ：\n\n$\\quad1+2$  \n$=plus\\ 1\\ 2$  \n$=(λm.λn.λf.λx.\\ m\\ f\\ (n\\ f\\ x))\\ 1\\ 2$  \n$=(λm.λn.λf.λx.\\ m\\ f\\ (n\\ f\\ x))\\ (λf.λx.\\ f\\ x)\\ (λf.λx.\\ f\\ (f\\ x))$  \n$=λf.λx.\\ (λf.λx.\\ f\\ x)\\ f\\ ((λf.λx.\\ f\\ (f\\ x))\\ f\\ x)$  \n$=λf.λx.\\ (λf.λx.\\ f\\ x)\\ f\\ (f\\ (f\\ x))$  \n$=λf.λx.\\ f\\ (f\\ (f\\ x))$  \n$=3$\n\n呐呐呐，是不是很神奇？\n\n## 布尔值和条件分支\n\n在邱奇编码下，布尔值被形式化为：\n\n$true\\ \\ ≡λa.λb.\\ a$  \n$false≡λa.λb.\\ b$\n\n注意到 $a$ 和 $b$ 其实相当于两个计算分支，所以可以如下构造 $if$：\n\n$if=λp.λa.λb.\\ p\\ a\\ b$\n\n那么 $if\\ true\\ then\\ 1\\ else\\ 0$ 就可以表示为 $(λp.λa.λb.\\ p\\ a\\ b)\\ true\\ 1\\ 0$，对其进行 $β$ 归约可得：\n\n$\\quad(λp.λa.λb.\\ p\\ a\\ b)\\ (λa.λb.\\ a)\\ (λf.λx.\\ f\\ x)\\ (λf.λx.\\ x)$  \n$=(λa.λb.\\ a)\\ (λf.λx.\\ f\\ x)\\ (λf.λx.\\ x)$  \n$=(λf.λx.\\ f\\ x)$  \n$=1$\n\nawesome.\n\n## 改写阶乘函数\n\n要想改写我们的阶乘函数，以上的要素还不够，需额外引入以下函数：  \n\n逻辑非 `!n`：$not=λp.λa.λb.\\ p\\ b\\ a$  \n判零 `n=0`：$IsZero=λn.\\ n\\ (λx.\\ false)\\ true$  \n小于等于 `m≤n`：$LEQ=λm.λn.\\ IsZero\\ (minus\\ m\\ n)$\n\n于是我们的阶乘函数就可以被完全函数化了：\n\n$fac=Y\\ (λx.λf.(if\\ (not\\ (LEQ\\ x\\ 0))\\ (mult\\ x\\ f(x-1))\\ 1))$\n\n完全展开可得：\n\n$fac=(λf.((λx.f(x\\ x))\\ (λx.f(x\\ x))))\\ (λx.λf.((λp.λa.λb.\\ p\\ a\\ b)\\ ((λp.λa.λb.\\ p\\ b\\ a)\\ \\\\((λm.λn.\\ (λn.\\ n\\ (λx.\\ false)\\ (λa.λb.\\ a))\\ ((λm.λn.\\ n\\ (λn.λf.λx.\\ n\\ (λg.λh.\\ h\\ (g\\ f))\\ \\\\(λu.\\ x)\\ (λu.\\ u))\\ m)\\ m\\ n))\\ x\\ (λf.λx.\\ x)))\\ ((λm.λn.λf.\\ n\\ (m\\ f))\\ x\\ f((λm.λn.\\ n\\ \\\\(λn.λf.λx.\\ n\\ (λg.λh.\\ h\\ (g\\ f))\\ (λu.\\ x)\\ (λu.\\ u))\\ m)\\ x\\ (λf.λx.\\ f\\ x)))\\ (λf.λx.\\ f\\ x)))$\n\n太神奇了，这居然完全不可读（逃\n\n## Playground\n\n尝试计算 `1+1` （使用邱奇编码！）\n\n---\n\n### 注解\n\n1. 具名，即给λ表达式命名，如：$miao=λx.x+1$  \n2. 除法函式的表达较为复杂，不列。\n3. 在邱奇编码中，$pred\\ 0=0$，$m<n→m-n=0$	2021-12-15 22:49:11	2021-12-15 22:49:11	2021-12-15 22:49:11	12	ChurchE	1001
12441	_(:з」∠)_init2021	2021-01-01 00:00:00	2021-01-01 00:00:00	2021-01-01 00:00:00	12		1001
12432	现已升级至 WaterLibrary 1.16.5 内核，版本代号"性能革命"	2020-10-15 07:06:41	2020-10-15 07:07:35	2020-10-15 07:07:35	28		1001
12457	# WMU - C210607\n\nComputation Theory Intro\n\n曾经更新于水瓜大学的课程，继续搬到博客来写。\n\n归档目录：\n\n[Algebraic Data Type](https://www.thaumy.cn/12460)  \n[Applicative Functor](https://www.thaumy.cn/12461)  \n[Bloom Filter](https://www.thaumy.cn/12458)  \n[Curry-Howard Correspondence](https://www.thaumy.cn/12462)  \n[Church Encoding](https://www.thaumy.cn/12463)  \n[Calculus of Constructions](https://www.thaumy.cn/12464)  \n[Combinatory Logic](https://www.thaumy.cn/12465)  \n[Continuation Passing Style](https://www.thaumy.cn/12466)  \n[Currying](https://www.thaumy.cn/12467)  \n[Database Normalization](https://www.thaumy.cn/12468)  \n[Dependent Type](https://www.thaumy.cn/12469)  \n[First-Class Function](https://www.thaumy.cn/12470)  \n[Functor](https://www.thaumy.cn/12471)  \n[Generalised Algebraic Data Type](https://www.thaumy.cn/12472)  \n[Higher-Kinded Type](https://www.thaumy.cn/12473)  \n[Higher-Order Function](https://www.thaumy.cn/12474)  \n[λ - Calculus](https://www.thaumy.cn/12475)  \n[Monad](https://www.thaumy.cn/12476)  \n[Monoid](https://www.thaumy.cn/12477)  \n[Polish Notation](https://www.thaumy.cn/12478)  \n[Pure Function](https://www.thaumy.cn/12479)  \n[Reverse Polish Notation](https://www.thaumy.cn/12480)  \n[Semigroup](https://www.thaumy.cn/12481)  \n[Side Effect](https://www.thaumy.cn/12482)  \n[Simply Typed Lambda Calculus](https://www.thaumy.cn/12459)  \n[Subtyping](https://www.thaumy.cn/12483)  \n[System F](https://www.thaumy.cn/12484)  \n[Type Constructor](https://www.thaumy.cn/12485)  \n[Type Inference](https://www.thaumy.cn/12486)  \n[Type Safety](https://www.thaumy.cn/12487)  \n[Y Combinator](https://www.thaumy.cn/12488)  \n	2021-12-15 22:41:30	2021-12-15 22:42:15	2021-12-15 22:42:15	12	《瓜大计算导论》系列	1001
12402	<span style="float:right;" class="wd-dt5 cur" onclick="up();showPost(12376)">点此返回索引根目录</span>\n\n## pilipala 1810BETA5 维护日志\n\n<blockquote>注意，此日志在时间戳上存在统计遗漏，现有的时间记录是结合多方面数据分析得出的，可能与实际不符。</blockquote>\n\n<span class="mk-dt">18.10‎.21<span class="mk-mtn"></span></span>pilipala_BETA5现已部署至 www.thaumy.cn  \n<span class="mk-dt">18.10‎.‎21‎<span class="mk-w"></span></span>新增菜单“pilipala计划”  \n<span class="mk-dt">18.10.‎21‎<span class="mk-w"></span></span>上传 StdLib1.12"REALUNATYPE&RETURNV"宣传图 作为置顶文章图片\n\n### <span class="mk-dt">18.10‎.21‎<span class="mk-updt"></span></span>内核概要  \n* 后台代码进一步优化，简化了站点的云部署流程\n* 将代码整合分类，使得webio清晰明了\n* 使用stdlib1.12进行建构，提供优于1.11版本的逻辑架构和运行效率\n* 新增pala root与pala user支持，用以操作啪啦元数据和用户数据\n* 修改了部分注释和名称，现版本逻辑的构建优于历史最高\n* 进一步规范palaDB命名\n\n## pilipala 1809BETA4 维护日志\n\n‎<span class="mk-dt">18.09.‎24<span class="mk-mtn"></span></span>中秋节：pilipala_BETA4现已部署至 www.thaumy.cn （有史以来bug最多的pilipala）\n\n### ‎<span class="mk-dt">18.9.‎24<span class="mk-updt"></span></span>交互\n* 上传 StdLib1.11"HeavenlyBlue"宣传图 作为置顶文章图片\n* 增加对手机浏览器的支持，仅限于iphone5/se，并且bug非常非常多\n* 该版本表现层（pilipala主题）拥有众多bug，不予统计\n\n### ‎<span class="mk-dt">18.09.‎24<span class="mk-updt"></span></span>内核概要\n* 采用ASP.NET预编译技术，网站启动时间缩小到原来的20%，并且更加安全\n* 采用全新HeavenlyBlue架构的StdLib1.11核心（正式版内核），底层效率进一步提升，且带来更多函数支持\n* 使用pala文章数据分表技术，增强了原数据的安全性\n* 网站底部加载按钮现启用，在以后文章较多时可有效提升网页速度，减少流量\n* 使用母版页和内容页架构网页表现层，减小耦合以便利开发\n\n<span class="mk-dt">18.09.‎24<span class="mk-bug"></span></span>pala文章数据分表技术降低了性能，复杂了架构逻辑，且向后兼容性极差\n\n## pilipala 1808BETA3 维护日志\n\n‎<span class="mk-dt">18.08.‎27<span class="mk-mtn"></span></span>pilipala BETA3现已部署至 asp.thaumy.cn （该版本为高二第一学期开学前的最后一次更新）\n\n### ‎<span class="mk-dt">18.08.‎27<span class="mk-updt"></span></span>交互\n* pilipala主题样式更改，合理布局使得网页体验更佳‎\n* 文章条带在文章页可用\n* 文章页随机文章按钮现可用\n* 文章页支持按钮现已采用AJAX无刷新更新技术，解决页面在点赞后跳动问题\n* 修复了文章页文章创建时间显示成修改时间的问题\n* 支持计数和阅读计数的cookie现设置为10秒清空，方便开发调试和寻找问题  \n  \n### <span class="mk-dt">18.08.‎27<span class="mk-updt"></span></span>内核概要\n* 阅读计数和点赞计数逻辑大幅优化，较beta2性能提升并且使得维护更加方便\n* stdlib内核新增参数化查询功能，可有效避免sql注入式攻击（虽然目前博客无任何sql注入安全问题）\n* 使用存储过程，提高执行效率\n* 内核和网页IO桥的部分代码逻辑优化并规范命名，便利后期维护\n\n## pilipala 1808BETA2 维护日志\n\n### ‎<span class="mk-dt">18.08.‎27<span class="mk-mtn"></span></span>入网维护\n* 噼里啪啦beta2已入网：asp.thaumy.cn\n* php版本博客地址更改：php.thaumy.cn\n* 开发者预览版博客地址：asp.thaumy.cn\n* 由于开发调试，www版博客暂不可用\n\n### ‎<span class="mk-dt">18.08.‎27<span class="mk-updt"></span></span>交互\n* 支持计数可用\n* 支持按钮可用\n* 浏览计数可用\n* 文章显示由创建日期从新到旧依次排列\n* 兼容手机浏览器（仅可读的兼容，这意味着交互体验极差），排版不会散架了\n\n### ‎<span class="mk-dt">18.08.‎27<span class="mk-updt"></span></span>内核概要\n* 使用全新的StdLib1.11内核alpha2（先行测试内核）\n* 数据库改为视图查询，维护更加便捷\n* 内核代码命名规范以及逻辑优化\n* 增加浏览器cookies支持，用以验证客户端\n* “网页IO协处理桥”功能更加专一\n\n## pilipala 1808BETA1 维护日志\n\n‎<span class="mk-dt">18.08.‎22<span class="mk-w"></span></span>上传了pilipala的第一个宣传图  \n‎<span class="mk-dt">18.08.‎22<span class="mk-mtn"></span></span>1808BETA1a2入网，该版本优化删除了400行代码，优化了运行速度  \n‎<span class="mk-dt">18.08.‎19<span class="mk-mtn"></span></span>1808BETA1a0现已部署至 www.thaumy.cn （其码量在3200行左右）  \n‎<span class="mk-dt">18.08.‎19<span class="mk-mtn"></span></span>该版本开发完成  \n‎<span class="mk-dt">18.08.‎19<span class="mk-updt"></span></span>相较于Press版本博客的添加了置顶文章功能（另建数据库存储）  \n‎<span class="mk-dt">18.08.‎19<span class="mk-mtn"></span></span>博客数据库构建完成  \n‎<span class="mk-dt">18.08.‎19<span class="mk-updt"></span></span>博客主题已载入博客项目  \n‎<span class="mk-dt">18.08.‎19<span class="mk-mtn"></span></span>使用MUSE建立了第一版pilipala主题  \n‎<span class="mk-dt">18.08.‎18<span class="mk-mtn"></span></span>新的pilipala主题进入开发  \n‎<span class="mk-dt">18.08.‎17<span class="mk-mtn"></span></span>该版本进入开发流程，基于StdLib1.11（先行测试内核）  \n‎<span class="mk-dt">18.08.‎18±1<span class="mk-mtn"></span></span>博客数据库系统开始重构，仍然采用上一代存储策略\n\n## pilipala 1808ALPbHA3 维护日志\n\n‎<span class="mk-dt">18.08.‎16<span class="mk-mtn"></span></span>因为项目代码和管理不佳，该版本博客没有入网  \n‎<span class="mk-dt">18.08.‎16<span class="mk-mtn"></span></span>该项目开发终止  \n‎<span class="mk-dt">18.08.‎16<span class="mk-updt"></span></span>博客主题已载入博客项目  \n‎<span class="mk-dt">18.08.‎16<span class="mk-mtn"></span></span>使用MUSE建立的较完善的博客主题完成  \n‎<span class="mk-dt">18.08.‎13<span class="mk-mtn"></span></span>基于StdLib1.11的博客进入开发流程  \n‎<span class="mk-dt">18.08.‎13<span class="mk-updt"></span></span>基于MYSQL的博客数据库系统建立，该数据库使用用户表和文章表分开存储的策略\n\n## pilipala WSB（ALPHA2） 维护日志\n\n‎<span class="mk-dt">18.07.‎23<span class="mk-mtn"></span></span>该版本博客入网  \n‎<span class="mk-dt">18.06‎.‎10<span class="mk-updt"></span></span>建立使用MUSE导出的简单博客页，参考Personal主题设计  \n‎<span class="mk-dt">18.06‎.‎10<span class="mk-updt"></span></span>基于StdLib1.09的博客（此后以数据库数据输出）建立  \n‎<span class="mk-dt">18.06‎.‎10<span class="mk-updt"></span></span>基于MYSQL的博客数据库系统建立\n\n## pilipala StBlog（ALPHA1） 维护日志\n\n<span class="mk-dt">18.02‎.‎10<span class="mk-updt"></span></span>一个仅可以输出本地文本的简陋博客例程建立	2019-11-02 19:09:32	2019-11-24 19:09:46	2019-11-24 19:09:46	12	PB5-1维护日志	1001
12472	# Generalised Algebraic Data Type\n\n广义代数数据类型\n\n## 概要\n\n**广义代数数据类型**（又称一般化的代数数据类型）是ADT的增强版本，它允许在ADT的基础上通过为**值构造器**$^{*1}$（Value constructor或Data constructor）提供更加丰富的类型信息来完善类型约束，下文简称GADT。\n\n## 介绍\n\n虽然ADT具有易于使用和类型安全等一系列优异特性，但它仍然存在一定不足，考虑以下代码：\n\n```Haskell\ndata Expr\n  = BoolVal Bool\n  | IntVal Int\n  | Sum Expr Expr\n  | Equal Expr Expr\n```\n\n上述代码构造了一个表达式类型`Expr`，其含有代表Bool类型表达式的值构造器`BoolVal`和代表Int类型表达式的值构造器`IntVal`，以及分别代表求和表达式和判等表达式的`Sum`和`Equal`。\n\n我们可以很容易的实现对以上`Expr`的解析，这在构建DSL$^{*2}$时很有用：\n\n```Haskell\neval :: Expr -> Either Bool Int\neval (BoolVal b) = Left b\neval (IntVal i) = Right i\neval (Add e1 e2) =\n  case eval e1 of\n    Right i1 -> case eval e2 of Right i2 -> Right (i1 + i2)\neval (Equal e1 e2) =\n  case eval e1 of\n    Left b1 -> case eval e2 of Left b2 -> Left (b1 == b2)\n    Right i1 -> case eval e2 of Right i2 -> Left (i1 == i2)\n```\n\n受限于篇幅和可读性缘故，此处的`eval`是一个非穷尽（non-exhaustive）的模式匹配。由于`Sum`和`Equal`有很多种模式需要考虑，为其编写的冗余代码不但无助于逻辑本身，反而去掉会使得程序不安全：\n\n```Haskell\nfoo = eval (Add (IntVal 1) (BoolVal False)) -- “合法的滥用”\n```\n\n如果对ADT加以约束，那么上面所述的一些问题则不会发生，这就是GADT：\n\n```Haskell\ndata Expr a where\n  BoolVal :: Bool -> Expr Bool\n  IntVal :: Int -> Expr Int\n  Add :: (Expr Int) -> (Expr Int) -> Expr Int\n  Equal :: (Expr a) -> (Expr a) -> Expr Bool\n\neval :: Expr a -> Either Bool Int\neval (BoolVal b) = Left b\neval (IntVal i) = Right i\neval (Add (IntVal i1) (IntVal i2)) = Right (i1 + i2)\neval (Equal (BoolVal b1) (BoolVal b2)) = Left (b1 == b2)\neval (Equal (IntVal i1) (IntVal i2)) = Left (i1 == i2)\n```\n\n可以看到通过使用GADT，我们不需要考虑那些滥用情况下的模式，因为它们都被GADT约束掉了。这大大减少了代码冗余，也更可读$^{*3}$。同时，我们在类型层面为`eval`带来了类型安全性，而不是手工地去写全所有情况的匹配。\n\n## Playground\n\n没作业。\n\n---\n\n### 注解\n\n1. 值构造器是类型构造器的一部分，如有以下类型：\n\n   ```Haskell\n    data Type a = Foo a | Bar a | Baz\n   ```\n\n   `Foo`、`Bar`和`Baz`都是值构造器，更由于`Baz`无类型参数，故被称作空的值构造器（Nullary data constructor）或常量（Constant）。\n\n2. 领域特定语言（Domain Sepcific Language，DSL），如HTML、SQL等。\n3. 对于可读性的讨论，这里其实并不严谨，因为两个例子使用了不同的模式匹配方式。但基于可读性和代码量成负相关的事实，我姑且认为这样的表述还算可用。\n	2021-12-15 22:53:48	2021-12-15 22:53:48	2021-12-15 22:53:48	12	GADT	1001
12410	\n# awesome！\n\n<img style="width:30%;float:left;margin-right:10px;" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/moment.jpg">\n\n这是我独享的moment。  \n（运用自如）  \n\n&emsp;&emsp;实在是不知道如何写这篇评测，我删了又改改了又删。  \n那么就随便写写算了。。。。随性一点。  \n\n&emsp;&emsp;这块本子大概已经用了三个周了吧，本来想着一到手就评测一下的，实在是太忙，所以决定体验一段时间再写。  \n\n---\n\n因为我又热又笨的FX8300已经不能满足我对便携开发的热衷追求，我觉得是时候购买一台笔记本电脑了。\n\n## 需求\n\n* 续航\n\n&emsp;&emsp;考虑到尽可能的使用时长，我需要更大的电池和低功耗的处理器（桌面级标压处理器虽然性能可观，但是续航实在不敢恭维）。由于低压i5拥有更好的功耗控制，体制上在解锁TDP限制后与低压i7没有较大差距，价格又便宜那么几百块，所以买i5呗~~~嘛，理性一点。  \n\n* 存储器\n\n&emsp;&emsp;在内存方面，考虑到将来入坑剪辑和虚拟机的学习，所以我至少需要16G的运行内存，这可以让我拥有更多的任务挂载于系统。  \n\n硬盘到无所谓，除了某果，都可自行添加，512G是我的理想选择，当然1T更好（多存点垃圾，滑稽）。  \n\n* 显示效能\n\n&emsp;&emsp;由于经常进行网页设计和作图，我在上半年购置了一台三星SpaceMonitor作为主显示器（100%sRGB）应对色彩差异问题。所以笔电上的色彩需求就不在我的考虑范围内，原则上90%sRGB的屏幕我都可以接受。  \n\n* 拓展性\n\n&emsp;&emsp;雷电3接口提供了高达40Gbps的传输速率（约5G每秒），极高的带宽甚至允许它能外接显卡进行图形处理（玩游戏2333）。无论机身携带多少接口，相信雷电3都是必备的。  \n\n#### 大概就这些。\n\n---\n\n为什么我选择了YOGA？在18-19年的笔电市场中，大多数笔电都存在某方面的短板，符合要求的款式大概也就戴尔的XPS和苹果的MBP了（价格甚高，买得起也修不起呀）。。。小米和联想的小新我曾经觉得比较理想，二者都有很高的拓展性和可观的性价比。\n\n到了2019年9月，联想发布了YOGA的新系列。\n\nC940满足以上全部需求，并且还多了块90%色域的触控屏和压感笔，没有过万（这是重点）。  \n\n---\n\n#### 下面来聊一聊这个本子\n\n> &emsp;&emsp;YOGA C940延续了YOGA系列一贯的商务风格。它的机身为金属材质，并在此基础上采用了CNC工艺与喷砂处理，机身线条硬朗，手感细腻，高端范十足。（懒得写，引用自环球网）\n\n&emsp;\n\n<img style="width:70%" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/A面.jpg">\n\nA面大方气派，YOGA字样由CNC镂刻嵌入。\n\n<img style="width:50%" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/fold (4).jpg"><img style="width:50%" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/fold (2).jpg"><img style="width:50%" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/fold (1).jpg"><img style="width:50%" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/fold (3).jpg">\n\n显示屏360度可折叠，帐篷模式平板模式，玩法多多，想怎么放就怎么放。\n\n<img style="width:100%" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/paint.jpg">\n\n4096级压感触控笔，搭配4K电磁屏，这就是块数位板。  \n\n*数位笔采用EDLC超级电容，理论上可实现无限次充放电，无需担心寿命问题。*\n\n<img style="width:50%" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/shaft.jpg"><img style="width:50%" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/dolby.jpg">\n\n同步转轴是这个本子的一大亮点，保证了音源始终面向用户，杜比音效，awesome。\n\n<img style="width:50%" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/interface.jpg"><img style="width:50%" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/fingerprint.jpg">\n\n两个雷电三接口和一个type-A接口，反应迅速的指纹识别模块。\n\n<img style="width:70%" src="https://cdn.thaumy.cn/md-img/YOGA C940 使用体验/keybo.jpg">\n\n联想的键盘一向都不错，敲起来舒服到我甚至让把我的樱桃茶扔了。可能是来自于ThinkPad的技术积累吧。\n\n<blockquote>\n&emsp;&emsp;作为联想推出的一款10nm旗舰翻转本，YOGAC940无疑是非常成功的。无论是独特的外观与豪华的硬件配置还是实用的功能与贴心的细节设计，都达到了对手所无法企及的高度。与此同时，它还有着出色的性能表现与相对亲民的价格。如果你刚好需要一款轻薄本，那么不妨考虑一下这款综合实力出色的YOGA C940。（引用自环球网）\n</blockquote>\n\n其实不仅有14寸版本，还有15寸版本的c940。  \n15寸版本虽然拥有更强的性能（1650显卡与标压处理器），但是其续航和屏幕素质与14有较大差距。没有100%sRGB的屏幕作为绘画本显然不是理想选择。  \n适合自己的才是最好的。\n\n<br>\n\n<p align="right">此文章使用 YOGA C940 编辑完成。</p>	2020-01-10 21:42:34	2020-01-10 21:42:39	2020-01-10 21:42:39	12	YOGA C940 使用体验	1001
12481	# Semigroup\n\n半群\n\n## 概要\n\n给定集合 $S$，其上有二元运算 $○$ 满足：$S○S→S$ $^{*1}$。若 $○$ 满足结合律，即：$∀x,y,z∈S$，有 $(x○y)○z=x○(y○z)$，则称有序对 $(S,○)$ 为半群，运算 $○$ 称为该半群的乘法。实际使用中，在上下文明确的情况下，可以简述为“半群$S$”。\n\n## Samples\n\n对于自然数集 $N$：\n\n$N$ 和其上的运算 $+$ 构成的有序对 $(N,+)$ 是一个半群。  \n\n$N$ 和其上的运算 $-$ 构成的有序对 $(N,-)$ 不是一个半群，因为 $∃x,y,z∈N\\ \\ (x-y)-z≠x-(y-z)$，且 $∃x,y∈N\\ \\ ¬(N-N→N)$ 。\n\n## Playground\n\n$(N,×)$是一个半群吗？为什么？\n\n---\n\n### 注解\n\n1. $S○S→S$ 表示任意两个集合 $S$ 内的元素按照二元运算符 $○$ 所规定的规则运算，并且运算结果仍属于集合 $S$ 。这种特性被称为运算 $○$ 的封闭性，即 $S$ 对 $○$ 封闭。\n	2021-12-15 22:56:54	2021-12-15 22:56:54	2021-12-15 22:56:54	12	Semigroup	1001
12440	# 每月评论\n\n> 每月评论的第二期\n\n* 每一刊每月评论将在当月的月末发行，同时也会伴随博客的版本更新。\n\n## 进击的巨人 - 最终季\n\nAttack on titan - Final Season\n\n> ~~啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊，莱纳！！！！！~~\n\n<img style="width:100%;" src="https://cdn.thaumy.cn/md-img/每月评论/2012/我已经受够墙壁了.jpg"><div style="width:100%;text-align:center">~~墙之巨人~~</div>\n\n&emsp;&emsp;要说这个月有什么最令人兴奋的事情，那必须是巨人更新了！  \n&emsp;&emsp;这一次制作组改为了MAPPA，画风和前几部大同小异。给我最直观的感受是人物面部的线条没有以前厚实了，并且画风也具有了一种很“现实”的感觉（我也不知道是不是剧情衬托的......）。  \n\n<img width="33.3%" src="https://cdn.thaumy.cn/md-img/每月评论/2012/OP.jpg"><img width="33.3%" src="https://cdn.thaumy.cn/md-img/每月评论/2012/飞走吧.jpg"><img width="33.3%" src="https://cdn.thaumy.cn/md-img/每月评论/2012/莱纳.jpg">\n\n&emsp;&emsp;配乐仍然是泽野弘之大佬，但OP和ED的风格相较于前几季的区别比较大。刚开始听OP感觉风格很疯癫，但是看过了一两集之后就觉得风格完全不一样了，和ED一样，都让我感觉有一种浓重的“现实”感。  \n\n<img width="50%" src="https://cdn.thaumy.cn/md-img/每月评论/2012/是啊.jpg"><img width="50%" src="https://cdn.thaumy.cn/md-img/每月评论/2012/阿尼.jpg"><div style="width:100%;text-align:center">莱纳和阿尼</div>\n\n&emsp;&emsp;本季的重点不再是人和巨人之间的故事，而变成了马莱和艾尔迪亚的故事。前作很多的铺垫也在本季揭露出来，故事的各个方面都体现出了更深刻的认知。\n> 白骨终将化为沙土，却生生不息。\n\n## <img width="100px" style="box-shadow:none;" src="https://cdn.thaumy.cn/md-img/每月评论/2012/水瓜大学kimomimi512.png"><span style="line-height:50px">水瓜大学</span>\n\n> 群号：1164772054\n\n&emsp;&emsp;这是水瓜社开办的一个新团体。  \n&emsp;&emsp;介于水瓜社特殊的集体性质，已经不打算招收新的成员了（从创立到现在仍然只有三个人......<img height="30px" src="https://cdn.thaumy.cn/表情包/melonBoy.jpg">。于是我们打算开设一个新的组织。受到聊天上下文的启发和影响，它被命名为“水瓜大学”。  \n&emsp;&emsp;和大家所想的都不同，水瓜大学并不是一个学术团体，也不是一个有各种分工的组织。水瓜大学的成立初衷是弥补水瓜社过于严苛的加盟条件带来的不足，它致力于建立一个开放包容的社交网络。我们希望水瓜大学能成为一个真正的权力平等、无所不聊的团体，以更好的丰富大家的摸鱼体验（?  \n&emsp;&emsp;水瓜社目前由机器人小品（Pinn）管理，并施行渐进式招生制度。\n\n> ~~附件1:原logo<img width="60px" style="box-shadow:none;" src="https://cdn.thaumy.cn/md-img/每月评论/2012/水瓜大学.png">这logo谁设计的啊~可真够丑的...~~\n\n## 噼里啪啦的转折点\n\n<img width="100%" src="https://cdn.thaumy.cn/md-img/每月评论/2012/PILIPALA_beta8.jpg">\n\n> 要去创造更多东西。\n\n&emsp;&emsp;截至本文发布，噼里啪啦BETA8已经为我的博客服务了接近四个月。  \n&emsp;&emsp;本月噼里啪啦迁移到了Linux环境下，我也借此体验了一&period;net core带来的便利和C#9.0的诸多新特性，此前受限于虚拟主机的一系列不便也得到了完全释放。新增的用户系统和后台让噼里啪啦在不同用户下的迁移变得更加方便了。  \n<img width="100%" src="https://cdn.thaumy.cn/md-img/每月评论/2012/post_list_user.jpg"><div style="width:100%;text-align:center">叽里咕噜后台</div>\n\n&emsp;&emsp;但是，介于个人精力的有限和技术上的门槛，噼里啪啦的开发工作变得越发缓慢了：我需要一个技术大爆炸。噼里啪啦已经非常完善（可能还缺失一个插件系统吧），所以以后工作的侧重点将从该项目转移。这并不意味着噼里啪啦项目会被遗弃掉，在接下来的很长一段时间里，将有更多有价值的东西添加到噼里啪啦中。\n\n---\n\n### 版权信息\n\n麦哲伦同人配图pixiv：80600690\n\n---\n\n<div align="right">\n\n每月评论 - 2012期(共2期)  \n撰稿&校对&审核：Thaumy\n\n</div>\n	2020-12-30 12:42:09	2021-01-10 16:00:40	2021-01-10 16:00:40	12	每月评论2012	1001
12467	# Currying\n\n## 概要\n\n柯里化（Currying），是一种将多参数函数转换为单参数函数的方法。\n\n## 介绍\n\n考虑二参数函数：$f(x,y)=x+y$  \n该函数接收两个参数并计算它们的和。  \n\n在柯里化中，该函数可被改写为 $f(x)=[f(y)=x+y]$，函数$f(x)$是一个*偏函数*$^{^*1}$。由此，函数应用 $f(1,2)$ 可被改写为 $[f(1)](2)$ 。  \n\n中括号在这里也是为了便于理解而添加的，实际上函数应用的最简形式为 $f(1)(2)$\n\n不难发现，$f(1)$ 返回一个函数 $f(y)$，该函数 $f(y)$ 将作用于参数 $2$ 上，进而返回 $x+y$ 的值，即为$3$。\n\n注意到函数 $f(y)$ 在本质上是一个**闭包**$^{^*2}$。\n\n## Playground\n\n给定函数：$f(x)=\\{f(y)=[f(z)=x+y-z]\\}$  \n尝试计算$f(3)(2)(5)$的值\n\n---\n\n### 注解\n\n1. 偏函数（Partial Function）：返回函数的函数  \n2. 使用自由变量的函数被称作**闭包**（Closure）。如：给定自由变量$a=3$，规定$f(x)=a+x$，那么$f(x)$就是一个闭包。\n	2021-12-15 22:50:46	2021-12-15 22:50:46	2021-12-15 22:50:46	12	Currying	1001
12446	# 每月评论\n\n> 每月评论 - 第四期\n\n* 每一刊每月评论将在当月的月末发行，同时也会伴随博客的版本更新。\n\n---\n\n## 开开心心过DA♂RK年！\n\n水瓜社和水瓜大学全体成员在此祝大家，牛年快乐！\n<center><img style="width:40%;min-width:300px" src="https://cdn.thaumy.cn/md-img/每月评论/2102/redbag.gif"><div></center>\n<img style="width:140px;" src="https://cdn.thaumy.cn/md-img/每月评论/2102/needredbag.jpg"><div>\n\n## 国际空间站通联监听\n\n> 本月5日，国际空间站和俄罗斯海参崴在北京时间16:30左右于145.800Mhz频段进行通联。\n\n&emsp;&emsp;海参崴和我威海的地理位置貌似不会成为无线电监听的障碍，适逢水瓜社的jss和soulster都有手台，于是我们赶往海边监听。一开车门就接收到了信号，以下是抄收到的信息：\n\n<img style="width:33.3%;float:left" src="https://cdn.thaumy.cn/md-img/每月评论/2102/ham1.jpg"><img style="width:33.3%;float:left" src="https://cdn.thaumy.cn/md-img/每月评论/2102/ham2.jpg"><img style="width:33.3%;float:left" src="https://cdn.thaumy.cn/md-img/每月评论/2102/ham3.jpg">\n<center>设备：宝峰UV5R&老鹰771天线</center>\n\n<br>\n\n## 黄金矿工\n\n<img style="width:100%;float:left" src="https://cdn.thaumy.cn/md-img/每月评论/2102/btc.jpg"><div style="width:100%;text-align:center">数据来自币安</div>\n\n&emsp;&emsp;随着去年中旬比特币区块奖励减半，比特币市值可谓一路上涨，从8千刀直接飙到5万刀，并在本月22日凌晨达到58352.80美元/个，半年涨幅竟然高达600%。  \n&emsp;&emsp;好景不长，三日内BTC跌至4w6，24小时内37万人爆仓，炒币风险仍不可忽视。  \n&emsp;&emsp;虽然有一定风险，但我觉得数字货币仍有很好的前景，在面临政治压力之前仍有很大的增值空间。我认为在个人能够接受的亏损范围内投资区块链仍是不错的理财选择，于是我也开始挖矿了（甚至我的树莓树莓派也在挖矿！），奈何个人算力有限，每日收益只能勉强抵去电费，但让设备闲着未尝不是一种亏损。在这个国家信用货币持续增发的年代，钱越来越不值钱了，我很看好BTC的经济模式。  \n\n&emsp;&emsp;另外，本博客现在支持<a href="/12385">数字货币赞助</a>啦。\n\n## .NET6发布啦~！\n\n&emsp;&emsp;本月中旬，.NET6 preview1发布啦！  \n&emsp;&emsp;在众多新特性中，最令我兴奋的就是Blazor的跨平台开发和C#热重载调试。前者能很好的解决我目前在Electron移植上的性能问题，又能充分利用前端布局完成UI设计，后者能很大程度上提升C#的调试效率（虽然结合VS的调试效率本来就很好）。向来微软的工作流带给我的印象都是整齐划一且十分严谨的（Windows系统除外），我衷心希望微软能做好.NET平台的生态。  \n\n（暴击）不过话又说回来，C#你这垃圾语言什么时候支持  \n\n``` 吐槽\n更复杂的条件模式匹配 //switch模式匹配只能匹配常量，并且满足条件的行为只允许写一行\n基于密封类的和类型 //C#不允许在密封类内部声明子类\n扩展方法的静态调用 //C#的扩展方法只能在实例上被调用，这对静态工厂模式的设计很不友好\n原生单例模式 //没错，kotlin有的我也要！\n常用控制语句的表达式化、更好的常量声明 //减少副作用，另外我不喜欢在每个变量前都加个const\n无需句末分号 //加分号太啰嗦了，虽然我不指望它能实现这个\n```\n\n但我还是知道，C#的有些包袱太重了，和新兴的多范式语言较量还是很乏力的。  \n\n## Flag完成度清单\n\n在一月评论里面我写下了一些寒假计划，现评估它的完成度。\n\n|         项目列表         | 进度  |\n| :----------------------: | :---: |\n|    至少读完两本箱底书    |  80%  |\n| 三体第三部看完前三分之一 |  60%  |\n|    新头像绘制(设定陆)    |  0%   |\n|     每天都要写代码！     | 100%  |\n|         补番3部          | 100%  |\n\n&emsp;&emsp;这可能是我度过的最充实的假期了。  \n&emsp;&emsp;我几乎没有把时间浪费在游戏上（几乎！我在假期的前10天是有接触游戏的），在剩余的时间里我读了大概400余页书籍，娱乐方式是看番和聊天。注意到我的学习是有偏好的，相较于大学里的基础学科（如英语、数学或物理），我更倾向于计算机类的东西。即便如此，我仍秉持基于兴趣爱好的目标驱动，鲜有考虑求职需要或是学历提升方面的东西，因此我并不为自己在上述行为中感到有什么努力感。是的，我只是在此向你介绍我如何消遣我的假期时光。\n\n---\n\n&emsp;&emsp;其实这个月够无聊的，本来打算把这期评论咕一咕的，但终究觉得要写些什么。  \n&emsp;&emsp;原本想发些技术类文章的，可是我越读书越感觉自己还差得远，可能写出来也很快会被未来的自己当作垃圾文章来看了，于是就不去写罢。\n\n---\n\n<div align="right">\n\n每月评论 - 2102期(共4期)  \n撰稿&校对&审核：Thaumy\n\n</div>\n	2021-03-04 14:48:26	2021-03-04 14:47:13	2021-03-04 14:47:13	12	每月评论2102	1001
12455	# 每月评论\n\n> 每月评论 - 第七期\n\n* 受限于各类因素，每月评论将按需发行。\n\n---\n\n## RE:苹果发布会\n\n&emsp;&emsp;本月19日凌晨一点，苹果召开了第二场秋季新品发布会。发布了airpods3、更多颜色的Homepod mini，以及......我期待已久的MacBook Pro!!!  \n&emsp;&emsp;从去年开始我就十分期待苹果的新款MBP，熬过了M1、iPad、iMac、iPhone后，它终于发布了。这次的配置真的是十分强悍，看发布会的时候的我真的是被各种震惊。......抛开性能，这次的外观真的是一言难尽啊，这还是世界上第一款刘海屏笔记本吧（居然没有Face ID，这很差劲），观感上还变厚了。  \n&emsp;&emsp;但是我莫得选择。随着经验的不断积累，已经受够Windows上糟糕的开发体验的我越发地感受到Windows系统对开发的不友好，可我又不能把Linux作为日常生活使用的系统。无论如何，我都迫切需要macOS（它遵循单一UNIX规范，并且在交互上也与Linux更加近似）。  \n&emsp;&emsp;超长的续航也是吸引我的地方，现在我笔记本的电池损耗已经达到50%了，每次去教室敲代码都要带充电器真的很麻烦（不插电，我的轻薄本甚至连两个小时都挺不住），更不用说教室的充电位置十分有限以至于我根本找不到充电位置有余之教室的这种问题了。\n我做了充足的准备以转移到macOS：我的工具链是完全跨平台的，这让我能在macOS上享受任何我热爱的语言和工具。  \n&emsp;&emsp;毫不犹豫地，我下单了MacBook Pro 16英寸，配备10c+24c的M1 Max芯片和32+1T空间。大概要一个月后才能拿到货，可把我急死了。\n\n<div style="width:100%;text-align:center"><img style="min-width:320px;width:50%;" src="https://cdn.thaumy.cn/post/每月评论/每月评论2110/res/your_new_mac.jpg"></br><em>这是我的新Mac！</em></div>\n\n## 新版本pilipala\n\npilipala要迎来正式版啦！  \n&emsp;&emsp;一向以简洁高效为设计目标的pilipala将迎来全新版本，我重构了整个系统的架构体系，并采用了F#作为开发语言。F#提供了C#所不具备的函数式编程能力。尽管相较于其他ML系或者Haskell系语言，F#的类型系统有一定缺失，作为函数式语言而言也不够“纯”，但我相信它仍提供了目前最丰富的函数式生态（得益于与其他.NET构件兼容）。顺带一提，我是把F#当做“better C#”来用的，就像Kotlin是“better Java”那样，这也是虽然JVM生态上也有十分不错的Scala等函数式语言但我却没有打算采用的原因。  \n&emsp;&emsp;F#好处多多。最为显著地，以pilipala内核为例，得益于函数式设计思维和语言本身更少的语法噪音，由F#编写的全新内核提供了比旧版C#内核更多的功能，代码数量却减少了2500+行。全新设计的函数式错误类型系统也让pilipala更加安全。  \n&emsp;&emsp;不过我恨铁不成钢啊，要是F#能支持trait就好了（受Rust影响，我天天都在捣鼓怎样才能让F#模拟trait以实现更强大的静态泛型和约束能力，但都以失败告终）。\n\n## 关于假期Flag\n\n- [x] 精通正则表达式读完前300页（因为对我而言之后的内容鲜有阅读价值）。\n- [ ] 数据结构读完前200页，余下的交由下学期完成。`大概只读到170页左右。`\n- [ ] 达成40篇瓜大计算导论的编写。`实际只完成了31篇。`\n- [x] 补番两部。\n\n要知道，人是有惰性的啊。\n\n---\n\n## 杂事\n\n> 本板块用于记录一些有的没的。\n\n* 假期的时候手机摔掉了，更换屏幕时我不小心挑断了一根信号线，这使得手机的4G信号变得奇差无比。\n  <div style="max-height:220px;height:45vw;width:100%;"><img style="max-width:120px;width:30%;float:left" src="https://cdn.thaumy.cn/post/每月评论/每月评论2110/res/broken_iqoo.jpg"><em style="width:60%;text-align:center;margin:5%;margin-top:10%;float:left">屏幕被摔坏的手机，要知道它还在水里面泡了好一会。</em></div></br>\n\n  于是我买了一部二手LG V50作为备机开热点使用。只需要600元，你就可以得到：IP68防水、无线充电、SD卡槽、骁龙855、2.5K OLED屏幕、双卡5G、顶级手机DAC解码器和极为先进的3.5mm耳机孔......这手机真的是太值了！！！哦，它甚至还能接副屏！\n  <div style="max-height:160px;height:34vw;width:100%;"><img style="max-width:120px;width:30%;float:left" src="https://cdn.thaumy.cn/post/每月评论/每月评论2110/res/lg_v50.jpg"><em style="width:60%;text-align:center;margin:5%;margin-top:9%;float:left">LG V50</em></div></br>\n\n* 学校的几把猫怀孕了。\n* 我上大二了。\n\n---\n\n&emsp;&emsp;Stay Hungry, Stay Foolish.\n\n---\n\n<div align="right">\n\n每月评论 - 2110期(共7期)  \n撰稿&校对&审核：Thaumy\n\n</div>\n	2021-11-08 17:14:40	2021-11-08 17:15:27	2021-11-08 17:15:27	12	每月评论2110	1001
12401	<span style="float:right;" class="wd-dt5 cur" onclick="up();showPost(12376)">点此返回索引根目录</span>\n\n## PILIPALA 1902BETA6 LTS 第八步进维护日志\n\n<span class="mk-dt">19.08.21<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.08.21<span class="mk-w"></span></span>纠正了几个错别字，感谢<span class="wd-dt3">雅爱方雏</span>的支持。  \n<span class="mk-dt">19.08.15<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.08.15<span class="mk-w"></span></span>更新了关于博客页  \n<span class="mk-dt">19.08.15<span class="mk-dbg"></span></span>修复了关于博客计时器时钟过快的问题  \n<span class="mk-dt">19.08.14<span class="mk-dbg"></span></span>修复了文章列表加载不完全的问题  \n<span class="mk-dt">19.08.08<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.08.08<span class="mk-w"></span></span>发布了文章：结束了，初始化下一征程  \n<span class="mk-dt">19.08.08<span class="mk-mtn"></span></span>纠正了维护日志中的部分时间错误，这包括：\n* PILIPALA 1902BETA6 第二预览版维护日志\n* PILIPALA 1902BETA6 第一预览版维护日志\n* pilipala 1810BETA6 维护日志\n* pilipala 1810BETA5 维护日志\n\n<span class="mk-dt">19.08.08<span class="mk-mtn"></span></span>维护日志阅读说明已添加\n\n## PILIPALA 1902BETA6 LTS 第七步进维护日志\n\n### 从本日志起，细微的样式调整和文章更改将不加记录或登记为微调。这样做利于提升日志的目的性和维护效率。\n\n<span class="mk-dt">19.07.11<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.07.02<span class="mk-dbg"></span></span>由于未知原因，通过百度搜索进入博客时会出现错误路径调用的问题已消失  \n<span class="mk-dt">19.07.11<span class="mk-w"></span></span>发布文章：生病。。。  \n<span class="mk-dt">19.07.02<span class="mk-bug"></span></span>通过百度搜索进入博客时会出现错误路径调用  \n<span class="mk-dt">19.06.30<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.06.30<span class="mk-dbg"></span></span>修复了返回顶部按钮样式错误的问题  \n<span class="mk-dt">19.06.30<span class="mk-w"></span></span>发布了文章：氛愿景  \n<span class="mk-dt">19.06.29<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.06.29<span class="mk-w"></span></span>发布了关于博客页面  \n<span class="mk-dt">19.06.29<span class="mk-w"></span></span>完善了部分文章  \n<span class="mk-dt">19.06.29<span class="mk-ui"></span></span>修改了卡片样式  \n<span class="mk-dt">19.06.23<span class="mk-updt"></span></span>上下文章浏览按钮现可用  \n<span class="mk-dt">19.06.23<span class="mk-dbg"></span></span>修复了SL内核的一个查询语句bug  \n<span class="mk-dt">19.06.22<span class="mk-ui"></span></span>样式微调  \n\n## PILIPALA 1902BETA6 LTS 第六步进维护日志\n\n<span class="mk-dt">19.06.16<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.06.16<span class="mk-w"></span></span>发布了文章：我  \n<span class="mk-dt">19.06.16<span class="mk-ui"></span></span>CNZZ站长统计现已隐藏  \n<span class="mk-dt">19.06.16<span class="mk-ui"></span></span>导航栏卡片样式修改  \n<span class="mk-dt">19.06.15<span class="mk-bug"></span></span>在手机浏览时刷新主页会导致背景图片丢失  \n<span class="mk-dt">19.06.15<span class="mk-ui"></span></span>对部分颜色微调，并进行了样式表规范  \n<span class="mk-dt">19.06.15<span class="mk-ui"></span></span>导航栏签名样式修改，与头像所在盒联色  \n<span class="mk-dt">19.06.15<span class="mk-ui"></span></span>导航栏字距调整，修改版权信息  \n<span class="mk-dt">19.06.08<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.06.07<span class="mk-ui"></span></span>修改了部分样式  \n<span class="mk-dt">19.06.07<span class="mk-mtn"></span></span>SL1.15内核进入开发流程  \n<span class="mk-dt">19.06.02<span class="mk-ui"></span></span>修改了移动端头像大小  \n<span class="mk-dt">19.05.26<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.05.26<span class="mk-ui"></span></span>mrks与wrds标签样式更改  \n<span class="mk-dt">19.05.26<span class="mk-ui"></span></span>优化了背景图片的加载速度  \n<span class="mk-dt">19.05.26<span class="mk-w"></span></span>发布文章：PILIPALA BETA7愿景  \n<span class="mk-dt">19.05.25<span class="mk-w"></span></span>发布文章：赞助&支持  \n<span class="mk-dt">19.05.25<span class="mk-w"></span></span>部分文章和图片作了少许改动  \n<span class="mk-dt">19.05.25<span class="mk-ui"></span></span>优化了友链样式  \n<span class="mk-dt">19.05.18<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.05.18<span class="mk-ui"></span></span>新增wrd.css，它将和marks.css（已更名为mrks.css）一起用标记增加文章的可读性  \n<span class="mk-dt">19.05.01<span class="mk-w"></span></span>为“句摘”页补充了来自于《瓦尔登湖》一书的摘录  \n<span class="mk-dt">19.05.18<span class="mk-dbg"></span></span>由主题代码错误导致的“手机模式下文章列表标签栏的Time标签显示错位到右侧”的BUG现已修复  \n\n## PILIPALA 1902BETA6 LTS 第五步进维护日志\n\n<span class="mk-dt">19.05.11<span class="mk-ui"></span></span>marks样式已使用github作CDN优化  \n<span class="mk-dt">19.05.11<span class="mk-w"></span></span>删除了部分文章  \n<span class="mk-dt">19.05.11<span class="mk-ui"></span></span>文章条带已弃用  \n<span class="mk-dt">19.05.11<span class="mk-w"></span></span>发布文章：友情链接  \n<span class="mk-dt">19.05.11<span class="mk-w"></span></span>发布文章：欢迎页&主引导  \n<span class="mk-dt">19.05.11<span class="mk-bug"></span></span>手机模式第一次加载背景图片过于缓慢（超过30s），此问题有待于使用CDN解决  \n<span class="mk-dt">19.05.11<span class="mk-ui"></span></span>主题颜色微调  \n<span class="mk-dt">19.05.11<span class="mk-bug"></span></span>手机模式下文章列表标签栏的Time标签显示错位到右侧  \n<span class="mk-dt">19.05.01<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.05.01<span class="mk-bug"></span></span>颜色条带（xxxStrip）出现悬空，由于利用率低下，该功能在下一版本中会被“NEW”、“HOT”等图标取代  \n<span class="mk-dt">19.05.01<span class="mk-ui"></span></span>主题样式微调，新增图片阴影样式以增加观感  \n<span class="mk-dt">19.05.01<span class="mk-updt"></span></span>SL内核现已改为生产模式以进一步提升运行速度  \n<span class="mk-dt">19.05.01<span class="mk-updt"></span></span>图片外链加速现已由贴图库改用又拍云  \n<span class="mk-dt">19.05.01<span class="mk-ui"></span></span>field主题圆角改为8px（原10px）  \n<span class="mk-dt">19.05.01<span class="mk-w"></span></span>部分文章内容小改  \n<span class="mk-dt">19.05.01<span class="mk-dbg"></span></span>Time/Date标签重复显示问题修复  \n<span class="mk-dt">19.04.22<span class="mk-bug"></span></span>部分外链图片失效  \n<span class="mk-dt">19.04.21<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.05.01<span class="mk-bug"></span></span>Time/Date标签出现重复显示（该问题由主题函数暂未开发导致）  \n<span class="mk-dt">19.04.21<span class="mk-w"></span></span>修改了部分文章内容  \n<span class="mk-dt">19.04.21<span class="mk-dbg"></span></span>使用img标签解决了部分文章图片过大的超出问题  \n<span class="mk-dt">19.04.21<span class="mk-mtn"></span></span>对内核和主题的部分文件做了命名优化  \n<span class="mk-dt">19.04.21<span class="mk-dbg"></span></span>使用contain方式解决了手机端背景显示不清晰的问题，但效果仍不理想  \n<span class="mk-dt">19.04.21<span class="mk-ui"></span></span> 菜单下拉按钮样式更改，使其更利于阅读  \n<span class="mk-dt">19.04.21<span class="mk-ui"></span></span>调整了文字大小以在保证阅读的情况下显示更多内容  \n<span class="mk-dt">19.04.21<span class="mk-ui"></span></span>修改了部分图标样式  \n<span class="mk-dt">19.04.21<span class="mk-ui"></span></span>氛元素主题（ElementFen theme）更名为氛主题（Field theme），受到IDE启发，现已采用暗色调配色，提供了更强的可读性，有利于视力保护和缓解审美疲劳  \n<span class="mk-dt">19.04.20<span class="mk-ui"></span></span>LabelBox图标修改，新增Time标签，用来表示文章发布的详细时间，该标签解决了手机端时间溢出问题  \n<span class="mk-dt">19.04.20<span class="mk-updt"></span></span>博客在本周内被百度收录\n\n## PILIPALA 1902BETA6 LTS 第四步进维护日志\n\n<span class="mk-dt">19.04.14<span class="mk-bug"></span></span>文章图片过大会超出显示范围，丧失自动调整功能，这与最近的一次样式修改有关  \n<span class="mk-dt">19.04.14<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.04.14<span class="mk-updt"></span></span>CNZZ站长统计现可用  \n<span class="mk-dt">19.04.14<span class="mk-w"></span></span>发布了文章：关于pilipala  \n<span class="mk-dt">19.04.14<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.04.14<span class="mk-updt"></span></span>维护日志现已使用更简洁的时期表达  \n<span class="mk-dt">19.04.14<span class="mk-dbg"></span></span>修正了维护日志的几处日期错误  \n<span class="mk-dt">19.04.14<span class="mk-bug"></span></span>博客背景图无法兼容移动端，表现为不能覆盖全屏  \n<span class="mk-dt">19.04.14<span class="mk-updt"></span></span>现已使用图床优化图片加载速度  \n<span class="mk-dt">19.04.14<span class="mk-bug"></span></span>MarkDown的引用标签无法套用，会显示为">"符号  \n<span class="mk-dt">19.04.14<span class="mk-w"></span></span>删除了部分文章  \n<span class="mk-dt">19.04.14<span class="mk-updt"></span></span>优化了文章格式  \n<span class="mk-dt">19.04.13<span class="mk-w"></span></span>发布文章：Thaumy人设  \n<span class="mk-dt">19.04.13<span class="mk-w"></span></span>发布文章：水瓜社成立  \n<span class="mk-dt">19.04.13<span class="mk-w"></span></span>修改了部分文章标题、内容  \n<span class="mk-dt">19.04.05<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.04.05<span class="mk-w"></span></span>发布了文章：Thaumy语录  \n<span class="mk-dt">19.04.05<span class="mk-updt"></span></span>css结构优化  \n<span class="mk-dt">19.04.05<span class="mk-updt"></span></span>现已采用思源黑体和Ubuntu字体作为显示字体，基于GoogleFonts外链  \n<span class="mk-dt">19.04.05<span class="mk-updt"></span></span>因为手机端不支持动态渲染毛玻璃，毛玻璃样式和透明样式现已更换为不透明扁平色  \n\n## PILIPALA 1902BETA6 LTS 第三步进维护日志\n\n<span class="mk-dt">19.03.31<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.03.31<span class="mk-updt"></span></span>站点背景样式微调  \n<span class="mk-dt">19.03.31<span class="mk-updt"></span></span>取消了菜单栏的毛玻璃样式，并进行了样式微调  \n<span class="mk-dt">19.03.30<span class="mk-bug"></span></span>首页的调用机制和AJAX不利于代码阅读和向后兼容，这个问题已列入BETA7开发任务  \n<span class="mk-dt">19.03.30<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.03.30<span class="mk-updt"></span></span>现已通过js函数返回顶部而非使用js事件  \n<span class="mk-dt">19.03.30<span class="mk-updt"></span></span>维护日志标签样式更新  \n<span class="mk-dt">19.03.30<span class="mk-updt"></span></span>Box阴影微调以提升层次感  \n<span class="mk-dt">19.03.30<span class="mk-updt"></span></span>毛玻璃渐变层微调以提升视觉体验  \n<span class="mk-dt">19.03.30<span class="mk-updt"></span></span>css结构优化  \n<span class="mk-dt">19.03.30<span class="mk-updt"></span></span>手机版菜单调出按钮ShowNaviBtn现已完备，并使用了旋转样式以提升体验  \n<span class="mk-dt">19.03.24<span class="mk-dbg"></span></span>ShowNaviCardBoxBtn向后兼容问题已解决，并给予了命名优化  \n\n## PILIPALA 1902BETA6 LTS 第二步进维护日志\n\n<span class="mk-dt">19.03.24<span class="mk-updt"></span></span>使用了清晰度更高的个人头像以解决手机端头像模糊的问题  \n<span class="mk-dt">19.03.24<span class="mk-updt"></span></span>文章底部的评论和点赞按钮样式优化，现已加入响应式适配  \n<span class="mk-dt">19.03.24<span class="mk-updt"></span></span>返回顶部按钮现已支持淡入和出加载，返回顶部机制更新完成  \n<span class="mk-dt">19.03.24<span class="mk-dbg"></span></span>ShowNaviCardBoxBtn代码优化完成，采用全新滑出样式  \n<span class="mk-dt">19.03.24<span class="mk-bug"></span></span>ShowNaviCardBoxBtn不利于代码维护，目前正在想办法解决这个问题  \n<span class="mk-dt">19.03.24<span class="mk-updt"></span></span>为手机版提供了一个下拉按纽（ShowNaviCardBoxBtn）以单独显示文章菜单导航，有效利用了空间  \n<span class="mk-dt">19.03.23<span class="mk-updt"></span></span>规范了部分css类名称，同时对导航、文章列表和文章详情进行了样式更改  \n<span class="mk-dt">19.03.23<span class="mk-updt"></span></span>现已支持手机和电脑的响应式背景，这在不同的设备上能给予了不同的背景观感，也有利于针对手机电脑适配背景  \n<span class="mk-dt">19.03.23<span class="mk-updt"></span></span>将部分Box毛玻璃化以增加可读性，并与半透明背景和描边搭配以丰富视觉效果  \n<span class="mk-dt">19.03.23<span class="mk-updt"></span></span>毛玻璃模糊度与背景色优化，增强了可读性  \n<span class="mk-dt">19.03.16<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.03.16<span class="mk-updt"></span></span>文章卡片更换为毛玻璃样式  \n<span class="mk-dt">19.03.16<span class="mk-bug"></span></span>由于和毛玻璃样式冲突，桌面端的背景随鼠标移动特效失效  \n<span class="mk-dt">19.03.16<span class="mk-updt"></span></span>更改一些移动端的显示间距，使其更利于展示  \n<span class="mk-dt">19.03.16<span class="mk-updt"></span></span>调整了部分背景和圆角样式  \n\n## PILIPALA 1902BETA6 LTS 第一步进维护日志\n\n<span class="mk-dt">19.03.10<span class="mk-mtn"></span></span>维护日志已上载  \n<span class="mk-dt">19.03.10<span class="mk-updt"></span></span>增加了点击“THAUMY的博客”文字可以返回首页的功能  \n<span class="mk-dt">19.03.09<span class="mk-dbg"></span></span>修复了维护日志的一些标记错误  \n<span class="mk-dt">19.03.09<span class="mk-updt"></span></span>氛元素主题样式修改，使得手机和平板的浏览布局更佳，并调整了灰白色的深度以增强视觉效果  \n<span class="mk-dt">19.03.09<span class="mk-updt"></span></span>优化了版权文本的行距  \n<span class="mk-dt">19.03.09<span class="mk-w"></span></span>上传了啪啦B6宣传图  \n<span class="mk-dt">19.03.09<span class="mk-w"></span></span>发布文章 噼里啪啦第六开发版现可用  \n<span class="mk-dt">19.03.09<span class="mk-w"></span></span>重选了菜单和文列的展示文章  \n<span class="mk-dt">19.03.09<span class="mk-dbg"></span></span>文章列表倒序加载已修复，这与stepTextList()方法的第二重载的错误有关  \n<span class="mk-dt">19.03.09<span class="mk-updt"></span></span>重置了数据库的一些默认值  \n<span class="mk-dt">19.03.09<span class="mk-dbg"></span></span>修复了StudioLibrary1.14内核的一个错误，这个错误使得stepTextList()方法的第二重载无法筛选文章类型以输出文章  \n<span class="mk-dt">19.03.09<span class="mk-bug"></span></span>文章列表不能以ID为顺序倒序加载  \n<span class="mk-dt">19.03.09<span class="mk-bug"></span></span>由文章详情返回首页后会丢失已加载的文章列表  \n<span class="mk-dt">19.03.09<span class="mk-updt"></span></span>博文已支持MarkDown语言，往后的博文更新将全部以MarkDown编写  \n<span class="mk-dt">19.03.03<span class="mk-w"></span></span>维护日志校准完成  \n<span class="mk-dt">19.03.02<span class="mk-updt"></span></span>氛元素主题维护日志提供标记块支持  \n<span class="mk-dt">19.03.02<span class="mk-updt"></span></span>氛元素主题超链接标记块颜色调整为蓝色，与评论按钮一致  \n<span class="mk-dt">19.02.17<span class="mk-updt"></span></span>氛元素主题部分样式微调  \n<span class="mk-dt">19.02.17<span class="mk-mtn"></span></span>氛元素主题开始使用GUID进行版本控制  \n<span class="mk-dt">19.02.17<span class="mk-mtn"></span></span>PILIPALA开始使用GUID进行版本控制\n\n## PILIPALA 1902BETA6 第三预览版维护日志\n\n### <span class="mk-dt">19.02.14<span class="mk-updt"></span></span>PILIPALA第六开发版（PILIPALA Beta6 LTS）\n\n* 应用了第三代对象式架构，将整个网站系统的耦合度显著降低，极大地避免了各部分的彼此牵连，并降低了逻辑复杂度\n* 提供了主题编写支持，用户可以根据需要自行编写主题、更改网站样式\n* 采用主页映射，将站点首页映射到启动页，利于简化链接复杂度\n* 废除webio（网页IO桥），全局数据处理部署于webservice，简化了数据操作逻辑\n* 去除了服务端ajax支持，因为它会大幅提升现有架构复杂度\n* 该版本使用WebApplication代替WebSite建筑，因为前者提供了更佳的MSBuild支持\n\n### <span class="mk-dt">19.02.14<span class="mk-updt"></span></span>氛元素主题190213（fen）\n\n* 提供了基于JQuery的Ajax支持，减轻了服务端业务压力，无刷新加载提升了用户体验\n* 响应式网页设计使得氛元素主题能兼容任何屏幕规格的浏览设备，移动端最佳的浏览设备为 iPad Pro，桌面端最佳分辨率为1080p\n* 为第三代对象式架构提供了UI及命名支持，优化了css分类\n* 数据层操作全部移交服务端，提升了安全系数\n* 删除了ReadOnly条带，因为该样式不利于数据层整合\n* 半透明的UI设计，与背景图搭配提升了浏览体验\n* 新增功能：点击头像可返回首页\n  \n<span class="mk-dt">19.02.14<span class="mk-dbg"></span></span>点赞按钮现可用  \n<span class="mk-dt">19.02.14<span class="mk-dbg"></span></span>浏览计数现可用  \n<span class="mk-dt">19.02.14<span class="mk-dbg"></span></span>推进加载按钮现可用（该按钮可有效减轻服务端数据库遍历压力）\n\n### <span class="mk-dt">19.02.14<span class="mk-updt"></span></span>StudioLibrary1.14LTS的全面支持\n\n* 噼里啪啦命名空间全部重构，应用了第三代对象式架构以全面兼容palaDB，使其完全脱离业务实现架构束缚，\n为开发及向后兼容与维护提供便利\n* 采用大量接口约束噼里啪啦方法与结构，明确了各个方法的分工和彼此联系\n\n### <span class="mk-dt">19.02.14<span class="mk-updt"></span></span>palaDB全部重构\n\n* 文本数据采用三分库设计（灵感来源于AKG K3003），达到了逻辑简明与业务高效的完美契合\n* 删除原有palaRoot（根级数据表）和palaUser（用户数据表），两者精简后兼为一表，提升了数据整合度\n* 视图部分全部重构，对StudioLibrary对象式架构提供基层支持\n* 数据库函数大量精简，采用父子级和归类查询思路，简洁明了的函数设计很好地提升了开发效率\n\n## PILIPALA 1902BETA6 第二预览版维护日志\n\n<blockquote>注意，此日志在时间戳上存在统计遗漏，现有的时间记录是结合多方面数据分析得出的，可能与实际不符。</blockquote>\n\n<span class="mk-dt">19.02‎.‎07‎<span class="mk-mtn"></span></span>PILIPALA 第六开发版第二预览版已上线：www.thaumy.cn  \n<span class="mk-dt">19.02‎.‎07‎<span class="mk-updt"></span></span>增添了对手机浏览器的支持，手机px宽为1024以上网页会自动切换到pc模式  \n<span class="mk-dt">19.02‎.‎07‎<span class="mk-bug"></span></span>点赞浏览计数评论推进加载功能因ajax解决方案不理想暂不可用  \n<span class="mk-dt">19.02.‎07<span class="mk-dbg"></span></span>修复了配置文件冗余标记导致的运行环境问题\n\n## PILIPALA 1902BETA6 第一预览版维护日志\n\n<blockquote>注意，此日志在时间戳上存在统计遗漏，现有的时间记录是结合多方面数据分析得出的，可能与实际不符。</blockquote>\n\n<span class="mk-dt">19.02‎.‎04‎<span class="mk-updt"></span></span>上传了氛元素UI作为站点  \n<span class="mk-dt">19.02‎.‎04‎<span class="mk-bug"></span></span>因为运行环境问题，该版本无法部署于站点服务器\n\n## pilipala 1810BETA6 维护日志\n\n<blockquote>注意，此日志在时间戳上存在统计遗漏，现有的时间记录是结合多方面数据分析得出的，可能与实际不符。</blockquote>\n\n<span class="mk-dt">18.12‎.‎09<span class="mk-mtn"></span></span>因为新的实现思路，该项目开发终止，没有入网  \n<span class="mk-dt">18.10.‎27‎<span class="mk-mtn"></span></span>噼里啪啦项目正式纳入码肆计划（masiproj）	2019-11-02 19:09:29	2019-11-02 19:09:44	2019-11-02 19:09:44	12	PB6维护日志	1001
12482	# Side Effect\n\n副作用\n\n## 概要\n\n某些函数在调用时还会对周围环境产生影响，这些影响就被称为副作用。\n\n## 介绍\n\n某些函数依赖于外部环境，因而可能对外部环境产生影响，产生的影响就叫做副作用。  \n\n下面给出了一个函数`sum`，它计算两个数的和并返回。\n\n``` C\nint i=0;\nint sum(int a,int b){\n    i=1;\n    return a+b;\n}\n```\n\n但是它还改变了外部变量`i`的值，这就是副作用。  \n当你的业务逻辑依赖于这个`i`时，就可能出问题，因为它是可能被更改的。\n\n我们在写代码时要避免副作用。  \n当然有些副作用是不可避免的，由此人们就发明了一些控制副作用的技能，比如猫。\n\n## Playground\n\n函数`printf`有副作用吗，为什么？\n	2021-12-15 22:57:20	2021-12-15 22:57:20	2021-12-15 22:57:20	12	Side Effect	1001
12487	# Type Safety\n\n类型安全\n\n## 概要\n\n**类型安全**是编程语言的一种特性，具有类型安全完备的语言不会抛出运行时类型错误，例如空指针异常（Null Pointer Exception,NPE）或者类型转换异常。强大的类型系统往往能够将类型错误在编译期检出，从而避免了将类型错误推迟到运行时。\n\n## 类型安全的反例\n\n* ### 弱类型  \n\n类型安全往往要借助强大的类型系统来实现，而弱类型则根本没有类型的概念（或很模糊），因此不具有类型安全性，考虑以下JavaScript代码：\n\n```JavaScript\nfunction f(a, b) { return a - b }\nlet x  = f( {} , {} )//NaN\n```\n\n由于JavaScript的类型系统是建立在运行期的，所以以上类型错误并不会在编译期（对于JS而言，更确切的表述是运行前）被发现，因而`x`的值在运行期变成了`NaN`，这个错误的值会一直在运行期传播蔓延（期间很可能产生许多不希望的后果！），直到引发异常（Exception）。如果类型系统完备，则在运行前就会发现减法不能作用于`Object`这一事实，因而提前发现了错误。\n\n* ### 滥用继承和多继承\n\n滥用继承是一种为达目的而不择手段的继承方式，出于一些原因，人们有时会在不考虑原有继承关系的情况下进行派生，从而破坏了原有类型的安全性，考虑以下Java代码：\n\n```Java\nclass A {}//对全局抽象\nclass B extends A{}//内含业务逻辑\nclass C extends A{}//内含业务逻辑\n```\n\n上述代码由于写的非常好而在社区广受欢迎，所以作者将其做成了一个Java包分享给大家使用。\n\n某公司由于业务面的拓宽，有越来越多的业务逻辑在类`B`和类`C`中呈现高度分化，于是某开发人员小李自己实现了一个类`D`并从`A`中派生出来以满足新的需要（假定小李因为在通宵打代码所以根本没有时间去研究原作者的派生意图）。由于`D`从`A`中派生出来，所以其他的开发人员在需要`A`作为参数的地方传入`D`并不能被编译器检查出来，这就造成了类型安全的缺失。\n\n由于这一原因，Kotlin中的类在默认情况下是封闭（sealed）的，从而在一定程度上缓解了随意派生这种现象。\n\n多继承主要体现在C++中，这种多父类的机制在设计不完备的情况下会出现很大的类型问题（多继承的作用关系往往是难以分析的），因而在现代化的编程语言中往往只允许类的单根继承。\n\n* ### 放弃类型检查\n\n以Java为例，由于其所有类型的基类均为`Object`，所以在迫不得已而使用`Object`的情况下可能会造成类型问题，由于`Object`是Java的**平台类型**（即最终的基类），所以这种类型错误是无法被发现的。\n\n例如：\n\n```Java\nObject s = "1";\nObject i = 1;\nint sum = (int) s + (int) i;//不会被编译器发现\n```\n\n虽然例子很⑨，但在实现某些特定功能或模拟一些特性（如泛型或HKT）的时候的确有可能使用上述写法。这用起来很方便，但代价是显而易见的。\n\n强制转换由于放弃了类型检查，因而也难以避免发生错误：\n\n```Java\nclass Base {}\nclass Derived extends Base {}\n\nBase    b = new Base();\nDerived d = (Derived) b;//不会被编译器发现\n```\n\n父类强制转换到子类会造成类型信息的缺失，因而上述代码在运行期抛出了异常。\n\n* ### 封装性破坏  \n\n典型的例子就是C++的友元函数，它破坏了类的封装性，因而对类型安全造成了威胁（因为你可以修改一些数据以使原本能够正常进行的类型转换失败，这是不能被编译器发现的），因而现代化的编程语言均不支持这一特性。\n\n如果推广开来，那么你也能够明白为什么指针不是类型安全的。\n\n* ### 恶臭的NULL\n\nNULL可以说是破坏绝大多数编程语言类型安全的一个罪魁祸首了，以Java为例，几乎所有的引用类型都可以被设置为`null`。因而在某种程度上，`null`是横跨类型系统的一种存在：\n\n```Java\nclass Clazz{}\n\nString s = null;\nObject o = null;\nClazz  c = null;\n...//如果大家都为 null，那还有什么类型可言呢？\n```\n\nNULL最初是为编程语言的实现的简单性而引入的，而现如今绝大对数的NPE是由NULL引起的，可以说是万恶之源了。\n\n> 我称之为我的十亿美元错误......当时，我正在设计第一个全面的类型系统，用于面向对象语言中的引用功能。我的目标是确保所有对引用的使用都是绝对安全的，由编译器自动执行检查。但是我无法拒绝定义一个 Null 引用的诱惑，因为它实在太容易实现了。这导致了无数错误、漏洞和系统崩溃。在过去的四十年里，这些问题可能已经造成了十亿美元的损失。 ——托尼 · 霍尔\n\n## 类型安全举例\n\n* ### ADT中的类型安全：计数与模式匹配\n\n在ADT那一节的末尾我们提到了ADT具有类型安全性，由于ADT的所有取值是可**计数**$^{*1}$的，因而编译期的类型检查能及时发现类型异常从而使得编译无法被通过。同时，类型安全也为**模式匹配**$^{*2}$这种编程范式提供了安全基础，具有类型安全的类型在模式匹配中也是类型安全的，例如：\n\n```Haskell\ndata Alphabet = A | B | C\n\nf A = A\nf B = B\n{-\nwarning:\n  Pattern match(es) are non-exhaustive\n  In an equation for ‘f’: Patterns not matched: C\n-}\n```\n\n由于模式匹配并未匹配完全（缺失了模式`C`），所以这个问题被检测到而产生了警告。类型安全是相对的，显然在绝大多数的工业语言中遗漏匹配并不会得到这样的警告（例如你写的`if`语句并未涵盖所有情况）。\n\n非ADT类型则由于不可计数而使得类型系统难以发现潜在的类型错误。这让我想起了编写RPN那一节时的经历，当时我在为文章末尾讨论的的RPN解析器编写用例：\n\n```Haskell\nparser '+' (x : y : s) = (y + x) : s\nparser '-' (x : y : s) = (y - x) : s\nparser '*' (x : y : s) = (y * x) : s\nparser '/' (x : y : s) = (y / x) : s\n--parser ' ' s = s\nparser x s = (read [x]) : s\n```\n\n可见，`parser`的模式匹配拥有相对复杂的类型组合，使得类型系统难以推导其计数（因而计数被忽略了）而发现遗漏的模式。被打上注释的那一行是一个当时被我漏掉的匹配空格的模式，由于类型系统没有检测到这一疏忽，所以我在运行期收到了一个无法匹配空格的异常抛出。\n\n* ### 泛型安全\n\n在没有泛型的情况下，如果我们模拟一个泛型数组，会这样做：\n\n```Java\nvar intArr = new ArrayList<>();\nintArr.add(1);\nintArr.add(2);\nint i = (int) intArr.get(0);//取出\n```\n\n看起来没什么问题，但这个数组是允许其他类型存入的，这就造成了类型不安全：\n\n```Java\nintArr.add("3");//不会被编译器发现\nint i = (int) intArr.get(2);//抛出异常\n```\n\n而有了泛型，我们就可以这样做：\n\n```Java\nvar intArr = new ArrayList<Integer>();\nintArr.add(1);\nintArr.add(2);\nintArr.add("3");//不能通过编译\nint i = intArr.get(0);\n```\n\n编译期类型检查使得其他类型不能添加到泛型数组中，这就使得类型安全得到了保证。与此同时我们还省去了繁琐的类型转换过程。\n\n上述泛型是不变的，泛型型变技术（逆变和协变）允许我们在类型安全的基础上扩展我们的泛型，它同样是类型安全的，这里就不作过多介绍了。同时，高阶类型作为泛型技术的一种扩展，同样享有泛型带来的类型安全性。\n\n* ### 表达式安全性\n\n表达式也有助于类型安全，考虑以下代码：\n\n```Java\nint i;//为了演示而使用int，请考虑可能的NPE情况。\nif (...) { i = 1; }\n...//TODO\n```\n\n如果你写过类似上述的代码，那么你一定了解这样的代码是多么糟糕。如果后续代码用到了`i`的值而你没有在`else`块里规定`i`在另一种情况下的取值，那么很可能引发异常。而在Kotlin中，`if...else...`可以当作表达式来使用，从而避免了因遗忘而导致的未初始化：不同于语句，表达式是必须有返回值的。\n\n```Kotlin\nval i: Int = if (...) { 1 } else { 0 }\n...//TODO\n```\n\n## Playground\n\n今天没有作业。\n\n---\n\n### 注解\n\n1. 计数，即为类型取值的数目。例如布尔类型的取值只有True和False两种，那么我们称其计数为2。如果某个类型的计数过于庞大，那么我们通常认为它是不可计数的。\n2. 常见于函数式或具有函数式风格的语言，模式匹配能够在避免使用`if...else...`的同时提供比`switch`强大得多的分支处理能力，模式匹配还具有良好的可读性。\n	2021-12-15 23:00:44	2021-12-15 23:00:44	2021-12-15 23:00:44	12	Type Safety	1001
12456	# MacBook Pro 16'' 使用体验\n\n我心心念念的MacBook终于到手了。经过十天的适应和体验，我觉得有必要写一篇评测来向你介绍这台Mac的方方面面。\n\n## 工业设计\n\n<img src="https://cdn.thaumy.cn/post/评测/MacBook Pro 16'' 使用体验/res/id.jpg">\n\n&emsp;&emsp;这一代的MacBook Pro 16''使用了新模具，由于缺少收边设计，这导致它在观感上显得十分厚重。\n但从实物来看，它其实并没有渲染图上看起来的那样糟糕。这就好比看到iPhone和拿到iPhone一样，这是完全不同的感觉，且只能通过实际上手体验才能得到感知。它依然是顶尖做工与高超设计水准的代表。  \n&emsp;&emsp;但不可否认，刘海的确是丑爆了的设计。刘海破坏了这块边框仅有3.5毫米的屏幕在观感上的一致性，并且没有带来功能上的增强（我指它不具备FaceID）。但从实际体验来看，这块刘海给我的感觉仅仅是“这块屏幕有一个刘海”，并没有影响到我的工作。需要了解到macOS的顶部是菜单栏，在这块公共区域上增添这样的一个刘海对于16英寸的屏幕而言确实影响不大。另外值得一提的是，刘海是可以隐藏的，在刘海周边全黑的隐藏状态下，相较于手机更加难以区分刘海和显示区域的界限。  \n&emsp;&emsp;单手开合一直是MacBook的全系标配，这个不多讲。  \n&emsp;&emsp;MageSafe非常方便：随便一碰就能充电，充满后只需要轻轻一提就能取下。\n\n## I / O\n\n<img src="https://cdn.thaumy.cn/post/评测/MacBook Pro 16'' 使用体验/res/io.jpg">\n\n&emsp;&emsp;MiniLED所具备的1000nit亮度仅于播放HDR视频可用。它确实提供了远超以往的超高对比度和精确的色准。泛光控制和动态刷新率调节均十分优异，你确实可以相信这是目前笔记本上最好的显示器之一。  \n&emsp;&emsp;经升级的扬声器提供了非常震撼的音效体验。这是我听过的最好的外放设备，在笔记本扬声器中实属是天花板级别。令我出乎意料的是，它的内放同样出色，可能是由于这一代针对高阻抗耳机的优化所致，即使在最大音量下，它依旧可以提供高保真的音频输出。$^{*1}$  \n&emsp;&emsp;约2毫米键程的键盘手感中规中矩，但静音效果十分优秀。经阳极氧化工艺处理的黑色键盘周边使得键帽背光状态下的光线溢出明显减少。由于我没有使用过配备TouchBar的MabBook，所以对于F系列实体按键的回归感知不强。  \n&emsp;&emsp;宽大的触控板提供了目前最顶尖的触控体验，我相信任何熟练使用这块触控板工作的人都不再需要鼠标。  \n&emsp;&emsp;相较于我原来1.4千克的笔记本而言，2.2千克确实很重，我难以仅靠单手持续把握它。  \n&emsp;&emsp;我既不是摄影爱好者，也没有投影设备的连接需求，所以SD卡槽和HDMI接口的回归对我而言感知不强。\n\n## 续航\n\n<img src="https://cdn.thaumy.cn/post/评测/MacBook Pro 16'' 使用体验/res/battery_life.jpg">\n\n&emsp;&emsp;这台Mac配备了M1 Max芯片（24核GPU款）和32GB运行内存，其功耗控制十分优秀。\n\n* 在我较轻的使用场景下，它能满足我近2天的工作需要（14h）。冰凉，风扇不转。$^{*2}$  \n* 在我一般的使用场景下，它能满足我一整天的工作需要（8～10h）。大体冰凉，仅D面偶尔温热，风扇不转。  \n* 在我重度的使用场景下，它能提供至少4小时的使用时间。稍高于体温的峰值热量，风扇以难以察觉的声音运转。\n\n&emsp;&emsp;让我惊奇的是，在CPU满载的情况下，这台笔记本的风扇竟然只有1500RPM左右的转速（而且前10分钟它是不转的），噪音之微小以至于我需要把耳朵贴到它的出风口上才能确定它确实启动了风扇。在我90%用例中它连发热都提不上，更不要提什么风扇运行了。\n\n&emsp;&emsp;现在就可以把电充满，毫不夸张地从天亮用到深夜。\n\n## 性能\n\n&emsp;&emsp;我的工作流对性能的感知并非很强，相信各大机构在性能方面会有更加专业且全面的评价。但我可以很负责任的讲，我完全不知道这台电脑的性能极限究竟在哪里，因为我还从未见过这样一台在CPU满载下风扇还不转的电脑（无论如何使用，风扇最多达到3000RPM转速，而它全速运行时可达5300RPM）。另外我认为目前应用的优化程度也不足以发挥这颗芯片的全部效能。\n\n## macOS\n\n<img src="https://cdn.thaumy.cn/post/评测/MacBook Pro 16'' 使用体验/res/macos.jpg">\n\n&emsp;&emsp;macOS是我最为关注的部分，也是我购买Mac的原因，它对我而言至关重要。  \n&emsp;&emsp;从实际使用来看，我对macOS的担忧确实过多了，它确实仅仅是一个更好用的Linux而已（我当然明白它是UNIX）。开发环境的配置不知道比Windows简单到哪里去了，适用于Linux的命令在macOS下均可用，大多数情况仅需`brew install`就能完成所有的工作。把应用程序（.app文件）移入或移出Applications文件夹就能完成应用的安装或卸载，不会造成残留。虽然一直听网上说Monterey的bug很多，但实际体验下来并没有多少，要知道Windows11的bug不知道比这玩意多哪去了。目前应用对M1芯片的适配已十分完善，我所使用的全部软件均为非转译原生。\n\n&emsp;&emsp;macOS是成熟的操作系统。其内存管理与任务调度策略相较于Windows都更胜一筹，这使得我即使在100%的CPU占用下也完全不会感受到和10%的CPU占用有任何的区别（macOS会优先满足前台应用对资源需求）。macOS对于高分辨率下的显示渲染给予了更好的支持（尤其是字体），这块3.7K&16''屏幕的细腻程度明显优于我原来笔记本的4K&14''屏幕。  \n&emsp;&emsp;macOS是开放的操作系统。截至目前，我还没有遇到任何受限于macOS的开发问题，系统权限的获取也十分方便（同Linux一样，sudo）。并非局限于AppStore，你也可以从其他来源安装软件使用，当然也包括破解软件。  \n&emsp;&emsp;macOS是优雅的操作系统。有别于Windows上四世同堂UI风格的随处可见，macOS的UI精简且统一。无论是使用跨平台分发的版本还是Windows上的替代品，macOS上的软件均具有现代美观的界面，~~这一点微软的Office系列就是很好的代表~~。  \n&emsp;&emsp;macOS也是高效的操作系统。使用macOS的笔记本是无需关机的，这使得你能够快速还原上一次的工作状态而不必担心Windows上不关机所带来的卡顿和故障。系统自带Caps&Ctrl映射交换（对程序员友好）。相较于Windows，macOS的快捷键设计丰富且更加合理，搭配触控板，堪称效率神器。\n\n&emsp;&emsp;总而言之，使用这台电脑工作，我最不担心的就是macOS。\n\n## 总结\n\n<img src="https://cdn.thaumy.cn/post/评测/MacBook Pro 16'' 使用体验/res/end\n.jpg">\n\n&emsp;&emsp;虽然我很满意这台Mac，但不可否认的是它的确不适合所有人。对于游戏玩家和工科（非计科软工类）群体而言，MacBook的确可能成为非常差劲的选择。我不是果粉（我十分讨厌iPhone），也不希望引起争端，衷心希望大家都能够选购自己最喜欢的产品。在我看来，这台Mac只是一个工具，它能以令我满意的方式完成我所需完成的任务。\n\n---\n\n### 注解\n\n1. 与配备ES9218功放芯片的LG V50手机进行对比，耳机为兴戈EM2R。\n2. 具体的负载情况如下：\n   * 较轻的使用场景：屏幕亮度依正常环境适宜，功耗模式节能，开启wifi，后台开启网易云音乐持续播放音乐，Safari浏览器和Edge浏览器共维持在10个页面左右，VSCode、TODO。\n   * 一般的使用场景：屏幕亮度依正常环境适宜，功耗模式自动，开启wifi，较轻使用场景中的所有应用，附加Rider（2～4个项目）、IDEA（1～2个项目）、Navicat、Github Desktop、PS或Excel。\n   * 重度使用场景：屏幕亮度依正常环境适宜，功耗模式高能耗，开启wifi，一般使用场景下的所有应用，后台持续挖矿，维持CPU的100%负载状态。\n\n<div align="right">\n\n本文章使用MacBook Pro 16''编写并发布。\n\n</div>\n	2021-11-21 10:45:24	2021-11-21 10:42:14	2021-11-21 10:42:14	12	MacBook Pro 16'' 使用体验	1001
12399	<span style="float:right;" class="wd-dt5 cur" onclick="up();showPost(12376)">点此返回索引根目录</span>\n\n## beta 维护日志(pub1706版本1)(小部分错误)\n\n<span class="mk-dt">17.06.07<span class="mk-updt"></span></span>停用了主机屋虚拟主机，beta 版本结束  \n<span class="mk-dt">17.06.05<span class="mk-mtn"></span></span>进行了 1 次 zjw 常规备份  \n<span class="mk-dt">17.06.05±2<span class="mk-updt"></span></span>Sindex 文件夹开始存储 js文件  \n<span class="mk-dt">17.06.02<span class="mk-updt"></span></span>减小 Qplayer播放器音乐音量 至 20%  \n<span class="mk-dt">17.06.02<span class="mk-dbg"></span></span>修复了 NewBlog页面中的博客运行计时为0 的问题  \n<span class="mk-dt">17.05.29->06.04<span class="mk-w"></span></span>修订页面 NewBlog 计 66 次  \n<span class="mk-dt">17.05.31<span class="mk-mtn"></span></span>进行了 1 次 zjw 常规备份  \n<span class="mk-dt">17.05.30<span class="mk-mtn"></span></span>截至此时，博文在 beta版本 中累计修订 279 次  \n<span class="mk-dt">17.05.30<span class="mk-updt"></span></span>更换了 没有特色图片的替代图片  \n<span class="mk-dt">17.05.30<span class="mk-dbg"></span></span>修复了 音乐播放器不响应 的问题  \n<span class="mk-dt">17.05.29<span class="mk-w"></span></span>删除页面：关于  \n<span class="mk-dt">17.05.29<span class="mk-w"></span></span>发布页面：关于  \n<span class="mk-dt">17.05.27<span class="mk-bug"></span></span>修复 ajax返回主页时特色图片不加载 的问题未成功  \n<span class="mk-dt">17.05.27±10<span class="mk-bug"></span></span>登记问题：浏览器开启缓存的情况下打开博客会应用旧样式  \n<span class="mk-dt">17.05.27<span class="mk-w"></span></span>将 Developer's Lab计划 页面更名为 Developers Lab  计划  \n<span class="mk-dt">17.05.27<span class="mk-w"></span></span>将 Developers Lab  计划 页面更名为 Developer's Lab计划  \n<span class="mk-dt">17.05.27<span class="mk-w"></span></span>发布了页面：Developers Lab  计划  \n<span class="mk-dt">17.05.27<span class="mk-w"></span></span>将 我的工作室 页面更名为 MyStudio  \n<span class="mk-dt">17.05.27<span class="mk-w"></span></span>将 新的Blog 页面更名为 NewBlog  \n<span class="mk-dt">17.05.21<span class="mk-updt"></span></span>网易云音乐停止提供歌单音乐解析服务，所有音乐由 Sindex 播放  \n<span class="mk-dt">17.05.21±2<span class="mk-updt"></span></span>建立 Sindex 文件夹，用于存储备用的网易云音乐文件  \n<span class="mk-dt">17.05.20<span class="mk-w"></span></span>上传了 StdLib1.07 的宣传画(1pic)  \n<span class="mk-dt">17.05.20<span class="mk-w"></span></span>将 初始化17 页面更名为 17正在运行  \n<span class="mk-dt">17.05.20<span class="mk-w"></span></span>发布了 StdLib1.07pub  \n<span class="mk-dt">17.04.29<span class="mk-mtn"></span></span>进行了 1 次 zjw 常规备份  \n<span class="mk-dt">17.04.29±3<span class="mk-mtn"></span></span>未知维护  \n<span class="mk-dt">17.04.22<span class="mk-mtn"></span></span>截至此时，博文在 beta版本 中累计修订 213±2 次  \n<span class="mk-dt">17.04.22<span class="mk-w"></span></span>上传了 StdLib1.06 的宣传画(1pic)  \n<span class="mk-dt">17.04.22<span class="mk-w"></span></span>发布了 StdLib1.06puba1  \n<span class="mk-dt">17.04.21<span class="mk-w"></span></span>发布了 StdLib1.06pub  \n<span class="mk-dt">17.04.02<span class="mk-mtn"></span></span>截至此时，博文在 beta版本 中累计修订 200±2 次  \n<span class="mk-dt">17.04.15<span class="mk-mtn"></span></span>进行了 1 次 zjw 常规备份  \n<span class="mk-dt">17.04.15±10<span class="mk-updt"></span></span>建立 indexStd 文件夹，用于存储公开的网页文档、实验性项目、待应用的网页特效  \n<span class="mk-dt">17.04.02<span class="mk-w"></span></span>上传了 StdLib1.03 的宣传画(1pic)  \n<span class="mk-dt">17.04.02<span class="mk-w"></span></span>上传了 StdLib1.04 和 StdLib1.05 的宣传画(2pic)  \n<span class="mk-dt">17.02.19<span class="mk-w"></span></span>发布了 StdLib1.05pub  \n<span class="mk-dt">17.02.18<span class="mk-w"></span></span>发布了 StdLib1.04pub  \n<span class="mk-dt">17.02.02<span class="mk-mtn"></span></span>进行了 1 次 zjw 常规备份  \n<span class="mk-dt">17.02.02<span class="mk-mtn"></span></span>截至此时，博文在 beta版本 中累计修订 139±2 次  \n<span class="mk-dt">17.01.27<span class="mk-updt"></span></span>建立了ActionAi子文件夹，以存储一些网页特效  \n<span class="mk-dt">17.1.28<span class="mk-w"></span></span>发布日志：D78  \n<span class="mk-dt">17.01.28<span class="mk-w"></span></span>发布文章：新年快乐！  \n<span class="mk-dt">17.01.27<span class="mk-mtn"></span></span>进行了 1 次 zjw 常规备份  \n<span class="mk-dt">17.01.27±10<span class="mk-updt"></span></span>建立 ThaumyFiles 文件夹，以存储一些网页特效  \n<span class="mk-dt">17.01.26<span class="mk-mtn"></span></span>截至此时，博文在 beta版本 中累计修订 128 次  \n<span class="mk-dt">17.01.26<span class="mk-w"></span></span>将 欢迎页[向导] 更名为 欢迎页&主引导  \n<span class="mk-dt">17.01.26<span class="mk-w"></span></span>发布了 StdLib1.03pub  \n<span class="mk-dt">17.01.25<span class="mk-w"></span></span>发布了 StdLib1.03a2  \n<span class="mk-dt">17.01.21<span class="mk-w"></span></span>发布了 StdLib1.03a1  \n<span class="mk-dt">17.01.21<span class="mk-w"></span></span>发布 StdLib1.03beta（该版本的第一发布时间为17.1.20）  \n<span class="mk-dt">17.01.13<span class="mk-w"></span></span>将 工作室招募 页面更名为 我的工作室  \n<span class="mk-dt">17.01.12<span class="mk-updt"></span></span>添加插件：Crayon  \n<span class="mk-dt">17.01.12<span class="mk-updt"></span></span>更换博客主题从 personal 到 personal2.2，此时 press 版本为 4.7  \n<span class="mk-dt">17.01.07<span class="mk-w"></span></span>发布了 欢迎页[向导]  \n<span class="mk-dt">17.01.07<span class="mk-w"></span></span>发布了页面：初始化17  \n<span class="mk-dt">17.01.04<span class="mk-w"></span></span>将 我的工作室 页面更名为 工作室招募  \n<span class="mk-dt">17.01.01<span class="mk-w"></span></span>发布了页面：我的工作室  \n<span class="mk-dt">16.12.26<span class="mk-w"></span></span>发布了日志：D77  \n<span class="mk-dt">16.12.26<span class="mk-updt"></span></span>恢复了 www.thaumy.ml 和 cool.thaumy.ml 的域名解析  \n<span class="mk-dt">16.12.23<span class="mk-w"></span></span>发布了日志：B11  \n<span class="mk-dt">16.12.19<span class="mk-w"></span></span>发布了日志：B10  \n<span class="mk-dt">16.12.18<span class="mk-w"></span></span>发布了日志：D48 ，E48  \n<span class="mk-dt">16.12.17<span class="mk-w"></span></span>发布了页面：新的Blog  \n<span class="mk-dt">16.12.17<span class="mk-updt"></span></span>博客域名由 aumy.ml 更改为 thaumy.ml  \n<span class="mk-dt">16.12.17<span class="mk-updt"></span></span>更换虚拟主机服务商为 主机屋 ，博客进入 beta 版本  \n<span class="mk-dt">16.12.17<span class="mk-updt"></span></span>停用 hostinger 虚拟主机，alpha 版本结束\n\n## alpha 维护日志(凭借回忆建立的日志，信息非常模糊甚至错误)\n\n<span class="mk-dt">16.11.01<span class="mk-updt"></span></span>部分回忆报告说明这期间更换了 personal 主题，并且开启了 ajax ，使用 Qplayer 播放器  \n<span class="mk-dt">16.10.01<span class="mk-updt"></span></span>部分回忆报告说明这期间添加了网易云外链播放器  \n<span class="mk-dt">16.09.01<span class="mk-mtn"></span></span>博客长期处于停止更新状态  \n<span class="mk-dt">16.08.25<span class="mk-updt"></span></span>更新部分文章，配置插件，自定义模板内容等  \n<span class="mk-dt">16.08.15->25<span class="mk-updt"></span></span>使用 aumy.ml 作为博客域名，此时 press 版本为 4.5.?  \n<span class="mk-dt">16.08.15->25<span class="mk-updt"></span></span>博客建立，采用 hostinger 虚拟主机，使用未知主题，博客进入 alpha 版本	2019-11-02 19:09:23	2019-11-02 19:09:39	2019-11-02 19:09:39	12	WP_beta日志	1001
12388	<div class="all">\n<div class="about_title">\n\n<span style="font-size:1.5em;font-weight:600">THAUMY的博客</span>\n<br>\n<span style="font-size:1.3em;font-weight:400">基于pilipala构建</span>\n\n<div class="about_title_u2">\n\nThaumy's blog, based on pilipala  \n\n</div>\n\n</div>\n\n<div class="about_co">\n\n### <span style="color:#3690FF">版本信息</span>\n\n噼里啪啦 1.0 - 茜\n<span style="background:rgb(0 197 184);font-size:smaller;padding-left:3px;border-radius:3px;padding-right:3px;font-weight:500;color:snow;display:inline-flex;" class="bSha">Akane</span>\n\n<div class="about_co_u2">\n\n内核版本：<span id="ver">preview<span>\n\n</div>\n\n<img class="pilipala_logo" style="box-shadow:unset;" src="http://cdn.thaumy.cn/post/站点信息/关于博客/1_0/pilipala_2022.svg">\n\n</div>\n\n<div class="about_thanks">\n\n### <span style="color:#3690FF">鸣谢</span>\n<span style="font-size:12px;color:#53A0FE">(名称不分先后)</span>  \nZervan(内容勘误，参与测试)  \nHodpel(技术支持)  \n雅爱方雏(提供文案)  \n星魂w(参与测试)  \njss(参与测试)  \n\n### <span style="color:#3690FF">版权信息</span>\nThaumy的博客❤2016-2022  \nCC BY-SA 3.0  \nAll code under MIT license\n\n### <span style="color:#3690FF">支持</span>\n\n[FAQ](https://www.thaumy.cn/12489) | [维护信息](https://www.thaumy.cn/12376) | [赞助](https://www.thaumy.cn/12385)\n</div>\n\n</div>\n\n<style>\n    /* 屏幕宽度 [ 776 , + ) */\n    @media (min-width:776px) {\n        .pilipala_logo {\n            width: 280px;\n            position: relative;\n        }\n    }\n\n    /* 屏幕宽度 [ 539 , 775 ] */\n    @media (min-width:539px) and (max-width: 775px) {\n        .pilipala_logo {\n            width: 220px;\n            position: relative;\n        }\n    }\n\n    /* 屏幕宽度 [ 539 , + ) */\n    @media (min-width: 539px) {\n        .about_title {\n            width: 55%;\n            display: block;\n            float: left;\n        }\n\n        .about_co {\n            width: 45%;\n            float: right;\n            display: block;\n        }\n\n        .about_thanks {\n            float: left;\n        }\n    }\n\n    /* 屏幕宽度 ( - , 538 ] */\n    @media (max-width: 538px) {\n        .all {\n            text-align: center;\n        }\n\n        .pilipala_logo {\n            width: 180px;\n        }\n\n        .about_title_u2 {\n            font-size: 0.9em;\n        }\n\n        .about_co_u2 {\n            font-size: 0.9em;\n        }\n\n        .about_title {\n            width: 100%;\n        }\n\n        .about_co {\n            width: 100%;\n        }\n\n        .about_thanks {\n            float: unset;\n        }\n    }\n\n    #t-y,\n    #t-d,\n    #t-h,\n    #t-m,\n    #t-s {\n        font-size: 15px;\n        line-height: 30px;\n        background: rgba(0, 0, 0, 6%);\n\n        padding-left: 3px;\n        padding-right: 3px;\n\n        margin-left: 2px;\n        margin-right: 2px;\n        border-radius: 1px;\n    }\n</style>\n	2019-06-29 23:15:38	2022-07-12 22:12:56	2022-11-05 18:07:14	12	关于博客	1001
12398	<span style="float:right;" class="wd-dt5 cur" onclick="up();showPost(12376)">点此返回索引根目录</span>\n\n## public c2 维护日志(1710版本1)\n\n<span class="mk-dt">18.02.22<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">18.02.19<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">18.02.19<span class="mk-updt"></span></span>基于press的本博客停止了技术更新  \n<span class="mk-dt">18.02.19<span class="mk-w"></span></span>发布 博客重构计划EP03  \n<span class="mk-dt">18.02.09<span class="mk-updt"></span></span>基于ASP.NET技术的博客系统开始开发  \n<span class="mk-dt">18.02.09<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.12.16<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.12.16<span class="mk-mtn"></span></span>回收了 2 条次广告性评论  \n<span class="mk-dt">17.12.16<span class="mk-updt"></span></span>将评论框的 “您的昵称” 和 “您的邮箱” 输入栏宽度（width）由 80% 更改为 100%  \n<span class="mk-dt">17.12.02<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.12.02<span class="mk-updt"></span></span>发表了文章 Arduino单片机开发感想  \n<span class="mk-dt">17.12.02<span class="mk-mtn"></span></span>回收了 167 条次广告性评论  \n<span class="mk-dt">17.11.19<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.11.19<span class="mk-mtn"></span></span>删除了 1 条次 广告性评论  \n<span class="mk-dt">17.11.11<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.10.29<span class="mk-mtn"></span></span>回收了 68±20 条次 广告性评论（不完全统计）  \n<span class="mk-dt">17.10.15<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.10.29<span class="mk-w"></span></span>修改了 StdLib1.07#public更新日志 文章的宣传图片  \n<span class="mk-dt">17.10.29<span class="mk-mtn"></span></span>回收了 16 条次 广告性评论  \n<span class="mk-dt">17.10.21<span class="mk-mtn"></span></span>回收了 47 条次 广告性评论  \n<span class="mk-dt">17.10.15<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.10.15<span class="mk-updt"></span></span>更新了 博客音乐播放器歌单  \n<span class="mk-dt">17.10.15<span class="mk-mtn"></span></span>回收了 57 条次 广告性评论  \n<span class="mk-dt">17.10.08<span class="mk-updt"></span></span>博客已被百度收录\n\n## public c1 维护日志(1709版本1)\n\n<span class="mk-dt">17.10.04<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.10.04<span class="mk-updt"></span></span>维护日志头规则现已更新：红色为问题登记日志，绿色为修复日志，黑色为常规日志，蓝色为备份日志  \n<span class="mk-dt">17.10.04<span class="mk-w"></span></span>更改 MyStudio 页面名称为 工作室  \n<span class="mk-dt">17.10.04<span class="mk-w"></span></span>更改 NewBlog 页面名称为 关于博客  \n<span class="mk-dt">17.10.04<span class="mk-w"></span></span>将 DevelopersLab 计划 页面归档处理  \n<span class="mk-dt">17.10.04<span class="mk-w"></span></span>修订了 MyStudio 页面的内容  \n<span class="mk-dt">17.10.04<span class="mk-bug"></span></span>登记问题：音乐播放器部分歌曲无法加载，需要二次点击才能正常播放  \n<span class="mk-dt">17.10.04<span class="mk-mtn"></span></span>回收了 40 条次 广告性评论  \n<span class="mk-dt">17.10.01<span class="mk-mtn"></span></span>回收了 27 条次 广告性评论  \n<span class="mk-dt">17.09.24<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.09.24<span class="mk-updt"></span></span>删除了 博客垃圾文件及目录 ，优化性能  \n<span class="mk-dt">17.09.24<span class="mk-w"></span></span>删除了 20->30 条次 广告性评论  \n<span class="mk-dt">17.09.10<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.09.06<span class="mk-updt"></span></span>音乐播放器唱片上的唱臂图片 已更新为矢量  \n<span class="mk-dt">17.09.06<span class="mk-updt"></span></span>将 NewBLOG页面 中的 不满意处&(一月内) 栏目和 修复&Updt(一月内) 栏目合并为 DevUpdtLog#开发维护日志 栏目，并添加跳往博内页面 维护日志 的超链接作为内容  \n<span class="mk-dt">17.09.06<span class="mk-w"></span></span>删除了 2 条次 广告性评论 和 1 条次 测试性评论\n\n## public b3 维护日志(1708版本2)\n\n<span class="mk-dt">17.08.31<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.08.31<span class="mk-updt"></span></span>调整了 文章底部菜单 的 按钮顺序  \n<span class="mk-dt">17.08.31<span class="mk-updt"></span></span>对文章页的文章底部菜单的属性栏增加了图标  \n<span class="mk-dt">17.08.31<span class="mk-updt"></span></span>文章底部菜单增加标签属性  \n<span class="mk-dt">17.08.31<span class="mk-updt"></span></span>更新了 音乐播放器歌单  \n<span class="mk-dt">17.08.28<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.08.27<span class="mk-bug"></span></span>登记问题：音乐播放器的静音按钮只能为当前歌曲静音，在播放下一首歌曲时静音失效  \n<span class="mk-dt">17.08.27<span class="mk-updt"></span></span>取消了评论区 站点栏目 的填写  \n<span class="mk-dt">17.08.27<span class="mk-updt"></span></span>更改了评论区文字，将 评论 改为 留言  \n<span class="mk-dt">17.08.27<span class="mk-updt"></span></span>修改了 音乐播放器的 随机播放按钮 和 静音按钮 的大小  \n<span class="mk-dt">17.08.27<span class="mk-dbg"></span></span>修复了 在ie11环境下音乐播放器的随机播放按钮不显示的问题\n\n## public b2 维护日志(1708版本1)\n\n<span class="mk-dt">17.08.24<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.08.24<span class="mk-bug"></span></span>登记问题：在ie11环境下音乐播放器的随机播放按钮不显示  \n<span class="mk-dt">17.08.24<span class="mk-updt"></span></span>更改了音乐播放器 随机播放按钮和静音按钮的样式  \n<span class="mk-dt">17.08.24<span class="mk-dbg"></span></span>修复了 音乐播放器静音图标第二次点击后会出现字体丢失的问题  \n<span class="mk-dt">17.08.24<span class="mk-updt"></span></span>点赞心形按钮样式修改，已点赞的文章会显示红心  \n<span class="mk-dt">17.08.22->24<span class="mk-dbg"></span></span>修复了 文章底部菜单图标首次使用时，因hover图片加载过慢导致在hover图片加载完成前无图片可显示，形成类似闪烁的假象 的问题  \n<span class="mk-dt">17.08.23午->24早<span class="mk-bug"></span></span>受台风“天鸽”影响，博客无法访问  \n<span class="mk-dt">17.08.20<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.08.19<span class="mk-bug"></span></span>登记问题：文章底部菜单图标首次使用时，因hover图片加载过慢导致在hover图片加载完成前无图片可显示，形成类似闪烁的假象  \n<span class="mk-dt">17.08.19<span class="mk-dbg"></span></span>修复了 文章底部菜单图标在不同环境下实际占用空间不同导致显示不合理 的问题  \n<span class="mk-dt">17.08.16<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.08.15<span class="mk-dbg"></span></span>修复了 文章底部菜单图标高低不一致，并且使用不规范 的问题  \n<span class="mk-dt">17.08.15<span class="mk-updt"></span></span>文章底部菜单图标做部分重绘  \n<span class="mk-dt">17.08.13<span class="mk-updt"></span></span>置顶文章右上角的橙红小标志已更新为矢量  \n<span class="mk-dt">17.08.13<span class="mk-updt"></span></span>文章底部菜单图标做部分调整，并已更新为全矢量  \n<span class="mk-dt">17.08.09<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.08.09<span class="mk-updt"></span></span>更改了维护日志的登记问题日期头，由 y.m.dfound±int--register±int_ 简化为 y.m.d±int--r±int_  \n<span class="mk-dt">17.08.08<span class="mk-bug"></span></span>登记问题：博客未被百度收录  \n<span class="mk-dt">17.08.06<span class="mk-updt"></span></span>博客菜单栏已更新为全矢量\n\n## public b2 维护日志(1707版本2)\n\n<span class="mk-dt">17.07.28<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.07.25±5<span class="mk-updt"></span></span>博客已被百度收录  \n<span class="mk-dt">17.07.23<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.07.23<span class="mk-updt"></span></span>改用标准方法引入js&css  \n<span class="mk-dt">17.07.23<span class="mk-w"></span></span>上传了 StdLib1.08 的宣传画(1pic)  \n<span class="mk-dt">17.07.22<span class="mk-updt"></span></span>开始使用谷歌广告服务  \n<span class="mk-dt">17.07.21<span class="mk-w"></span></span>发布了 StdLib1.08pub  \n<span class="mk-dt">17.07.20<span class="mk-updt"></span></span>压缩了部分js以提升速度  \n<span class="mk-dt">17.07.20<span class="mk-updt"></span></span>博客签名新增打字效果  \n<span class="mk-dt">17.07.19<span class="mk-updt"></span></span>修改了 webkit环境下博客页面滚动条样式  \n<span class="mk-dt">17.07.19<span class="mk-updt"></span></span>修改了 评论区部分样式和文字  \n<span class="mk-dt">17.07.19<span class="mk-dbg"></span></span>修复了 评论区前三个信息框在手机浏览器查看时超出边界 的问题  \n<span class="mk-dt">17.07.18<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.07.18<span class="mk-dbg"></span></span>修复了 蓝线刷新条宽度与pjax的刷新区域Central不相等 的问题  \n<span class="mk-dt">17.07.18<span class="mk-bug"></span></span>登记问题：蓝线刷新条宽度与pjax的刷新区域Central不相等  \n<span class="mk-dt">17.07.17<span class="mk-updt"></span></span>将 闪烁加载图案 更换为 蓝色刷新条  \n<span class="mk-dt">17.07.16<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.07.16<span class="mk-updt"></span></span>博客由 ajax 转为 pjax 加载  \n<span class="mk-dt">17.07.16<span class="mk-updt"></span></span>停用了 Advanced AJAX Page Loader 插件  \n<span class="mk-dt">17.07.14<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份\n\n## public a3 维护日志(1707版本1)\n\n<span class="mk-dt">17.07.13<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.7.12<span class="mk-updt"></span></span>对国外访问进行特别优化，使用www.webpagetest.org进行优化测试  \n<span class="mk-dt">17.7.12<span class="mk-updt"></span></span>对部分js和css进行CDN加速  \n<span class="mk-dt">17.7.12<span class="mk-updt"></span></span>将 poi-player播放器音量减小至 20%  \n<span class="mk-dt">17.7.12<span class="mk-updt"></span></span>对部分影响速度的字体进行去本地化，转为CDN加速  \n<span class="mk-dt">17.7.12<span class="mk-updt"></span></span>半数资源SSL，提高安全性  \n<span class="mk-dt">17.07.11<span class="mk-mtn"></span></span>截至此时，博文在 public a2 版本 中累计修订 557±1 次  \n<span class="mk-dt">17.07.11±1<span class="mk-updt"></span></span>引用的外链js全部被压缩处理  \n<span class="mk-dt">17.07.11<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.07.11<span class="mk-w"></span></span>发布了文章：log17  \n<span class="mk-dt">17.07.11<span class="mk-w"></span></span>删除了页面：17 is running  \n<span class="mk-dt">17.07.10<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.7.10<span class="mk-updt"></span></span>废除数据仓库服务，停止其他项目在主机屋的运行  \n<span class="mk-dt">17.07.10<span class="mk-w"></span></span>修订页面 友情链接 计 37 次  \n<span class="mk-dt">17.07.10<span class="mk-w"></span></span>修订页面 NewBlog 计 35 次  \n<span class="mk-dt">17.07.10<span class="mk-updt"></span></span>通过调用 poi-player 的自身函数实现真正的音量下调到 20%  \n<span class="mk-dt">17.07.10<span class="mk-updt"></span></span>博客友链系统进行部分重新排版和样式修正  \n<span class="mk-dt">17.07.10<span class="mk-w"></span></span>发布了页面：维护日志  \n<span class="mk-dt">17.07.09±1<span class="mk-updt"></span></span>使用了极端的方法将 poi-player 播放器音量调整为 20%  \n<span class="mk-dt">17.07.08±1<span class="mk-updt"></span></span>停用 Qplayer 播放器，开始使用 poi-player 播放器  \n<span class="mk-dt">17.07.08<span class="mk-updt"></span></span>博客开放了友链注册  \n<span class="mk-dt">17.07.08<span class="mk-w"></span></span>发布了页面：友情链接  \n<span class="mk-dt">17.07.08±1<span class="mk-updt"></span></span>使用GitHub Pages作为CDN加速服务  \n<span class="mk-dt">17.07.08±1<span class="mk-bug"></span></span>登记问题：博客音乐自动换歌时会短暂播放上一首  \n<span class="mk-dt">17.07.08±1<span class="mk-bug"></span></span>登记问题：博客音乐播放器静音图标点击后样式发生错误  \n<span class="mk-dt">17.07.08<span class="mk-bug"></span></span>登记问题：在chorme环境下博客的图片、特效状态字体出现模糊  \n<span class="mk-dt">17.07.08<span class="mk-dbg"></span></span>修复了 ie浏览器中运行计时为0 的问题  \n<span class="mk-dt">17.07.07<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.07.07<span class="mk-mtn"></span></span>截至此时，博文在 public a3 版本 中累计修订 469 次  \n<span class="mk-dt">17.07.07±1<span class="mk-updt"></span></span>将 多媒体、脚本资源 外链引用自 github(raw开发模式)  \n<span class="mk-dt">17.07.07<span class="mk-dbg"></span></span>修复了 引用js时因为wp super cache插件的缓存问题导致错误引用 的问题  \n<span class="mk-dt">17.07.07±1<span class="mk-updt"></span></span>停用了Qplayer播放器  \n<span class="mk-dt">17.07.07±1<span class="mk-updt"></span></span>引用的js全部被压缩处理  \n<span class="mk-dt">17.07.07±2<span class="mk-updt"></span></span>压缩了部分图片，提升速度体验  \n<span class="mk-dt">17.07.04->07<span class="mk-w"></span></span>修订往期文章计 8 次\n\n## public a2 维护日志(pub1706版本7)\n\n<span class="mk-dt">17.06.26<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.06.18->19</span>修订往期文章计 18 次  \n<span class="mk-dt">17.06.18<span class="mk-w"></span></span>发布了文章：浅谈press数据库优化  \n<span class="mk-dt">17.06.17<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.06.17<span class="mk-mtn"></span></span>截至此时，博文在 public a2 版本 中累计修订 428 次  \n<span class="mk-dt">17.06.17±2<span class="mk-bug"></span></span>登记问题：ajax刷新后全部首页图片无法加载  \n<span class="mk-dt">17.06.17±3<span class="mk-dbg"></span></span>修复了 CNZZ无法正常统计 的问题  \n<span class="mk-dt">17.06.17±3<span class="mk-dbg"></span></span>修复了 进入博客时音乐卡顿 的问题  \n<span class="mk-dt">17.06.17±3<span class="mk-bug"></span></span>登记问题：加载首页有几率至少有一张特色图片无法加载  \n<span class="mk-dt">17.06.17<span class="mk-updt"></span></span>将博客数据库表 wp_post 删除了 33条 记录  \n<span class="mk-dt">17.06.16<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.06.16<span class="mk-updt"></span></span>为 thaumy.link & thaumy.ml 设置 database 记录，用于访问数据仓库  \n<span class="mk-dt">17.06.15<span class="mk-updt"></span></span>为 thaumy.ml 设置 datarep 记录，用于访问数据仓库\n\n## public 维护日志(pub1706版本5)\n\n<span class="mk-dt">17.06.14<span class="mk-mtn"></span></span>截至此时，博文在 public版本 中累计修订 361 次  \n<span class="mk-dt">17.06.14<span class="mk-w"></span></span>修订 欢迎页&主引导 计 6 次  \n<span class="mk-dt">17.06.14<span class="mk-w"></span></span>修订页面 NewBlog 计 4 次  \n<span class="mk-dt">17.06.14<span class="mk-w"></span></span>发布了文章：应用程序三层架构与MVC(文章摘要) ，修订计 5 次  \n<span class="mk-dt">17.06.13<span class="mk-mtn"></span></span>进行了 1 次 xvm 常规备份  \n<span class="mk-dt">17.06.09<span class="mk-mtn"></span></span>截至此时，博文在 public版本 中累计修订 343 次  \n<span class="mk-dt">17.06.09<span class="mk-w"></span></span>修订页面 NewBlog 计 8 次  \n<span class="mk-dt">17.06.09<span class="mk-w"></span></span>修订页面 Developers Lab  计划 计 5 次  \n<span class="mk-dt">17.06.09<span class="mk-updt"></span></span>删除了 NewBlog 页面中的 V_MENU 分栏  \n<span class="mk-dt">17.06.09<span class="mk-updt"></span></span>删除了 NewBlog 页面中的 LoginLogs 按钮  \n<span class="mk-dt">17.06.08<span class="mk-w"></span></span>修订页面 17 is running 计 5 次  \n<span class="mk-dt">17.06.08<span class="mk-mtn"></span></span>进行了 1 次 zjw 常规备份  \n<span class="mk-dt">17.06.07<span class="mk-w"></span></span>修订页面 NewBlog 计 3 次  \n<span class="mk-dt">17.06.07<span class="mk-updt"></span></span>删除了 NewBlog 页面中的 phpAdmin数据库管理系统 和 服务器文件管理系统 按钮  \n<span class="mk-dt">17.06.07±7<span class="mk-updt"></span></span>更换域名为thaumy.link  \n<span class="mk-dt">17.06.07±7<span class="mk-updt"></span></span>改thaumy.ml域名为闲置域名  \n<span class="mk-dt">17.06.07<span class="mk-updt"></span></span>更换虚拟主机服务商为 xvmhost ，博客进入 public 版本	2019-11-02 19:09:19	2019-11-02 19:09:35	2019-11-02 19:09:35	12	WP_public日志	1001
12390	最近经历了一场大病，导致博客持续停更。  \n不过目前已经康复，可能以后就不能熬夜写代码了......  \nThaumy再此提醒各位，要按时作息，早睡早起，好好吃饭多睡觉，这样才能多写代码多玩游戏（滑稽  \n由于上周第七步进没能更新，所以噼里啪啦的BETA7开发工作将提前到第七步进完成时（约七月十五日	2019-07-11 13:53:36	2019-07-11 13:53:34	2019-07-11 13:53:34	28	生病。。。	1001
12438	2020年12月12日15时52分，pilipala在linux环境下运行成功！	2020-12-12 15:55:37	2020-12-12 15:55:37	2020-12-12 15:55:37	28		1001
12479	# Pure Function\n\n纯函数\n\n## 概要\n\n纯函数的输出结果仅仅依赖于其输入值。\n\n## 介绍\n\n假如有这么一个函数\n\n```C\nint getSecond(){\n    ...\n}\n```\n\n这个函数能够返回现实世界中当前的秒数，比如现在是2021年6月11日20时59秒，那么这个函数就返回值59。\n\n显然这个函数它的输出结果不依赖于其输入结果，这样就可能产生问题，甚至是副作用。\n好比你的电脑的计时元件出了问题，那么这个函数就会输出不正确的结果...（当然这个例子并不好\n\n很典型的例子，取随机数函数就是一个非纯函数。\n\n下面给出几个纯函数的例子：\n\n```C\nint sum(int a,int b){\n    return a+b;\n}\n\nint get1(){\n    return 1;\n}\n```\n\n当然，成为纯函数的前提是你必须是一个函数，这就要求你无论如何都要有返回值，下面的喵喵喵函数就不是纯函数：\n\n```C\nvoid miaomiaomiao(){\n\n}\n```\n\n## Playground\n\n今天没有作业。\n	2021-12-15 22:56:14	2021-12-15 22:56:14	2021-12-15 22:56:14	12	Pure Function	1001
12495	> 寻找其他情报。\n\n- [x] 阶段0\n- [x] 阶段1\n- [x] 阶段2\n- [x] 阶段3\n- [x] 阶段4\n- [x] 阶段5\n- [ ] 阶段6\n\n- 泡影\n- 戴宝林\n- 金杖端\n- $_*\\ ^*\\ _*$\n\n`S1C` `不夜咲` `10-25-08` `2024的二分之一`\n\nnanako\n\n	2022-02-08 12:59:07	2202-06-18 06:00:00	2202-06-18 06:00:00	12	线索	1001
12478	# Polish Notation\n\n波兰表示法\n\n## 概要\n\n**波兰表示法**是把运算符置于操作数前的算术表示法，与逆波兰表示法一样，同样可以消除对括号的需要。虽然该表示法同样容易被算法实现，但多应用于学术范畴而非计算器中。\n\n## 介绍\n\n由于你已经了解了RPN，此处直接给出的PN表达应该是易于理解的，例如：\n\n`2 - 1` 表示为 `- 1 2`  \n`2 / 1` 表示为 `/ 1 2`  \n`1 - 2 * 3` 与 `- 1 * 2 3` 等效\n\n波兰表示法（PN）与逆波兰表示法（RPN）的表达规则是相反的。根据运算符位置的不同，我们将表示法分为**前缀**、**中缀**和**后缀**。容易想到，PN和RPN分别是前缀表示法和后缀表示法的别称。我们日程生活中使用的是中缀表示法。\n\n波兰表示法同样适用于栈基解析，从右至左观察表达式，规则如下：\n\n1. 如果遇到操作数，压入栈中。\n2. 如果遇到运算符，从栈中弹出相应的操作数，计算后压入栈中。\n\n重复上述规则直到栈元中仅剩下一个元素，即为结果。\n\n尽管前缀表示法并不常见于计算器实现，但我们仍然能够实现它：\n\n```Haskell\nparser "+" (x : y : s) = (x + y) : s\nparser "-" (x : y : s) = (x - y) : s\nparser "*" (x : y : s) = (x * y) : s\nparser "/" (x : y : s) = (x / y) : s\nparser " " s = s\nparser x s = (read x) : s\n\ncalc e s = head $ foldr (\\x acc -> parser x acc) s (words e)\n\nmain = do\n  putStrLn . show . calc "- * / 15 - 7 + 1 1 3 + 2 + 1 1" $ [] -- 5.0\n```\n\n你可能已经注意到了，相较于RPN版本，上述代码只是反转了解析方向和作用顺序而已。\n\n## Playground\n\n没作业。\n	2021-12-15 22:55:56	2021-12-15 22:55:56	2021-12-15 22:55:56	12	PN	1001
12452	# 2021苹果全球开发者大会概要\n\n## iOS15\n\nLiveText（三端均有，图片文字识别功能  \n地图更新（国内感知不强  \n钱包更新（国内感知不强  \nMusic更新\n\n## AirpodsPro\n\n功能性增强（如残障支持\n\n## iPadOS15\n\n多任务（应用分屏  \nQuickNote应用（笔记软件  \nTranslate应用（翻译软件  \nSwiftPlayground（代码学习工具\n\n## tvOS相关\n\n感知不强\n\n隐私保护：  \nMail应用隐私控制  \nSafari隐私控制  \nApp隐私报告（类似小米  \nSiri语音数据本机处理以强化隐私  \niCloud数字遗产计划（没听讲。。。\n\n## iCloud+\n\nSafari全匿名访问（利用Apple中继服务器转发http请求以杜绝web站点对源地址的追踪，类似于Tor  \nMail随机邮箱（一次性邮箱地址，随用随删\n\n## 健康相关\n\n睡眠质量、指标检测、健康共享等，功能感知弱（健康共享可以实时查看家人健康状况，如最近一分钟的心率变化。。。\n\n## watchOS8\n\n看图提神功能（？？？  \n呼吸、健康、锻炼等等  \nApple Fitness+（健身课程  \n人像表盘  \n全新照片app  \n支持GIF图  \n天气  \n多计时器\n\n## HomeKit\n\n感知不强\n\n## macOS12 :: Monterey\n\nUniversalControl（MacBook/iMac控制iPad、iMac  \nShortcuts（系统级快捷键自定义！  \nSafari重构（好看！  \n为开发者提供的一大堆API  \nSwift新特性：aysnc/await/actor关键字（aka并发编程  \nXcodeCloud（云编译、云测试、CI/CD\n\n---\n\n### 总结\n\n这次发布会没有新mbp14/16，亏我认真听了这么长时间。。。其实我早就注意到了，发布会放了一个半小时多了都还没有出现新设备的操作演示，WWDC19的时候早就出现在新硬件上的演示了。。。挺失望的，又要等大半年了\n	2021-06-08 02:58:00	2021-06-08 03:00:00	2021-06-08 03:00:00	12	WWDC21	1001
12454	# 每月评论\n\n> 每月评论 - 第六期\n\n* 受限于各类因素，每月评论今后将按需发行。\n\n---\n\n## 近期提要\n\n### 三月概要\n\n&emsp;&emsp;开学了，这个学期的课非常非常非常多。我不能同时将编程学习和学校课程放在同一个地位上了，因为这样后者简直是个内卷的无底洞。学习了F#。\n\n### 四月概要\n\n&emsp;&emsp;调整了一下学习策略，非专业课程全部纳入按需学习范畴。换句话说，能不学就不学，尽量把水课内容推迟到最后以节约时间（~~我称之为“惰性求值”~~）。空缺出的时间主要进行有关于计算机网络（读CNATDA）以及函数式编程方面的学习，还包括一些小的开发项目。\n\n### 五月概要\n\n&emsp;&emsp;和上个月一样。\n\n### 六月概要\n\n&emsp;&emsp;前两周大体和上个月一样，此时CNATDA基本读完，Haskell学习收尾。受雅爱方雏启发，自6月7日起利用闲暇时间写一些文章给水瓜大学科普顺便进行自我提升。后两周的时间进行渐进式课程复习以应付期末考试。\n\n### 七月概要\n\n&emsp;&emsp;考试周。复习和摸鱼交替进行，懒得睡的时候偶尔会学到一两点（高数什么的实在太难了）。因为学习强度太高，再进行技术提升的话我真的受不了（头痛），所以这个月基本没怎么学习新的技术了。用最少的时间避免了挂科。7月16日后是假期时间：写文章、科目三、更新博客系统交替进行。\n\n## 环境依赖去中心计划\n\n&emsp;&emsp;受到一些事件的启示和对技术原理的了解，我越发觉得网络是一个可怕的东西。随便封禁一个账户就能对真实的个人产生巨大的影响，或从社工/人肉角度对真实的个人产生巨大威胁。当前的互联网已经与个人实体高度绑定，而且我们没有去绑定的权力。早在两年前我就在博客发表了类似的看法，但在最近我才极其强烈地感受到它带来的制约。\n\n&emsp;&emsp;自六月中旬我开始重整个人的整个社交体系，这包括一系列可能在人看起来难以理解的做法（账户职能分离、数据抹除、严格权限以及去组织关联）。\n\n&emsp;&emsp;我觉得每个人都有权在网络保持沉默，但实际情况是如果不在网络留下什么大家会觉得你有问题。\n\n&emsp;&emsp;我能更加专注于想做的事情，并无法想象曾经的自己在无用的社交媒介上究竟获取到或制造了多少垃圾信息。\n\n## 立一些假期Flag\n\n1. 精通正则表达式读完前300页（因为对我而言之后的内容鲜有阅读价值）。\n2. 数据结构读完前200页，余下的交由下学期完成。\n3. 达成40篇瓜大计算导论的编写。\n4. 补番两部。\n\n---\n\n## 杂事\n\n> 本板块用于记录一些有的没的。\n\n* 最近对博客内核上做了一些修改，性能大概有百分之二十的提升（得益于惰性求值访问器、哈希基缓存和内存表）。\n* 不知道新Macbook Pro会不会在9月发布会发布，很期待。\n* 大概是五月吧，我的播放器坏了（洗衣服时进水了），这导致我没法欣赏hires音源了。\n\n---\n\n&emsp;&emsp;Stay Hungry, Stay Foolish.\n\n---\n\n<div align="right">\n\n每月评论 - 2107期(共6期)  \n撰稿&校对&审核：Thaumy\n\n</div>\n	2021-08-10 13:39:57	2021-08-10 13:40:31	2021-08-10 13:40:31	12	每月评论2107	1001
12502	# 近日概况\n\n连续高强度写了两个月的代码，整个人都不好了。\n\n本来还想发几篇博文，结果全烂在手里了。一想到最近全在写代码，就连七八月评论也没法写了，还不如把git提交记录粘上去呢！  \n几乎是除了吃饭睡觉就是写代码，开发任务挤满了我的全部时间，但即便如此，所做的还是达不到所想要的。  \n\n新博客大概要拖到年底发布了，我总是对自己的开发进度给予了太高的期望。不过在那之前，应该是还要把压箱底的几篇博文登上来的。\n\n搞了快半年的噼哩啪啦内核终于写个差不多了，剩下的部分都是些边角料工作，随时都能完成的。测试了下性能，很符合我的期望。要知道这一代的内核可拓展性实在是太强了，我还需要写其他的插件和服务之类的东西才能把额外的噼里啪啦功能驱动起来，不过我估计这些都要推到寒假了。但到那时候我的理论也快应用完了，又是需要学习的时候，之后还要找工作，烦。\n\nPalang被我从内核砍出来了，作为噼哩啪啦服务单独拿出来用，要知道这玩意可是设想拿来做后台基础设施的，固然要设计的十分完善。但是新内核加的一大堆特性直接让我一年前精心设计的语言草案过时了，前一阵子改了又改，目前是一团糟。我想，设计语言这种东西还是等到我看完编译原理再来搞吧。jiligulu后台的对接就弄成gRPC好了，UI就拿老的凑合用。\n\n不过说到UI，最近重构的Field直接让我的发布计划无限延期了。本来寻思着把V3拿出来用vue的SFC重构一下，顺便糊上vuetify节省工作量。谁知vuetify实在太好看了，和老Field怎么看怎么不搭，于是就试着把老UI再改改，结果越改越好看，搞笑的是有些组件的设计居然比vuetify还好看，弄得vuetify又不搭了。于是近日在研究怎么定制vuetify主题，但由于我这个人不喜欢用老技术，于是重构时的技术选型定到了vue3+vuetify3+vite+stylus+ts，结果在查找问题的时候全是vuetify2+webpack的参考，有些东西去issue里一看人家直接说不支持，弄的我一个v-switch大小调节搞了一天（没错，整整一天）都弄不出来，最后竟是强制相对定位加缩放变换才调到我所合适的样子，我早该这么干的，不过谁知道我竟只能这么干！哦对了，我是在说我最近在定制vuetify主题对吧？我看了下vuetify那堆文档，发现他们所谓的主题仅仅就是改改样式表，根本不能做到像素级定制。由于vuetify之前一直是我拿来快速糊屎用的framework，这次一深度定制就体会到它的局限了，然后我就产生了一个邪恶的想法：既然SFC这么直观，那我拿它造一个自用的UI框架岂不是太简单？名字我都想好了，就叫FieldUI嘛！然后自己想怎么搞就怎么搞，各种平台一把梭哈，简直美滋滋。但我是在写网页诶，为了写个博客主题就整那么大个轮子，实在是不值当，何况有些技术方案都等待主题完工后才能定型，要我等到什么时候！不过说真的，它已经被加到我的轮子列表里了，做梦的屋子还是有的。\n\n扯的有点长了，目前来看进度还是比较可观的，新评论区的设计还没定型，一直改来改去的也很耗费时间。我打算把这部分先砍掉，然后把其他部分补好，到时候主题和内核的对接工作一完成，博客就可以发布了。这个流程大概还要耗时一个月左右，是个不小的工程，但对其他设计是有加速作用的。评论的功能内核是有的，想写我套个老UI也不是不能成，但那样有点难看。这次的工作和以前不同了，beta8那会是有UI没功能，现在是有功能没UI，任务还是要轻的。\n\n粗略算了下，内核和我写的各种依赖，在加上我开发的各种插件啊，这些后端的东西（还没写完）就已经五六千行了，估计真正释出用例的时候，代码怎么说也得一万起步吧，全套完整实现应该不会超过两万行，这可能是我的第一个万行工程了。之前写的beta5还是6还是7我忘记了，有个版本的代码量是七八千行还是五六千行的，那应该是我写过的最多代码的项目，不过全是屎就是了。\n\n代码如诗。\n\n文是昨天晚上写的。  \n今天早上起来莫名的兴奋，想起来原来是昨天梦里梦到F#的RFC1043通过了。\n	2022-08-24 09:54:51	2022-10-02 17:40:01	2022-08-24 09:54:51	12	近日概况	1001
12504	欢迎来到"THAUMY的博客"的**测试预览站**~  \n你可以在这里看到所有即将发布的内容，包括但不限于技术，欢迎通过各种形式反馈任何问题！  \n	2022-10-02 17:43:13	2022-10-02 17:43:15	2022-10-02 17:43:16	12		1001
12434	近期正在对pilipala内核进行基准测试，以对新的内核版本进行性能剖析和排除潜在bug	2020-10-26 16:44:34	2020-10-26 16:42:20	2020-10-26 16:42:20	28		1001
12503	# 言论\n\n《将苑·卷一·智用》\n>天作时作而人不作，是谓逆人。\n\n《孤独摇滚！》\n>抛弃个性，和死亡等价\n\n《乒乓》\n>我只要快乐就好，只要有意思就足够了，我不想为了胜利而牺牲什么，也不想拉别人下马\n\n《Lycoris Recoil》\n>只有没半点长处的家伙，才会对自己的定位感到自豪\n\n网友\n>如果周围的人表情凝重，或许还有一线希望；如果周围的人鼓掌叫好又叫，也许变革就快来了。可图里的人群就像鲁迅写的"颈项都伸得很长，仿佛许多鸭，被无形的手捏住了的，向上提着"‥‥‥\n\n网友\n>知识改变命运，有钱不用改。\n\n网友\n>我支持共产主义是因为我是红三代，你支持共产主义是因为幻想。我们之间的阶级差太多了。\n\n---\n\n鲁迅\n>从来如此，便是对么？  \n\n网友\n>或若不对，但如此可保平安\n\n---\n\n孔子\n>逝者如斯夫，不舍昼夜。\n\n网友\n>世界是一个个封闭的圈层，因人适配的谎言包围着我们。\n\n左宗棠\n>说硬话，办软事，乃误国之贼。\n\n葛易\n> 永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功，苦难不值得追求，磨练意志是因为苦难无法躲开。\n\n---\n\n罗素\n> 如果一听到一种与你相左的意见就发怒，这表明，你已经下意识地感觉到你那种看法没有充分理由。如果某个人硬要说二加二等于五，你只会感到怜悯而不是愤怒。\n\n>所谓幸福的生活，必然是指安静的生活，原因是只有在安静的气氛中，才能够产生真正的人生乐趣。\n\n>不要为自己持独特看法而感到害怕，因为我们现在所接受的常识都曾是独特看法。\n\n>人的情绪起落是与他对事实的感知成反比的，你对事实了解得越少，就越容易动感情。\n\n>这个世界的问题在于聪明人充满疑惑，而傻子们坚信不疑。\n\n>放弃自己想要的某些东西，是幸福生活不可或缺的一部分。\n\n---\n\n2022-3-1\n>金子不会发光\n\n《三体》\n>弱小和无知不是生存的障碍，傲慢才是!\n\n薛定谔\n>生命以负熵为食\n\n《咒术回战》\n>枕边脱落的头发变多了，喜欢吃的夹心面包从便利店消失了，这些小小的绝望堆彻起来，才会让人长大。\n\n2021-9-15\n>感情是熵\n\n《新华词典》\n>张华考上了北京大学；李萍进了中等技术学校；我在百货公司当售货员：我们都有光明的前途。\n\n唐纳德·克努特\n>过早的优化是万恶之源\n\n《乒乓》\n>比乒乓更广阔的，是人生。\n\n《小魔女学园》\n>没有什么比梦想更能创造未来,  \n没有什么比口袋空空更能使人冒险,  \n有没有常识与有没有教育无关,  \n想知道革命的意义是什么，就称之为进步,  \n想知道进步的意义是什么，就称之为明天。\n\n艾米莉·狄金森\n>我本能忍受黑暗，如果我未曾见过光明。\n\n查尔斯·布考斯基\n>一天不独处，我就会变得虚弱。我不以孤独为荣，但以此维生。\n\n亚瑟·查理斯·克拉克\n>真正先进的技术，看上去都与魔法无异。\n\n网友\n>迟到的正义绝非真正的正义。\n\n《我不是药神》\n>我卖药这么多年，发现这世上只有一种病，穷病。这种病你没法治啊，你也治不过来。\n\n2020-1-21\n>做一个强奸现实的人\n\n《我是谁：没有绝对安全的系统》\n>敢做就能赢\n\n《彩虹六号》\n>坐而言不如起而行。\n\n2017-10-4\n>为自由而牺牲自由。\n\n《欢迎来到实力至上主义的教室》\n>深藏不露是一种卓越的才能。\n\n网友\n>启蒙导致愚昧，知识带来无知。\n\n《论语》\n>志不同，道不合，不相为谋。\n\n2016-5-9\n>学无止，思无界，行无疆。\n	2022-10-18 00:23:35	2022-10-18 00:23:38	2022-11-22 17:09:09	12	言论	1001
12377	> 历经三个开发版，我们推出了极具运行效能的噼里啪啦博客系统，第六开发的新特性非常多，严谨的逻辑使它成为高速博客系统的不二之选。\n\n## <font color="DarkTurquoise">PILIPALA第六开发版（PILIPALA Beta6 LTS）</font>\n\n* 应用了第三代对象式架构，将整个网站系统的耦合度显著降低，极大地避免了各部分的彼此牵连，并降低了逻辑复杂度。\n* 提供了主题编写支持，用户可以根据需要自行编写主题、更改网站样式。\n* 采用主页映射，将站点首页映射到启动页，利于简化链接复杂度。\n* 废除webio（网页IO桥），全局数据处理部署于webservice，简化了数据操作逻辑。\n* 去除了服务端ajax支持，因为它会大幅提升现有架构复杂度。\n* 该版本使用WebApplication代替WebSite建筑，因为前者提供了更佳的MSBuild支持。\n\n## <font color="DarkTurquoise">氛元素主题190213（fen）</font>\n\n* 提供了基于JQuery的Ajax支持，减轻了服务端业务压力，无刷新加载提升了用户体验。\n* 响应式网页设计使得氛元素主题能兼容任何屏幕规格的浏览设备，移动端最佳的浏览设备为 iPad Pro，桌面端最佳分辨率为1080p。\n* 为第三代对象式架构提供了UI及命名支持，优化了css分类。\n* 数据层操作全部移交服务端，提升了安全系数。\n* 删除了ReadOnly条带，因为该样式不利于数据层整合。\n* 半透明的UI设计，与背景图搭配提升了浏览体验。\n* 新增功能：点击头像可返回首页，推进式加载按钮可用（该按钮有利于减轻服务端数据库遍历压力）。\n\n## <font color="DarkTurquoise">StudioLibrary1.14LTS的全面支持</font>\n\n* 名称缩写由StdLib（已经使用了3年）展写为StudioLibrary，缩写为SL。\n* 重构的FutabaRio架构对日益增长的业务负担提供了更易理解的命名空间工作分配。\n* 新增的nsguide.cs文件描述了各个命名空间的父子关系，并在此对命名空间作集中注释，利于代码的简明。\n* 删除了实际应用不大的exe文件运行类、PixelGraphic转码类（提供了一种基于图形和16进制的加密算法）、ArrayAlgorithm算法类（提供了一种基于矩阵的加密算法），这有利于SL的业务专注。\n* Sql参数化查询结构、Sql连接签名结构、Sql查询描述结构、Xml节点描述结构重新命名，部分内置访问器优化，使得开发更加高效。\n* 噼里啪啦命名空间全部重构，应用了第三代对象式架构以全面兼容palaDB，使其完全脱离业务实现架构束缚，为开发及向后兼容与维护提供便利。\n* 采用大量接口约束噼里啪啦方法与结构，明确了各个方法的分工和彼此联系。\n* 删除了暂时没有开发价值的多线程操作类，因为应用这一操作类会为线程操作带来不必要的逻辑负担。\n* 优化注释内容，注意到//行注释不够精准严格，因此新增的代码注释全部采用了/*  */块注释。\n\n## <font color="DarkTurquoise">palaDB全部重构</font>\n\n* 文本数据采用三分库设计（灵感来源于AKG K3003），达到了逻辑简明与业务高效的完美契合。\n* 删除原有palaRoot（根级数据表）和palaUser（用户数据表），两者精简后兼为一表，提升了数据整合度。\n* 视图部分全部重构，对StudioLibrary对象式架构提供基层支持\n* 数据库函数大量精简，采用父子级和归类查询思路，简洁明了的函数设计很好地提升了开发效率。\n	2019-03-09 22:49:33	2019-04-14 06:08:43	2019-04-14 06:08:43	28	噼里啪啦第六开发版现可用	1001
12364	&emsp;&emsp;最近研究了一下递归，在这里阐述一下自己的理解。  \n\n<ul>\n \t<li><span style="color: #ff9900">我的看法</span></li>\n</ul>\n\n&emsp;&emsp;<a href="http://baike.baidu.com/link?url=vtnjbv5K54Ch9hn9Qi1duM-ucK3_LSjN9TMNeykQpAIA_uLxX8W-naC2yCG78UFCq3eTQl1y74EwqM8E9LlfcmljplvFblihQOquWIlxFra">递归</a>是一种可靠的编程范式（除了某些情况下滥用递归会导致爆栈）。递归的基本思想是通过程序不断调用自身来解决所需解决的问题。这是一种很聪明的解决思路，并且还会减少代码量，使程序更加简洁。\n\n<ul>\n \t<li>百度百科上的解释</li>\n</ul>\n\n&emsp;&emsp;程序调用自身的编程技巧称为递归 (recursion) 。递归做为一种<a href="http://baike.baidu.com/item/%E7%AE%97%E6%B3%95">算法</a>在<a href="http://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序设计语言</a>中广泛应用。 一个过程或<a href="http://baike.baidu.com/item/%E5%87%BD%E6%95%B0">函数</a>在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的<a href="http://baike.baidu.com/item/%E8%AF%AD%E5%8F%A5">语句</a>来定义对象的<a href="http://baike.baidu.com/item/%E6%97%A0%E9%99%90%E9%9B%86%E5%90%88">无限集合</a>。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。\n\n<ul>\n \t<li><span style="color: #ff9900">构成</span></li>\n</ul>\n\n&emsp;&emsp;递归，顾名思义：传递——回归。我们在这里用一个简单的例子了解递归的基本思路。\n\n<pre>C#<code>\nclass Program1\n{\n    static void Main(string[] args)\n    {\n        for (int row = 1; row <= 9; row++)\n        {\n            for (int i = 1; i &lt;= row; i++)\n            {\n                Console.Write("{0}*{1}={2}", row, i, row * i);\n                Console.Write(" ");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n</code></pre>\n\n&emsp;&emsp;上面是使用传统模式打印99乘法表的代码，它采用了两个嵌套的for循环实现。一个循环负责横行，另一个则负责纵行。这里不过多介绍。\n\n<span style="color: #ff9900">我们再来看看下面的代码：</span>\n\n<pre>C#<code>\nclass Program2\n{\n    static void Main(string[] args)\n    {\n        multiplication(9);\n    }\n\n    public static void multiplication(int i)\n    {\n        if (i == 1)\n        {\n            Console.WriteLine("1*1=1 ");\n            Console.WriteLine();\n        }\n        else\n        {\n            multiplication(i - 1);\n            for (int j = 1; j &lt;= i; j++)\n            {\n                Console.WriteLine(j + "*" + i + "=" + j * i + "  ");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n</code></pre>\n\n&emsp;&emsp;这是使用递归来输出99乘法表的代码。与嵌套for循环相比，它只使用了一个for循环来达到输出的目的，而初始结果直接打印 “1*1=1” 的字符串。这看起来有些不可思议：它是怎么做到的？\n\n<ul>\n \t<li><span style="color: #ff9900">分析</span></li>\n</ul>\n\n&emsp;&emsp;在上面的两篇代码中，分别使用了不同的方式达到相同的目的。嵌套for过于简单这里不解释，递归则是通过不断调用自身达到最终目的。\n\n<span style="color: #ff9900">在这里，递归分为两个部分。我将他概括为初始化和返回:</span>\n<ol>\n \t<li><span style="color: #3366ff">初始化</span>：程序不断调用自身的方法，我们把调用方法这个行为看作是初始化：为接下来的循环做准备。</li>\n \t<li><span style="color: #3366ff">返回</span>：每次初始化都会进行判断，当某次初始化后的判断成立时，程序不再调用自身<span style="color: #ffcc00">(也就是达到了所谓的递归边界准备返回结束)</span>，并且结束当前方法，进行返回。返回后执行的便是上一个(父级)方法初始化完成后下面的代码：循环输出。因为每次初始化的传参都不一样并且有大到小，所以在此过程中，循环可以由小到大依次输出乘法表。</li>\n</ol>\n<span style="color: #ff9900">可能这样讲解还是有些模糊，于是我画了一幅图增进我的理解：</span>\n<img src="https://cdn.thaumy.cn/old_post/33cfb.jpg" width="60%">\n\n&emsp;&emsp;图这里使用的是33乘法表进行分析，可以看到它分为两个部分：执行和回溯，也就是我说的初始化(调用)和返回。\n\n<ul>\n \t<li><span style="color: #ff9900">总结</span></li>\n</ul>\n\n&emsp;&emsp;我其实对递归还是一知半解的，希望这次学习能够对我在算法研究领域添上一臂之力(上次研究归并算法的时候没少吃苦头。。。)，所以呢，这里就结束啦~！\n\n<img src="https://cdn.thaumy.cn/old_post/dgmb.jpg" width="20%">	2017-07-11 03:10:51	2017-07-12 10:13:06	2017-07-12 10:13:06	28	对递归的一些研究	1001
12415	<span style="float:right;" class="wd-dt5 cur" onclick="up();showPost(12387)">转到“我”</span>\n\n# <span class="wd-heimu">孤僻内向的大病娇</span>\n\n> 此设定适用于《东联往事 · 卷Ⅱ : 人类量产计划》的前半部分章节，设定不适用于所有量产阶段的Thaumy。\n\n## <span class="wd-dt4">P1</span> <span style="color:#48D1CC">基本设定</span>\n\n&emsp;&emsp;很少和陌生人交谈来往。  \n对于他人的主动接触显得十分敏感（尤其异性），不会主动透露自己的兴趣爱好（如果不被主动询问或者有特殊情况的话）。  \n&emsp;&emsp;好胜心较强，与更优秀的人接触时有机率触发阴谋论心理（自动将对方的一切行为脑补成与自己敌对的战略举措），并且表现得极为冷漠。  \n&emsp;&emsp;心情不好时会发生黑化反应，将解决目前问题列为最高优先级，此期间会丧失基本人格。遇到高兴的事情时黑化会慢慢解除，表现为乐于或主动和较为熟悉的人交流（陌生人介入的最佳时机）。\n\n## <span class="wd-dt4">P2</span> <span style="color:#48D1CC">设定详情</span>\n\n### <span style="color:#9ACD32">性格表征</span>\n\n&emsp;&emsp;适用于基于ThaumyNERVSYS的pH调节系统触发器：  \n当看到比自己优秀的人的时候，Thaumy倾向于表现出批判面，认为该人一无是处（并认为其擅长的方面没有应用价值），并造成Thaumy体内的氢离子浓度上升。  \n\n&emsp;&emsp;心情不好时会降低做任何事情的积极性，且懒于说话。主动回避与自己作风完全相反的人（必须是很完全时才会触发）。  \n\n&emsp;&emsp;不乐意在他人面前展示自己优秀的一面，但是如果对其进行主动试探，Thaumy绝对会毫不保留的把他知道的全告诉你。。。  \n\n> 社交准则1：由于 A.T. FIELD 的作用，和Thuamy进行谈话时必须表现出主动。Thaumy表现出的冷淡是他想继续交流的最好证明。（该社交准则不适用于于Thaumy性格匹配度低于30%的人）\n\n> 行为学表征1：当持续进行Thaumy极感兴趣的话题时，Thaumy会表现出身体发抖，感觉很冷的症状。\n\n### <span style="color:#CC3300">履历&档案</span>\n\n代号：Thaumy  \n<span class="wd-dt4">C31识别码：17A2EF1G1C0536</span>\n\n事务机构：  \n\n### A&M（阵方互联）\n<img width="300px" src="<{cdn_root}>/md-img/am_logo_1810.svg">\n\n### H2OMSOCIE（水瓜社）\n<img  width="300px" src="<{cdn_root}>/md-img/h2om_logo_1907.svg">\n\n### Community31（31学社）\n<img  width="300px" src="<{cdn_root}>/md-img/c31_logo_1802.svg">\n\n### 生理学采样报告：未公开  \n\n来自水瓜社的数据：\n水瓜标准基金委员会成员  \n水瓜常任委员会成员  \n\n来自阵方互联的数据：  \n此项目需要K1级别读取权限。您的设备不具备该许可级别。  \n来自C31的数据：  \n此项目需要F1级别读取权限。您的设备不具备该许可级别。  \n\n### <span style="color:#FF8C00">兴趣爱好</span>\n\n画画  \n打代码  \n某些设计  \n听歌（ACG）  \n\n# SP：其他属性\n\n### <span style="color:#48D1CC">十分差劲的全栈</span>\n\n&emsp;&emsp;在建模、板绘、视频、音乐、编程、硬件、艺术设计等领域都有不同程度的涉猎，<span class="wd-heimu">有了搜索引擎的支持</span>，Thaumy可以短时间内在任何一方面按需做出自己满意的作品。<span class="wd-heimu">某孙子王也是</span>\n\n### <span style="color:#48D1CC">与生俱来的强迫症</span>\n\n&emsp;&emsp;即使一个像素点的差别，Thaumy也会尽可能地考虑到它出现的合理性。这样的性格特点让使得Thaumy过分地注重细节，宁可用过低的时效比换取自己满意的成果。\n\n### <span style="color:#48D1CC">我是一位艺术家</span>\n\nThaumny总是有着独到的见解。丰富的想象力和大胆的尝试让理想和现实达成共识。\n>编程是门艺术，而我，是艺术家————Thaumy\n\n### <span style="color:#48D1CC">24x7x365宅</span>\n\n&emsp;&emsp;说到宅，没人能比得上Thaumy。————不应过多解释，这是公认的事实。  \n&emsp;&emsp;但是基于最新的数据表明Thaumy貌似想要出去看看这个世界。\n	2020-03-11 11:37:03	2020-07-29 19:53:37	2020-07-29 19:53:37	28	Thaumy人设5 (雅爱方雏编)	1001
12431	CommentLake是一款适用于pilipala的评论系统，目前尚处于测试阶段。此文章为测试而生。	2020-09-27 15:51:52	2020-09-27 15:52:44	2020-09-27 15:52:44	28	CommentLake测试	1001
12505	# 每月评论\n\n> 每月评论 - 第十一期\n\n* 受限于各类因素，每月评论将按需发行。\n\n---\n\n## 新学期\n\n&emsp;&emsp;已经是大三的学生了啊。\n\n## 测试站点已启用\n\n&emsp;&emsp;THAUMY的博客现已推出[测试站点](https://next.thaumy.cn/)!  \n&emsp;&emsp;与主站(www)不同，测试站点的主要工作是技术验证。你可以在那里查看本博客即将推出哪些新功能或是修复，也可以看到未来计划推出的博客文章。  \n&emsp;&emsp;目前，主站点仍停留在pilipala beta9，这是因为新版本的pilipala还没有准备好，我们仍需对它进行一系列可用性评估，以确保其稳定使用。\n\n## 乱序评估\n\n&emsp;&emsp;疫情也好，战争也罢，什么人权啊自由啊，在我看来都变得越发无聊了。  \n&emsp;&emsp;这个世界如此丰富多彩，有那么多没有体验过的东西，也都与我无关。  \n&emsp;&emsp;我喜欢一句话：“专业的事应该交给专业的人去做”。受限于教育和经济，也有很多人拿着仅有的零散知识，以为了解了相关体系，对着别人指指点点。典型的例子就是bilibili评论区，于是我也不看bilibili了。  \n&emsp;&emsp;拿政治举例，我既没对政治理论有所研究，又没有选票，也没有军队，关心政治就显得十分业余。  \n&emsp;&emsp;相似的还有艺术、社交、医学、金融、法律或是道德一类的东西。这些东西都有它们的理论体系，如果没有完备地学习过，自然看不到全局，也就得不出好的见解，此时的观点显然也不能普适。我在这些领域既非专业人士，也没有成为专业人士的觉悟，我正确的做法是把嘴闭上，而不是发表廉价的评论。  \n&emsp;&emsp;这就好比我妈看了抖音上面那些所谓的“编程应该这样学”，然后转过来跟我传授“正确”的学习方法一样，我也没有资格去评论我没有潜心研究过的领域。  \n&emsp;&emsp;当然，受邀评论除外。  \n&emsp;&emsp;于是，在大多数时候，我更喜欢成为“观察者”：从第三方视角审视人们的言论，当我发现有人的发言很廉价，我就要提醒自己，不要和傻子争论，更不要成为傻子。当我发现有人的见解超出了我的认知，我就要把它保存下来，以供确认或学习参考之用。  \n&emsp;&emsp;而且，我也有我所热爱的领域，关心圈外的东西并不会让我更加快乐。  \n&emsp;&emsp;上世纪，能够接触计算机的人，多为精英人士。二十年前，能够拥有计算机的家庭，多半富裕。十年前，网络论坛上的人们还在认真地讨论问题。而现在，任何人都能联网，愚昧和无知充斥着整个网络，阴阳怪气之人所见既是。  \n&emsp;&emsp;如何提高信息门槛，以免受到网络垃圾的影响，也愈发重要了。\n\n## 课程设计\n\n&emsp;&emsp;最近C#课程设计的项目占据了我大多数的时间，宿舍里五个人通力合作终于赶完了程序。经事后不完全统计（很不幸，在归档时丢失了一份接口实现，只得通过反编译进行还原），竟有一万九千余行代码！  \n&emsp;&emsp;好在假期把vue及其生态研究了一番（为了开发field v4），也有一部分和pilipala需求重合的F#基础设施，整个项目的开发流程还算舒适（毕竟是写给别人的代码，屎山还是难免的）。我们还做了接入支付宝的扫码支付，我有自信这是所有作业中最好的项目，可惜老师只在乎她的工作，对这些内容并不赏识。不过，我也还算是有些收获，借此研究了下二维码识别、支付宝F2F接口以及C#与F#的互调用。  \n&emsp;&emsp;不过在我看来，这些收获并不值得。\n\n---\n\n<div align="right">\n\n每月评论 - 2209期(共11期)  \n撰稿&校对&审核：Thaumy\n\n</div>\n	2022-10-19 17:51:16	2022-10-19 17:51:18	2022-10-19 17:51:19	12	每月评论2209	1001
12506	# 我为什么不喜欢Go语言\n\n> 首先我必须指出，这篇文章**带有强烈的主观色彩**。任何语言都有它的使用价值，语言圣战不仅没有意义，还很幼稚。\n\n&emsp;&emsp;Go作为一门新开发的语言，在短短几年的时间内就取得了如此高的关注度，并带来了非常丰富的生态。这对于刚学完Rust的我自然而然地充满了吸引力，因为Rust让我充分感受到了现代化工业语言设计与理论相结合的最佳实践，而Go以快速、可靠和高效率著称，尤其是在高并发领域。与此同时，很多人喜欢把Go和Rust相比较，它们都注重高性能，也都声称解决了一系列其他语言难以解决的问题，两者的年龄也差不多。我便对Go充满了好奇和期待：到底是怎样优秀的设计能让Go如此受人追捧？\n\n&emsp;&emsp;原来是“大道至简”啊！\n\n下面我就来讲讲Go的设计哲学。\n\n---\n\n## 违反直觉的类型标注\n\n&emsp;&emsp;Go的类型标注居于标识符之后，且没有使用冒号加以分隔，并且在连续的多个参数类型相同时可以省略前面的类型标识。  \n&emsp;&emsp;这使得同时出现多个函数参数时的可读性被削弱，你不能一眼看出哪些参数具有哪些类型:\n\n```go\nfunc f(a, b chan int, c, d int) {\n\n}\n```\n\n&emsp;&emsp;你不能在第一时间得知a的类型，而是要向后看一段代码，直到发现`b chan int`才能知道原来a和b是同样的类型`chan int`。  \n&emsp;&emsp;当语法高亮不可用时，这种代码会更加难以阅读。\n\n## 令人迷惑的return\n\nGo支持多返回值，但在使用具名返回时，你仍需要在末尾进行return：\n\n```go\nfunc f() (x int, y int) {\n    x = 1\n    y = 2\n    return\n}\n```\n\n```go\nfunc f() (x int, y int) {\n    x = 1\n    y = 1\n    return x, y\n}\n```\n\n上面的两种写法是等价的，但显然应该使用后一种写法。\n\n## 不支持嵌套多行注释\n\n和某些语言一样，Go同样不支持嵌套的多行注释：\n\n```go\n/*/**/*/\n```\n\n&emsp;&emsp;虽然在我常用的语言在对嵌套多行注释的支持性上并没有表现出一致的共识，但我仍希望Go能够具备这个特性，因为这对于某些调试场景来说是很友好的。\n\n## 随处可见的基本类型偏执\n\n&emsp;&emsp;Go的标准库中充满了基本类型偏执。  \n&emsp;&emsp;所谓基本类型偏执，是指在基本类型上约定一个特殊的值来表示不同的意义，这样的方式不是类型安全的，通常会带来难以察觉的潜在问题。\n\n常见地，设置最大goroutine数量的方式就是基本类型偏执：\n\n```go\nruntime.GOMAXPROCS(0)\n```\n\n&emsp;&emsp;当参数>=1时，视为设置最大goroutine数量。否则，则返回当前设置的最大goroutine数量。\n\n&emsp;&emsp;设置和读取最大goroutine数量应该交由不同的函数负责（即使使用一个函数负责，也应该采用类似于ADT的方式），这是基本的抽象行为。\n\n## 意义不明的`:=`\n\nGo提供具备类型推导的变量声明，有两种方式可以做到这一点：\n\n```go\nvar a = 1\n```\n\n```go\nfunc f() {\n    a := 1\n    println(b)\n}\n```\n\n&emsp;&emsp;但令人不解的是，`:=`仅能在函数内部使用，而var则没有这个使用限制。  \n&emsp;&emsp;甚至，`var`要更加通用一些，它允许仅进行声明而不赋初值（此时的初值是类型默认值）：\n\n```go\nvar a int//a is 0\n```\n\n`var`完全能够胜任`:=`的工作，也不会破坏抽象。  \n而更糟糕的是，`:=`还有一个使用陷阱，参见下文。\n\n## receiver弃元\n\n&emsp;&emsp;Go使用类似于扩展方法的语法为结构提供方法抽象，结构的值或其引用被作为函数的第一个参数（被称为receiver）被放在函数名的左边（语法糖，以显得更加清晰）。  \n&emsp;&emsp;但在某些抽象层次，我们需要在类型上实现不需要使用receiver的函数，以下的两种写法是等价的：\n\n```go\ntype A struct{ field int }\n\nfunc (A) F1()   {}\nfunc (_ A) F2() {}\n```\n\n&emsp;&emsp;`_`被称作**弃元**，它是用于占位而不会被（也不能被）使用的标识符，相当于一个黑洞。\n\n但Go中不存在**静态方法**的抽象，于是你只能这样调用：\n\n```go\n(*A).F1(nil)\n```\n\n这被称作**方法表达式**。  \n&emsp;&emsp;尽管这个例子显得有些牵强，但置receiver为nil显然是不优雅的。  \n并且，既然可以没有receiver（如同F1），那为什么要为了语法统一而必须传入receiver呢？\n\n## 执着于复用关键字\n\n&emsp;&emsp;Go总是倾向于复用已有的关键字。通过扩充语义或添加特例语法，你经常能够在Go中看到同一个关键字的不同作用：\n\n### type alias与new type\n\n```go\n//type alias\ntype A = int\ntype B = int\n\n//new type\ntype C int\ntype D int\n```\n\n&emsp;&emsp;类型别名（type alias）和新类型（new type）使用同样的`type`关键字，区别仅在于前者有等号。  \n&emsp;&emsp;而Go中的new type会继承底层类型的操作（仅对于基本类型），这一行为又会让人以为自己是在使用type alias。\n\n### 循环\n\nGo的for有四种用法：\n\n```go\nfor x := 3; x > 0; x-- {\n    //一般用法\n}\nfor i > 0 {\n    //while\n}\nfor {\n    //while(true)\n}\nfor index, value := range [...]int{1, 2, 3} {\n    //foreach\n}\n```\n\n&emsp;&emsp;for承担了过多责任，你仍需要查看之后的代码才能分辨for具体是哪一种用法。  \n我更倾向于使用`for`、`while`、`loop`、`foreach`，意义分明。\n\n&emsp;&emsp;对于复用关键字的讨论，官方的立场是复用关键字能保持Go编译器的的高效性（Go的确编译的很快，这点没得黑）和语法的简洁性，但我觉得语言的设计还是要符合人的思维方式（追求高效编译和语法简洁你去写汇编啊。\n\n### 条件分支\n\nGo的if语句可以添加初始化前缀：\n\n```go\nif i := 100; i > 0 {\n    //TODO\n}\n```\n\nswitch也一样：\n\n```go\nswitch i := 100; i {\ncase 1:\n    //TODO\ncase 2:\n    //TODO\ndefault:\n    //TODO\n}\n```\n\n于是你就能写出这样的代码：\n\n```go\nif i := 100; todo() {\n    println(i)\n}\n```\n\n&emsp;&emsp;为条件分支添加初始化前缀同样不能让人一眼看到条件的具体内容，理想的写法应该是这个样子的：\n\n```go\nif i > 0 where i := 100 {\n    //可惜Go并没有这样做\n}\n```\n\n另外，其switch还支持类型查询：\n\n```go\nswitch v := i.(type) {\ncase nil:\n    print("nil")\ncase A:\n    print(v)\ncase B:\n    print(v)\ndefault:\n    print(i)\n}\n```\n\n&emsp;&emsp;这让本就难以记住的switch又多了一种使用方法（并且还有坑，稍后会提到）。同时，`v := i.(type)`是类型断言`v := i.(A)`在switch中的语法特例，这种语法仅能在此处使用。\n\n&emsp;&emsp;Go的设计者可能希望通过这种方式体现Go的简洁，但以上用例显然不能让人感到直观（有时甚至违反直觉），只会让代码审阅更加头疼，让使用者感到困惑。\n\n## 切片陷阱\n\n&emsp;&emsp;Go的切片不是值拷贝，而是对原数组的引用。这意味着对原数组的更改会反映到其衍生出的切片上：\n\n```go\narr := [...]int{1, 2, 3, 4, 5}\nslice := arr[0:2]\nprintln(slice[0]) //1\narr[0] = 0\nprintln(slice[0]) //0\nslice[0] = -1\nprintln(arr[0]) //-1\n```\n\n共享极其容易导致UAF问题，也缺乏并发安全。\n\n&emsp;&emsp;但Go既不像其他语言那样引入只读切片，也不做编译期检查。你只能通过代码规范来约定对切片的使用方法，或对其加锁来控制并发问题。\n\n曾经在群聊中看到这样一句话：\n\n> Go 那个 slice 扩容其实是个 take ownership 的操作，扩容后之前的就不应该用，但是垃圾 Go 又没 ownership，所以不懂 Rust 的人是写不好 Go 的\n\n## 值传递的弊端\n\n&emsp;&emsp;Go中只有值类型，其他语言中的默认行为在Go中需要通过引用来实现。这就要求Go的任何类型都有一个默认值，也被称作**零值**：\n\n```go\nvar i int     //0\nvar s string  //''\nvar c rune    //0\nvar d float64 //0.0\n```\n\n&emsp;&emsp;这就让一些零值具有特殊意义的使用场景变得十分尴尬：你并不知道传没传值。因为没传是零值，传了零值也是零值。\n\n&emsp;&emsp;由于Go在任何时候都进行值传递，在频繁的数据转移时会带来比引用更大的性能开销。  \n&emsp;&emsp;使用引用可以避免这种开销，于是你的代码就可能变成这个样子（我明白这个例子有些夸张）:\n\n```go\nvar a *****A\n```\n\nGo的传值行为其实并没有带来多少便利。\n\n## 可忽略的CommaOk\n\n&emsp;&emsp;CommaOk是Go中常见的代码规范：如果一个函数可能返回不应使用的值（通常是错误），那么应通过返回的第二个布尔值（也可以是error类型）来判断这个值是否合法：\n\n```go\nfile, err := os.Open("file")\nif err != nil {\n    //handle file\n}\n```\n\n但对于一些内置类型（比如map、chan），你可以忽略"Ok"：\n\n```go\nm := map[string]int{}\nv := m["hi"]\nprintln(v) //0\n```\n\n&emsp;&emsp;在这种情况下，你压根就不知道map里有没有这个键值对：当键不存在时，会返回类型的零值！\n\n没有任何理由去使用无意义的值。Go会默许这种行为，这非常危险。\n\n## 不能拓展的方法设计\n\nGo通过为结构增加方法来提供类型的方法抽象：\n\n```go\ntype A struct{ field int }\n\nfunc (r A) F() {\n    println(r.field)\n}\n```\n\n方法`F`有一个接收者（receiver）r，它相当于OO中的`this`，于是你就能这样调用：\n\n```go\na := A{field: 1}\na.F()//1\n```\n\n&emsp;&emsp;虽然Go的方法设计很类似于其他语言中的**拓展方法**，但Go的方法并不支持拓展，因为你只能为相同包中的结构增加方法。  \n\n如此的语法设计并没有带来更多便利，虽然它长得像。\n\n## 过多的编译器开洞\n\nGo中有很多特殊函数，它们是编译器开的特例，并且有特别的语法：\n\n```go\n//type A struct{ field int }\n\na := new(A)\nm := make(map[string]int)\nc := make(chan string, 10)\n```\n\n&emsp;&emsp;你只能对于特定用途使用这些函数。它们也不是Rust中的`trait`，你也不能让自己的类型满足它们的约束要求。\n\n这些特例破坏了语言的统一性。\n\n## 无意义的类型查询结果\n\n```go\ntype A struct{ a int }\ntype B struct{ b int }\ntype C struct{ c int }\n\n//...\nswitch v := a.(type) {\ncase A, B:\n    println(reflect.TypeOf(v)) //(0x482ea0,0x464280)\n    println(reflect.TypeOf(a)) //(0x482ea0,0x464280)\ndefault:\n    println("default")\n}\n```\n\n当一个case匹配多个类型时，`v`的类型和`a`的类型相同（实际会发生`v:=a`）。\n\n这种行为同样会发生在没有任何类型满足匹配时：\n\n```go\nswitch v := a.(type) {\ncase C:\n    println("is C")\ndefault:\n    println(reflect.TypeOf(v)) //(0x482ea0,0x464280)\n    println(reflect.TypeOf(a)) //(0x482ea0,0x464280)\n}\n```\n\nGo编译器没有禁止这种行为，你仍能够在此时使用v，但显然v是没有意义的。\n\n## interface安全性\n\nGo在没有泛型之前，空接口的使用十分普遍：\n\n```go\nfunc f(x interface{}) {\n\n}\n```\n\n这其实就是C语言中的`void *`。  \n\n&emsp;&emsp;放弃类型检查带来的泛化不仅难以理解，还可能产生潜在的安全问题（更为重要地，它们通常难以复现和调试）。由于缺乏静态信息，编译器也难以对这类模式进行优化，如果搭配反射使用，则又会带来性能问题。  \n&emsp;&emsp;同时，Go编译器并不会进行静态检查，直接在未初始化的接口上调用方法是被允许的（产生运行时panic）。\n\n另外，空接口还有一个陷阱：\n\n```go\nvar x *interface{} = nil\nvar y interface{} = x\n\nprintln(y)        //(0x4585a0,0x0)\nprintln(y == nil) //false\n```\n\n&emsp;&emsp;按常理来说，Go会将x的值`nil`复制到y的值，从而使得y为`nil`才对。但Go在空接口的内部实现中有两个字段，它们分别是类型和指向值的指针，只有当两者均为`nil`时，空接口才为`nil`。\n\n这就导致了非常违反直觉的结果：\n\n```go\nvar i interface{} = (*A)(nil)\n\nprintln(i == nil)         //false\nprintln((*A)(nil) == nil) //true\n```\n\n## 简陋的泛型设计\n\nGo在1.18终于提供了对泛型的支持：\n\n```go\ntype Box[T any] struct {\n    value T\n}\n\nfunc unwrap[T any](b Box[T]) T {\n    return b.value\n}\n\nfunc main() {\n    b := Box[int]{value: 1}\n    print(unwrap(b)) //1\n}\n```\n\n&emsp;&emsp;但Go的泛型实现其实相当简陋，你大多数时候都需要借助于反射来收集足够的类型信息，尽管有足够的信息去在编译期特化，下面有两个例子:\n\n### 不支持在类型参数上进行type assertion\n\n```go\nfunc mempty[T []int | string]() T {\n    var z T\n    switch z.(type) {\n    case []int:\n        return []int{}\n    case string:\n        return ""\n    }\n}\n/*\n...cannot use type switch on type parameter value z (variable of type T constrained by []int|string)\n...cannot use []int{} (value of type []int) as type T in return statement:\n...cannot assign []int to string (in T)\n...cannot use "" (untyped string constant) as T value in return statement\n*/\n```\n\n### 也没有办法实施对基础类型的泛化约束\n\n```go\ntype BaseOn[T any] interface {\n    ~T\n}\n\nfunc as[T BaseOn[B], B any](x T) B {\n    return (B)(x)\n}\n\nfunc main() {\n    type A int\n    var a A = 1\n    i := as[A, int](a)\n    println(i)\n}\n/*\n...cannot embed a type parameter\n...cannot convert x (variable of type T constrained by BaseOn[B]) to type B\n...cannot implement BaseOn[int] (empty type set)\n*/\n```\n\n受限于历史包袱、匮乏的静态信息和性能，Go还不支持泛型方法。\n\n## 不被处理的goroutine返回值\n\n由goroutine调度的函数，其返回值会被忽略：\n\n```go\ngo func() int {\n    return 1//1不能通过任何方式被获取\n}()\n```\n\n&emsp;&emsp;但Go使用返回值表示错误（CommaOk），此时忽略返回值就意味着可能存在被忽视潜在的错误，这是不安全的。\n\n&emsp;&emsp;我认为理想的goroutine应只允许调度不返回的函数（等效地，也可以返回某种单值类型Unit），对于接受任何返回值的调度，应使用弃元：\n\n```go\ngo func() {\n    _ := f()\n}()\n```\n\n这样，所有的情况都能得到显式处理。\n\n## defer陷阱\n\ndefer是Go用于注册延迟调用的关键字：\n\n```go\ndefer print(0)\ndefer print(1)\nprint(2)\nprint(3)\nreturn //output is 2310\n```\n\n当函数返回前，被defer的函数会以LIFO顺序执行。\n\ndefer也被用于异常恢复，但如下的defer是无效的：\n\n```go\ndefer recover()\npanic("crash!")\nreturn\n```\n\n编译通过，但异常在运行时被传播了。你必须对recover进行函数包装：\n\n```go\ndefer func() { recover() }()\npanic("crash!")\nreturn\n```\n\n&emsp;&emsp;我们又发现了一个特例。因为`func(){}()`和`f()`是等价的，它们都是有效的函数调用，注册到defer时行为一致。但`defer recover()`并没有产生预期行为，recover是编译器开的一个洞。\n\n同时，defer还有一个坑：\n\n```go\nfunc f() (x int) {\n    defer func() { x = 1 }()\n    return 0\n}\n\nfunc main() {\n    println(f())//1\n}\n```\n\n&emsp;&emsp;在这个例子中，Go首先会执行return，将0拷贝到返回值栈区（Go的多返回值是通过在栈空间上预留区域实现的），然后defer会被执行（以LIFO），最后会退出当前调用栈并返回到上层调用栈（也就是汇编中的RET）。\n\n&emsp;&emsp;这种奇怪的设计让return不再是Go函数中最后被执行的语句，return的执行被割裂成了两个部分，而defer被穿插在二者之间执行。\n\n&emsp;&emsp;具名返回的行为是令人困惑的，这显然与它的设计初衷相违。也有人提出应避免使用具名返回以防范defer问题，这与解决`:=`的副作用问题有些类似（见下文），都有点自废武功的感觉。\n\n## `:=`的模糊语义\n\nGo中的`:=`适用于在函数内声明变量的同时完成其初始化：\n\n```go\na := 1     //a的类型由推导暗示，为int\nprintln(a) //1\n```\n\n但在某些情况下，`:=`也可以进行赋值：\n\n```go\nvar a int\nprintln(a, &a) //0 0xc000054768\na, b := 1, 2\nprintln(a, &a) //1 0xc000054768\nprintln(b)     //2\n```\n\n&emsp;&emsp;这是因为Go在编译时要求`:=`至少创建一个变量，在这个例子中那个变量是`b`。  \n要想避免这种副作用，推荐的做法是先声明再赋值，但这显得十分原始，更重要的是，你可能忘了在之后对声明赋值：\n\n```go\nvar a, b int\na = 1\nb = 2\n//当然你也可以这样写，但它不像:=那样是强制的\n//var a, b = 1, 2\n```\n\n当使用同一变量接收多个由CommaOk提供的错误信息时，这一副作用会更加明显：\n\n```go\nfile1, err := os.Open("file1")\nfile2, err := os.Open("file2")\nif err == nil {//always true if file2 exists\n    //handle file1 and file2\n}\n```\n\n错误信息会被难以察觉地覆盖，很可能file1在文件系统上是不存在的。\n\n## 多重异常范式\n\nGo具有两套异常处理模型：panic/recover和CommaOk。\n\npanic/recover是try/catch的变种：\n\n```go\ndefer func() {\n    msg := recover()\n    fmt.Println(msg)\n}()\npanic("panic message")\n```\n\n&emsp;&emsp;不同于Rust的panic，在Go中你可以使用recover来捕获当前调用调用栈中最后抛出的panic，并阻止栈展开。\n\n&emsp;&emsp;这就使得Go能够用异常来表示控制流，而这种控制流是相当混乱的。  \n&emsp;&emsp;想要规范这种控制流，则必须采用**受检异常**，但实践已经表明这类方式并不优雅（可以参考Java），因为总是有无法处理的异常，你总是需要catch anything and do nothing（顶多记录一下日志）。所以现在大家都不用受检异常了，crash is awesome。\n\n归根结底，还是不应该让异常接管控制流。\n\nCommaOk是POSIX风格错误处理（参见CS:APP 附录A）的变种：\n\n```go\nval, ok := tod88888888888888888o()\nif ok {\n    //use val\n}\n```\n\n&emsp;&emsp;但对于某些场景（例如map），"Ok"是可以被忽略的（参见上文讨论），这种方式也不够安全。\n\n&emsp;&emsp;两种范式的混用最终导致了Go并没有解决异常处理的一系列问题，甚至还将问题复杂化了（因为defer的LIFO和recover的leak）。\n\n## goto\n\nGo有一个功能受限的goto，它只能在函数内部跳转，且无法跳过变量声明：\n\n```go\nx := 2\nif x > 1 {\n    goto L1\n} else {\n    goto L2\n}\nL1:\nprintln("L1")//L1\nreturn\nL2:\nprintln("L2")\nreturn\n```\n\n尽管Go中受限的goto安全性要好一些，但使用它编写的程序仍然是不安全和难以维护的。\n\n&emsp;&emsp;也不能一味地贬低goto，在某些场景中使用goto也是有优势的（据群友说在实现某些解码器时使用goto能带来很大的性能提升，讨论基于C）。但我认为Go并不是将性能作为第一考量的语言（因为Go有GC的性能抖动），综合来看，保留goto的做法仍弊大于利。\n\n---\n\n&emsp;&emsp;其实，Go只是把传统问题换了一种语法表达罢了。Go设计团队的谜之设计甚至为Go带来了很多问题（并且他们不听取社区意见，一意孤行），这让Go逐渐变得违反直觉、令人困惑（可怕的是有些人执着地认为这些设计是符合“Go哲学”的：Go是简洁的，不是Go没有，而是你根本不需要它。\n\n使用Go，你的确能够快速给出产品原型，也的确能利用很多并发设施，这确实比使用C或C++要快些。但Go没有解决安全问题，给我的感觉是Google创造了一门能够更快速写Bug的编程语言。\n\n&emsp;&emsp;Go宣称快速，但却使用了GC（这个GC的性能一直备受争议），这不可避免地带来了性能抖动问题，也浪费了计算资源。这使得Go不能用于开发面向性能的应用或是开发资源受限的应用（尽管如此，但仍有很多超大型项目是使用Go的，这可能是由于历史和团队原因）。但如果是这样的话，我为什么不去用Node、JVM系或是.NET呢？要知道它们同样快速。\n\n&emsp;&emsp;Go宣称可靠，但你依然能够使用Go写出具有明显错误的程序并通过编译（最重要的是写出这样的程序何其容易！），你仍需要进行大量的测试和分析以发现诸如NPE、UAF和Dead Lock之类的问题。Go不但没有引入一个安全的类型系统（空接口是leak的），也不会进行编译时安全检查。Go不能解决历史遗留问题，就像C++一样。\n\n&emsp;&emsp;Go甚至没有一个好用的包管理系统（Google只关心他们自己的开发体验，本来Go就是一个在Google内部使用的语言），也缺失了很多提升开发效率和抽象层次的语言设施（简陋的泛型设计、到处都是擦除的类型系统、不能使用宏进行代码生成），甚至带来了非常多的陷阱（更可怕的是，这些陷阱集成到了语言层面）。另外，Go使用Plan9汇编，由于这种汇编资料匮乏，除了Google外也没人能够对Go进行优化改良。\n\n&emsp;&emsp;在我看来，貌似Go更适合作为云原生IL。比如让一些依赖于GC的语言翻译到Go，再由Go编译器编译到机器码......或许某一天大家更喜欢把语言编译到Go，而不是JavaScript（笑。\n\n&emsp;&emsp;在Google的力推下，Go或许还能挺十几年（或者几十年，因为它入门简单），但这并不是一门面向未来而设计的语言。\n\n## 后话\n\n&emsp;&emsp;这篇文章其实计划是要在6/7月份发表的，奈何赶上pilipala内核的开发，才一拖拖到现在。当时的我刚看完《Go语言核心编程》这本书，由于之前学过Rust，又看过《Kotlin核心编程》（Rust和《Kotlin核心编程》都非常不错！），于是在接触Go后产生了极大的心理落差，所以想要喷一下Go。  \n&emsp;&emsp;其实现在在我看来，Go也没有那么差，它确实有适合它使用的人，尤其是那些C++钉子户，因为学习Go的门槛是非常低的，也不涉及到PL之类的东西（能吃饭的语言就是好语言！）。Go的语言设计确实称不上优秀，但是对于重构用途还是有价值的，尤其是原有的基于脚本语言的项目，Go的提升还是很大的（参考ESBuild对比Webpack），而且在现在这个硬件资源十分过剩的时代，多个GC也没什么性能消耗，像Go这种天天alloc不回收的顶多加点内存条嘛（大雾）！要知道硬件成本可是最低的。\n\n&emsp;&emsp;但我还是要骂《Go语言核心编程》这本书和它的作者李文塔！一本30万字的书，光是被我发现的错误就有37处！可见这个人的编书质量是多么的糟糕。抛开勘误不谈，李文塔对于语言的认识也存在偏差，以下取自原书第56页：\n\n> 对象是附有行为的数据，而闭包是附有数据的行为，类在定义时已经显式地集中定义了行为，但是闭包中的数据没有显式地集中声明的地方，这种数据和行为耦合的模型不是一种推荐的编程模型，闭包仅仅是锦上添花的东西，不是不可缺少的。\n\n光是倡导不要使用闭包这种暴论，就足以说明一切了。\n\n我还是头一回读这么傻逼的书。\n\n---\n\n本文基于 Go1.18.3 编写\n	2022-10-27 00:05:58	2022-10-27 00:06:00	2022-11-29 19:24:31	12	我为什么不喜欢Go语言	1001
12507	<img src="https://cdn.thaumy.cn/post/日常/github万圣节彩蛋/github_status_halloween.png"/>\n\n*GitHub的万圣节彩蛋*  \n**Trick or treat！**\n	2022-10-31 14:30:26	2022-10-31 14:30:28	2022-10-31 14:30:30	12		1001
12409	因为MySQL5.7.28和5.7.17的某些方面出现了兼容问题，我耗费了大量时间才将其解决。  \n。。。所以这周博客又停更了。。。。但是，新年快乐！	2020-01-01 23:27:23	2020-01-01 23:27:27	2020-01-01 23:27:27	28		1001
12389	### 本博客的主题要随beta7推出新版本啦！  \n\n## <span style="color:#C71585">前景</span>  \n\n经过长时间的设计经验积累，氛主题由苹果风逐渐向微软风的UI转移。苹果的UI实在太圆润了，审美疲劳非常快，还是windows方方正正的风格耐看。  \n面向beta7的主题构建，氛主题的结构布局将会更加合理，让开发更有效率。我将添加更多友好的动画效果和交互控件，使这个主题拥有一流的交互体验。  \n\n## <span style="color:#C71585">持续构建</span>  \n\n氛将会和以前一样，提供每周的UI更新和系统优化。  \n\n## <span style="color:#C71585">新相</span>  \n\n为了适应水瓜社官网的暑期部署，一个新的主题将会进入流程：気。	2019-06-30 06:31:16	2019-06-30 06:31:18	2019-06-30 06:31:18	28	氛愿景	1001
12386	## <span style="color:#53A0FE">第七版推进</span>\n\n到目前，pilipala beta6 已经完成了六个版本的迭代。我们的开发工作也将进入下一阶段。  \npilipala beta7 将提供十个步进版本的迭代更新，长达三个季度。  \n此版本将于2019年暑期进入开发流程，此前，我们可爱的第六版将完成第十次步进。\n\n<span class="wd-dt2">计划修正：</span>  \n<span class="mk-dt">19.06.29<span class="mk-bug"></span></span>由于工程调整，beta7将于beta6第八步进后进入开发流程\n\n### <span style="color:#48D1CC">pilipala项目的有序进行：</span>\n\n* beta1 建立了可供浏览的网站系统\n* beta2 对上一代版本的不足之处加以优化\n* beta3 新的结构式架构\n* beta4 优化了上一代架构\n* beta5 结构式架构的最后一次优化\n* beta6 推出对象式架构，开发过程清晰明了，运行效率达到新高\n* beta7 将进一步提高系统的开发效能，使用模组化设计思路\n\n## <span style="color:#53A0FE">以Kaguya架构</span>\n\n我们计划在beta7上进一步优化beta6的稳定性和兼容性，它将继承beta6优异的FutabaRio对象式架构。Kaguya架构将提供更多开发选项，进一步降低耦合度。\n\n## <span style="color:#53A0FE">备选更新方案</span>\n\n支持插件  \n降低主题的编写难度  \n冗余数据分模块处理，以进一步精简数据库  \n优化现有ajax解决方案  \n使用内存查询来提升数据处理速度，用户的所有操作在会话期间均不会访问数据库。  \n降低部署难度  \n优化链接  \n提供更安全的文章访问级别  \n\n## <span style="color:#53A0FE">其他衍生项目</span>\n\n基于pilipala beta7 的水瓜社官网  \n推出企业版氛主题  	2019-05-26 00:39:38	2019-06-29 19:33:09	2019-06-29 19:33:09	28	PILIPALA BETA7愿景	1001
12396	经过一个月的编写调试，噼里啪啦推出了第七测试版。  \n在弥补上一版本的若干缺陷的同时，BETA7使用了新的业务体系，提供了更加丰富的函数支持。\n\n## Kaguya架构\n\n<blockquote>\n来自四宫辉夜的钦定\n</blockquote>\n\n1. 支持更大客制化空间的模块化主题\n2. 第三代数据桥\n3. 重构后的噼里啪啦数据库\n4. 快速部署支持\n5. 高可用性重构\n\n## WaterLibrary内核\n\n<blockquote>\n水库，纳百川之流\n</blockquote>\n\n1. 全新的文章控制器\n2. 规范统一的命名体系\n3. 多接口约束\n4. 简明易懂的业务层分工\n5. 更加安全的噼里啪啦数据库访问机制\n6. 专为第三代对象式架构调整的数据层\n7. 更多的数据源获取支持	2019-09-06 19:10:39	2020-02-12 06:51:29	2020-02-12 06:51:29	28	噼里啪啦BETA7已部署	1001
12397	 <div align="center">\n\n# 国庆赋\n### 雅爱方雏\n## 砥砺前行七十载，众心众志向未来。  \n## 以坚定的初心，不断寻求人民的福祉。  \n## 快速发展的背后，是『高工作效率』。  \n## 拼搏，奋斗，我们都是追梦人。\n\n</div>	2019-10-01 18:40:16	2019-10-01 18:40:16	2019-10-01 18:40:16	28	国庆赋	1005
12395	[2019-08-25/09:59:35]:创建日期\n[2019-08-25/10:00:37]:修改日期\n[C# DEMO]:概要\n[技术归档]:归档\n[C#]:标签\n[封面URL]:封面URL\n\n<blockquote>\n在上周的项目的开发中我发现一个很基础的知识点存在遗漏，决定写一篇博文，就是向上转型的问题。\n</blockquote>\n\n类似于这样：\n\n<pre>C#<code>A a = new B();/* 向上转型 */</code></pre>\n\n其中，子类B继承于父类A。\n\n### 什么是向上转型？  \n按照我的理解，上面的代码可以理解为：\n\n1. 新建一个A的实例a\n2. 将a转换到B类型\n\n第一步骤相信大家都明白。  \n那么第二步，A类型的a经过了怎样的步骤，转换成了B类型呢？\n\n为了探讨这个问题，我们建立一个类A：\n\n<pre>C#<code>class A\n{\n    public void output()\n    {\n        Console.WriteLine("我是A输出的");\n    }\n}</code></pre>\n\n建立类B，继承自A：\n\n<pre>C#<code>class B : A\n{\n    public void output()\n    {\n        Console.WriteLine("我是B输出的");\n    }\n}</code></pre>\n\n我们尝试调用一下output()方法：\n\n<pre>C#<code>A a1 = new B();\na1.output();</code></pre>\n\n得到输出结果：\n\n<pre>Console<code>我是A输出的</code></pre>\n\n<blockquote>\n可以看到，a1调用的是父类的方法。  \n</blockquote>\n\n那么如果有业务需求，如何调用B中的方法呢？  \n将A中方法添加虚拟：\n\n<pre>C#<code>public virtual void output()\n{\n    Console.WriteLine("我是A输出的");\n}</code></pre>\n\n将B中方法添加重写：\n\n<pre>C#<code>public override void output()\n{\n    Console.WriteLine("我是B输出的");\n}</code></pre>\n\n 再次像上面那样，调用output()方法：\n\n <pre>Console<code>我是B输出的</code></pre>\n\n<blockquote>\n由于重写，a调用了B类中的output()方法。\n</blockquote>\n\n下面来讨论另一种情况：使用new隐藏子类方法。\n\n<pre>C#<code>using System;\n\nnamespace ConsoleApp1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            A a = new B();\n            a.output();\n        }\n    }\n    class A\n    {\n        public void output()\n        {\n            Console.WriteLine("我是A输出的");\n        }\n    }\n    class B : A\n    {\n        public new void output()\n        {\n            Console.WriteLine("我是B输出的");\n        }\n    }\n}</code></pre>\n<br>\n<pre>Console<code>我是A输出的</code></pre>\n\n上面是一段完整的代码。\n\n<blockquote>\n输出表明虽然a被转换为B类型，但如果B类型的方法是将A中相应方法隐藏的，a会调用A中的方法。\n</blockquote>\n\n### 总结：\n\n<pre>C#<code>A a = new B();</code></pre>\n\n上述代码的实质是把子类B扩大到父类A，使其在实例a的外部能够调用父类的重名成员。  \n\n### 这样做有什么意义？  \n\n<blockquote>\n我们可以建立这样一个A的实例，让它能够调用A类和B类的重名成员，对于B类的额外内容，A类可以通过添加抽象的方式，在B类中以重写实现来完成调用。  \n</blockquote>\n\n对于只需要B类成员的情况：\n\n<pre>C#<code>B b = new B();</code></pre>\n\n这样便能屏蔽掉父类A，只专注于B类的功能了。\n\n教程写的繁琐不堪，如果能帮到大家，是我莫大的荣幸。	2019-08-27 08:17:30	2019-08-31 22:30:54	2019-08-31 22:30:54	28	C#向上转型的一系列多态问题	1001
12379	<v-app id="temp_app">\n    <v-timeline :dense="$vuetify.breakpoint.smAndDown">\n        <v-timeline-item fill-dot small color="info" v-for="item in list" :key="item">\n            <span v-if="item.time==''?false:true" slot="opposite">{{item.time}}</span>\n            <v-card class="elevation-2">\n                <v-card-title v-if="item.auth==''?false:true">\n                    {{item.auth}}\n                </v-card-title>\n                <v-card-text>\n                    {{item.text}}\n                </v-card-text>\n            </v-card>\n        </v-timeline-item>\n    </v-timeline>\n</v-app>\n<script>\n    new Vue({\n        el: '#temp_app',\n        vuetify: new Vuetify(),\n        data: {\n            list: [\n                {\n                    auth: "罗素",\n                    text: "如果一听到一种与你相左的意见就发怒，这表明，你已经下意识地感觉到你那种看法没有充分理由。如果某个人硬要说二加二等于五，你只会感到怜悯而不是愤怒。",\n                    time: "2022.4.4"\n                },\n                {\n                    auth: "罗素",\n                    text: "所谓幸福的生活，必然是指安静的生活，原因是只有在安静的气氛中，才能够产生真正的人生乐趣。",\n                    time: "2022.4.4"\n                },\n                {\n                    auth: "罗素",\n                    text: "不要为自己持独特看法而感到害怕，因为我们现在所接受的常识都曾是独特看法。",\n                    time: "2022.4.4"\n                },\n                {\n                    auth: "罗素",\n                    text: "人的情绪起落是与他对事实的感知成反比的，你对事实了解得越少，就越容易动感情。",\n                    time: "2022.4.4"\n                },\n                {\n                    auth: "罗素",\n                    text: "这个世界的问题在于聪明人充满疑惑，而傻子们坚信不疑。",\n                    time: "2022.4.4"\n                },\n                {\n                    auth: "罗素",\n                    text: "你能在浪费时间中获得乐趣， 就不是浪费时间。",\n                    time: "2022.4.4"\n                },\n                {\n                    auth: "罗素",\n                    text: "放弃自己想要的某些东西，是幸福生活不可或缺的一部分。",\n                    time: "2022.4.4"\n                },\n                {\n                    auth: "",\n                    text: "金子不会发光",\n                    time: "2022.3.11"\n                },\n                {\n                    auth: "白ice",\n                    text: "弱小和无知不是生存的障碍，傲慢才是。",\n                    time: "2021.12.12"\n                },\n                {\n                    auth: "薛定谔",\n                    text: "生命以负熵为食",\n                    time: "2021.11.25"\n                },\n                {\n                    auth: "《咒术回战》七海建人",\n                    text: "枕边脱落的头发变多了，喜欢吃的夹心面包从便利店消失了，这些小小的绝望堆彻起来，才会让人长大。",\n                    time: "2021.10.4"\n                },\n                {\n                    auth: "",\n                    text: "感情是熵",\n                    time: "2021.9.15"\n                },\n                {\n                    auth: "《新华词典》",\n                    text: "张华考上了北京大学；李萍进了中等技术学校；我在百货公司当售货员：我们都有光明的前途。",\n                    time: "2021.8.18"\n                },\n                {\n                    auth: "史蒂夫·乔布斯",\n                    text: "Stay Hungry, Stay Foolish.",\n                    time: "2021.8.05"\n                },\n                {\n                    auth: "David Wheeler",\n                    text: "All problems in computer science can be solved by another level of indirection.",\n                    time: "2021.4.23"\n                },\n                {\n                    auth: "唐纳德·克努特",\n                    text: "过早的优化是万恶之源",\n                    time: "2021.2.16"\n                },\n                {\n                    auth: "《乒乓》",\n                    text: "比乒乓更广阔的，是人生。",\n                    time: "2021.1.17"\n                },\n                {\n                    auth: "《小魔女学园》",\n                    text: "没有什么比梦想更能创造未来。\\n没有什么比口袋空空更能使人冒险。\\n有没有常识与有没有教育无关。\\n想知道革命的意义是什么，就称之为进步。\\n想知道进步的意义是什么，就称之为明天。",\n                    time: "2021.1.8"\n                },\n                {\n                    auth: "艾米莉·狄金森",\n                    text: "我本能忍受黑暗，如果我未曾见过光明。",\n                    time: "2020.12.2?"\n                },\n                {\n                    auth: "《小魔女学园》言之端叶(一)",\n                    text: "Nod Y LIe Delfrydol",\n                    time: "2020.12.6"\n                },\n                {\n                    auth: "马保国",\n                    text: "武林要以和为贵，要讲武德，不要搞窝里斗。",\n                    time: "2020.11.24"\n                },\n                {\n                    auth: "查尔斯·布考斯基",\n                    text: "一天不独处，我就会变得虚弱。我不以孤独为荣，但以此维生。",\n                    time: "2020.11.21"\n                },\n                {\n                    auth: "亚瑟·查理斯·克拉克",\n                    text: "真正先进的技术，看上去都与魔法无异。",\n                    time: "2020.10.31"\n                },\n                {\n                    auth: "《Python之禅》",\n                    text: "只用一种方法解决问题。",\n                    time: "2020.10.26"\n                },\n                {\n                    auth: "",\n                    text: "迟到的正义绝非真正的正义。",\n                    time: "2020.8.8"\n                },\n                {\n                    auth: "《明日方舟》龙门近卫局",\n                    text: "德才兼備",\n                    time: "2020.5.10"\n                },\n                {\n                    auth: "《我不是药神》",\n                    text: "我卖药这么多年，发现这世上只有一种病，穷病。这种病你没法治啊，你也治不过来。",\n                    time: "2020.4.11"\n                },\n                {\n                    auth: "",\n                    text: "一群高尚的人，一群纯粹的人，一群有道德的人，一群脱离了低级趣味的人，一群有益于人民的人。",\n                    time: "2020.4.2"\n                },\n                {\n                    auth: "",\n                    text: "永远年轻，永远热泪盈眶",\n                    time: "2020.2.18"\n                },\n                {\n                    auth: "",\n                    text: "做一个强奸现实的人",\n                    time: "2020.1.21"\n                },\n                {\n                    auth: "《我是谁：没有绝对安全的系统》",\n                    text: "Dreistigkeit siegt",\n                    time: "2019.11.24"\n                },\n                {\n                    auth: "《勾指起誓》",\n                    text: "理所当然的奇迹",\n                    time: "2019.8.29"\n                },\n                {\n                    auth: "《彩虹六号》",\n                    text: "坐而言不如起而行",\n                    time: "2019.3.3"\n                },\n                {\n                    auth: "《瓦尔登湖》",\n                    text: "经常需要运用他的知识的人，怎么能够很好地记得自己的无知呢？",\n                    time: "2019.1.27"\n                },\n                {\n                    auth: "《瓦尔登湖》",\n                    text: "人们更喜欢在互相恭维的泥淖中打滚",\n                    time: "2019.1.27"\n                },\n                 {\n                    auth: "《流浪地球》",\n                    text: "我们选择希望",\n                    time: "2018.11.9"\n                },\n                {\n                    auth: "",\n                    text: "为自由而牺牲自由",\n                    time: "2017.10.4"\n                },\n                {\n                    auth: "《欢迎来到实力主义至上的教室》",\n                    text: "深藏不露是一种卓越的才能",\n                    time: "2017.7.23"\n                },\n                {\n                    auth: "",\n                    text: "多希望有一天突然惊醒，发现自己在高三的一节课上睡着了，现在经历的一切都是一场梦，桌上满是你的口水。你告诉同桌，说做了个好长的梦。同桌骂你白痴，叫你好好听课。你看着窗外的球场，一切都那么熟悉，一切还充满希望...",\n                    time: ""\n                },\n                {\n                    auth: "",\n                    text: "启蒙导致愚昧，知识带来无知",\n                    time: "2017.7.19"\n                },\n                {\n                    auth: "",\n                    text: "志不同，道不合，不相为谋",\n                    time: "2017.2.3"\n                },\n                {\n                    auth: "崩坏学园2",\n                    text: "技术宅，拯救世界",\n                    time: "2016.12.10"\n                },\n                {\n                    auth: "",\n                    text: "学无止，思无界，行无疆",\n                    time: "2016.5.9"\n                }\n            ]\n        }\n    })\n</script>	2019-04-05 17:46:42	2021-10-08 23:00:49	2021-10-08 23:00:49	28	句摘	1001
12356	<style>p{text-indent: 2em; /*首行缩进*/}</style>\n\n> 本文属于转载文章\n\n## 三层架构（3-tier application）\n\n通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。区分层次的目的即为了“高内聚，低耦合”的思想。\n\n### 表现层（UI）\n\n通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。\n\n### 业务逻辑层（BLL）\n\n针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。\n\n### 数据访问层（DAL）\n\n该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。\n\n## MVC架构(Model-View-Controller)\n\n> 严格来讲，MVC是三层架构中的UI层。这意味着MVC把三层架构中的UI层再度进行了分化，分成了控制器、视图、实体三个部分，控制器完成页面逻辑，通过实体来与界面层完成通话；而C层直接与三层中的BLL进行对话。\n\nMVC可以是三层中的一个表现层框架，属于表现层。三层和MVC可以共存。三层是基于业务逻辑来分的，而MVC是基于页面来分的。MVC主要用于表现层，3层主要用于体系架构，3层一般是表现层、中间层、数据层，其中表现层又可以分成M、V、C，（Model View Controller）模型－视图－控制器\n\nMVC模式是GUI界面开发的指导模式，基于表现层分离的思想把程序分为三大部分：Model-View-Controller，呈三角形结构。Model是指数据以及应用程序逻辑，View是指 Model的视图，也就是用户界面。这两者都很好理解，关键点在于Controller的角色以及三者之间的关系。在MVC模式中，Controller和View同属于表现层，通常成对出现。Controller被设计为处理用户交互的逻辑。一个通常的误解是认为Controller负责处理View和Model的交互，而实际上View和Model之间是可以直接通信的。由于用户的交互通常会涉及到Model的改变和View的更新，所以这些可以认为是Cont roller的副作用。\n\nMVC 是表现层的架构，MVC的Model实际上是ViewModel，即供View进行展示的数据。 ViewModel不包含业务逻辑，也不包含数据读取。\n\n而在N层架构中，一般还会有一个Model层，用来与数据库的表相对应，也就是所谓ORM中的O.这个Model可能是POCO，也可能是包含一些验证逻辑的实体类，一般也不包含数据读取。进行数据读取的是数据访问层。而作为UI层的MVC一般不直接操作数据访问层，中间会有一个业务逻辑层封装业务逻辑、调用数据访问层。UI层（Controller）通过业务逻辑层来得到数据（Model），并进行封装（ViewModel），然后选择相应的View.\n\nMVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。比如一批统计数据你可以分别用柱状图、饼图来表示。C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。\n\nMVC如何工作MVC是一个设计模式，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。\n\n视图（View）：用户看到并与之交互的界面。对老式的Web应用程序来说，视图就是由HTML元素组成的界面，在新式的Web应用程序中，HTML依旧在视图中扮演着重要的角色，但一些新的技术已层出不穷，它们包括Macromedia Flash和象XHTML，XML/XSL，WML等一些标识语言和Web services.如何处理应用程序的界面变得越来越有挑战性。MVC一个大的好处是它能为你的应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，不管这些数据是联机存储的还是一个雇员列表，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。\n\n模型（Model）：模型表示企业数据和业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，就是说模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。\n	2017-06-17 04:16:29	2020-11-28 15:46:14	2020-11-28 15:46:14	28	三层架构与MVC	1001
12359	<blockquote>\n众所周知，wordpress是在数据库里存储数据的，这些数据包括文章、用户数据、媒体路径等，在这里不过多列举。\n</blockquote>\n<br>\n\n&emsp;&emsp;有效数据是wp运作的基础，无效数据则会减缓网页运行速度，带来未知的bug和不必要的资源占用，甚至是浪费你的服务器资源(我的数据库在优化前有20MB大，优化后只有1MB)。\n\n&emsp;&emsp;这里则是一篇基础文章，谈及最基本的数据库优化，表达我个人的见解。\n\n<span style="color:rgb(240,90,45)">wordpress在使用时会产生大量不必要的数据库信息，这些信息虽然只占用了很小一部分的服务器资源，但随着日积月累，这将会是一个庞大的资源开销，甚至撑爆你的数据库空间！</span>\n\n<ul>\n \t<li><span style="color:rgb(0,206,209)">wp_posts</span></li>\n</ul>\n这个表被用来存储文章信息，包括文章标题、内容、父级、别名和一些其他列，当一个wp站点运作时间较长，且更新活跃时，这里便成为一个数据垃圾场。\n\n&emsp;&emsp;wp在你每一次文章更改时都会保存文章的信息，这也包括自动草稿。每一次的文章更名都会在该表内增添一个新行，它不在原有的基础上修改，而是通过建立一个新行实现更改，这意味着之前所有的数据都会被保存。\n\n&emsp;&emsp;我删除了大量的文章、清空了回收站，当我浏览数据库时，发现wp_posts竟然有700多行数据，这意味着我的700次文章、页面修改全都被记录。这是非常恐怖的，仅仅200天就有800行数据，占用了多达20M的数据库空间。这意味着每一次打开博客，存储引擎就要在700行数据中select出真正有用的几十篇文章。虽然存储引擎是高效的，但是如果有上万行，速度延迟便变得明显，这对用户体验并不友好。\n\n&emsp;&emsp;一般来讲，wp_posts表中的post_status列的值为inherit时，这篇文章是可以被安全删除的。\n\n在控制台执行SQL语句：\n<pre>SQL<code>DELETE FROM `wp_posts` WHERE `wp_posts`.`post_status` = "inherit";</code></pre>\n另外，自动草稿也是可以被安全删除的：\n<pre>SQL<code>DELETE FROM `wp_posts` WHERE `wp_posts`.`post_title` = "自动草稿";</code></pre>\n\n\n<ul>\n \t<li><span style="color:rgb(0,206,209)">wp_postmeta</span></li>\n</ul>\n它被用来存储部分插件、文章自定义栏目数据，当删除一个插件时，这些数据并不会被清除。如果你经常安装插件，查看一下这个表的数据还是有必要的。\n\n<ul>\n \t<li><span style="color:rgb(0,206,209)">wp_comments</span></li>\n</ul>\n\n&emsp;&emsp;这个表存储了评论内容(wp原生的)，每一次评论都会被详细记录。这包括评论者的终端系统、运行环境、浏览器及其内核、IP地址、日期等。曾经有效的评论都会在这里被保存，不论你是否删除过或清空回收站。如果你的站点是开放评论的，请酌情考虑这些数据的价值(往往这些数据在指导对用户行为分析时是有用的)\n\n<ul>\n \t<li><span style="color: #ff6600;">wp_users</span></li>\n</ul>\n\n&emsp;&emsp;用户的基本信息都被存储在这里，它包括用户名、密码(被MD5加密)、邮箱、注册日期等。如果你的站点有用户注册，考虑这些信息是否被值得优化。\n\n<ul>\n \t<li><span style="color: #ff6600;">wp_usermeta</span></li>\n</ul>\n\n&emsp;&emsp;某些插件会使用该表，用来为用户增添新的属性。这方面的插件修改较多时，考虑这里的数据。\n\n&nbsp;\n\n> 无论垃圾数据量有多少，都应按照实际情况考虑。不要强硬地更改，这可能导致不必要的数据损失。适当保有数据作为备份，是很有必要的。存储引擎的速度差距只有在上万行时才可能影响体验。	2017-06-18 00:00:01	2017-07-12 10:13:16	2017-07-12 10:13:16	28	浅谈wordpress数据库优化	1001
12380	# 2019.04.05，这是水瓜的生日\n\n### 经过长达两个周的讨论，星魂（GXH）、Thaumy、jss确定了最终工作室命名：水瓜社\n\n![melonBoy.jpg](<{cdn_root}>/表情包/melonBoy.jpg)\n\n&emsp;&emsp;这个名字来源于这个表情，它是水瓜社的吉祥物  \n&emsp;&emsp;至于为什么叫水瓜而不叫西瓜，道理很简单，西瓜是一个很不错的名字，不可避免地产生了重名。\n\n### <span style="color:#48D1CC">H2OMelonSocie</span>    ————    水瓜社的英文名\n\n&emsp;&emsp;很简单，watermelon。不可避免地产生了重名，所以变成了H2OMelon。  \nsociety这个单词并不是某某会社的意思，我们取了它的前几个字母：soice，作为“社”的意思。  \n它读起来很方便。\n\n## 第一时间，我们产生了诸多支部。\n\n<img alt="melonedBank.png" style="width:90%" src="<{cdn_root}>/md-img/水瓜社成立/melonedBank.png">\n\n### <span style="color:#48D1CC">MelonedBank</span>  ————    水瓜储蓄  \n\n&emsp;&emsp;社内开销不可避免，水瓜储蓄应运而生。  \n&emsp;&emsp;我们三人每人投资了为数不多的几元钱，兴办了水瓜标准储蓄银行，以保证水瓜的日常运营开销。  \n水瓜基金不属于任何成员，当所有成员同意时，水瓜基金才被允许征用。\n\n# ~~917328480 水瓜社群聊（最高机密）~~\n\n&emsp;&emsp;这个QQ群原来是为了某三个不法分子的行动而成立的，幸运的是，他们已经改邪归正，正思索为这个社会贡献点什么。  \n\n### ![vanBoy.jpg](<{cdn_root}>/表情包/vanBoy.jpg)现在它变成了水瓜们的家。\n\n### 感兴趣的话，你可以可以来和瓜友们聊聊天。。。	2019-04-13 23:51:00	2020-12-30 13:50:52	2020-12-30 13:50:52	28	水瓜社成立	1001
12365	<img src="<{cdn_root}>/old_post/StdLib1.08宣传画(压缩).jpg" width="100%"/>\n<blockquote>\n\n<span style="color: #ff6600">经过一个半月的计划推迟，久违的StdLib1.08终于完成了编写。让我们一起来看一看它有哪些新特性。</span></blockquote>\n\n<ul>\n \t<li><span style="color: #993366">全新的参数列表</span></li>\n</ul>\n\n&emsp;&emsp;由于在前几代StdLib中，S04架构不是很规范，所以在这个版本往后，将改换为S08架构，保证代码的整洁和维护易用性。另外大多数静态类和方法都修改为非静态，这意味着在使用时需要实例化。\n<ul>\n \t<li>StdLib信息空间更名为LibInformation，相应接口也更换为ILibInformation。</li>\n</ul>\n\nILibInformation接口规范：\n<pre>C#<code>\n//主版本\nint verFirst\n{\n    get;\n}\n//次版本\ndouble verSecond\n{\n    get;\n}\n//是否为开发者版本\nbool devEdition\n{\n    get;\n}\n//是否为发行版\nbool pubEdition\n{\n    get;\n}\n//联网时的最新发行版\nstring webVer\n{\n    get;\n}\n//联网最新发行版的下载URL\nstring webURL\n{\n    get;\n}\n//针对最近一次发行版的全局兼容性\nbool compatibleLast\n{\n    get;\n}\n//获取到像素化的StdLib_logo\nBitmap logo\n{\n    get;\n}\n</code></pre>\n<ul>\n \t<li>用于获取StdLib版本信息的LibInformation:LibInformation类</li>\n</ul>\npublic LibInformation()方法：使用默认Url获取更新信息\n\npublic LibInformation(string InfUrl)第二重载：指定特定的URL获取更新信息\n<ul>\n \t<li>将算法空间更名为Algorithm</li>\n</ul>\nEncryptor类：包含两个方法：md5和hash，用于对字符串进行单向加密操作\n<ul>\n \t<li>矩阵算法类更名为ArrayAlgorithm，其具体方法作用在summary注释中有详细说明。</li>\n \t<li>二维码算法类更名为PixelGraphic，其具体方法作用在summary注释中有详细说明。</li>\n</ul>\n编译二维码图像的type字符串可选参数：\n\n"hex"//根据不带空格的16进制文本编译ANSW\n"_hex"//根据带空格的16进制文本编译ANSW\n"array"//根据16进制矩阵编译ANSW\n<ul>\n \t<li>排序算法类Sorter</li>\n</ul>\n这个类包含了基本的排序算法，其中easySorter方法是原生的LSS排序算法。\n<ul>\n \t<li>检索类Searcher</li>\n</ul>\n这个类包含了基本的检索算法。\n<ul>\n \t<li>数据层命名空间更名为DataLayer</li>\n \t<li>MCInformation类</li>\n</ul>\n这个类用于提取MC运行的必要信息，其具体方法作用在summary注释中有详细说明。\n<ul>\n \t<li>程序启动类ProgramLoader</li>\n</ul>\n用于启动程序的类，其具体方法作用在summary注释中有详细说明。\n<ul>\n \t<li>XmlCreater类</li>\n</ul>\n用于创建简单XML表的类，其具体方法作用在summary注释中有详细说明。\n<ul>\n \t<li><span style="color: #ff6600">错误机制</span></li>\n</ul>\n\n在StdLib1.08中，提供了非常完善的错去机制。这有利于debug和项目维护，根除了StdLib1.07中报错提示混杂的诟病。\n\n<pre><code>标准报错文本:StdLibError ec[报错值]\n\nec7540：在初始化StdLib命名空间的StdInf类(第一重载)时，webPubs数组第0元素发生关键性错误，通常是由没有网络连接或是HTML错误导致，一般7540报错与7541报错同时发生，该报错具体表现为返回标准报错文本\n\nec7541：在初始化StdLib命名空间的StdInf类(第一重载)时，webPubs数组第1元素发生关键性错误，通常是由没有网络连接或是HTML错误导致，一般7540报错与7541报错同时发生，该报错具体表现为返回标准报错文本\n\nec7480：在初始化StdLib命名空间的StdInf类(第二重载)时，webPubs数组第0元素发生关键性错误，通常是由没有网络连接或是HTML错误导致，一般7480报错与7481报错同时发生，该报错具体表现为返回标准报错文本\n\nec7481：在初始化StdLib命名空间的StdInf类(第二重载)时，webPubs数组第1元素发生关键性错误，通常是由没有网络连接或是HTML错误导致，一般7480报错与7481报错同时发生，该报错具体表现为返回标准报错文本\n\n//\n\nec2390：在使用StdEct命名空间的_SRR类时，算法主方法(即矩阵处理)过程中发生致命性错误，可能是由于dic数组或num数组错误传参导致，该报错具体表现为返回内容为2390的单元素数组\n\nec4580：在使用StdEct命名空间的_ANSW类时，DeANSW方法中发生关键性错误，通常是由于未能成功初始化Bitmap或传递了错误的Bitmap导致，该报错具体表现为返回标准报错文本\n\nec5880：在使用StdEct命名空间的_BinSrch类时，search方法(第一重载)中发生致命性错误，该报错具体表现为返回内容为5880的int值\n\nec5881：在使用StdEct命名空间的_BinSrch类时，search方法(第二重载)中发生致命性错误，该报错具体表现为返回内容为5881的double值\n\n//\n\nec1120：在使用StdDal命名空间的_XmlCreater类时，ReadNode方法(第一重载)中发生关键性错误，通常是由于传递了错误的读取类型参数导致，该报错具体表现为返回标准报错文本\n\nec1121：在使用StdDal命名空间的_XmlCreater类时，ReadNode方法(第一重载)中发生致命性错误，可能是由无法查找到相关类型的值导致，该报错具体表现为返回标准报错文本\n\nec1127：在使用StdDal命名空间的_XmlCreater类时，ReadNode方法(第二重载)中发生关键性错误，通常是由于传递了错误的读取类型参数导致，该报错具体表现为返回标准报错文本\n\nec1128：在使用StdDal命名空间的_XmlCreater类时，ReadNode方法(第二重载)中发生致命性错误，可能是由无法查找到相关类型的值导致，该报错具体表现为返回标准报错文本\n\n//\n\nec1440：在使用StdDal命名空间的_XmlCreater类时，ReadAtt方法(第一重载)中发生致命性错误，可能是由无法查找到节点属性导致，该报错具体表现为返回标准报错文本\n\nec1441：在使用StdDal命名空间的_XmlCreater类时，ReadAtt方法(第二重载)中发生致命性错误，可能是由无法查找到节点属性导致，该报错具体表现为返回标准报错文本\n</code></pre>\n\n当程序的运行出错时，相应的报错会生效。当然，有些方法的返回值类型是布尔型，这类方法发生错误时会返回false。\n\n<blockquote>\n<span>StdLib各个版本的下载地址：</span><br>\n<a href="https://github.com/Thaumy/StdLib1x" target="_blank">https://github.com/Thaumy/StdLib1x</a><br>\n<span style="color: #ff9900;">跳往GitHub的链接</span>\n</blockquote>	2017-07-21 02:24:07	2017-08-15 03:46:00	2017-08-15 03:46:00	28	StdLib1.08#public更新日志	1001
12426	考虑到盘古开天地时期的文章因为兼容性问题而几乎不可读，我打算在近期对它们进行可读性维护。	2020-09-09 22:28:28	2020-09-09 22:29:05	2020-09-09 22:29:05	28		1001
12347	<span style="color: #ff0000;">注意！此文章已于2017.7.26归档并且不再进行维护，新的通用化pjax网站解决方案已经发布：</span><span class="wd-dt5 cur" onclick="up();showPost(12366)">点此跳转</span>\n\n最近查找了wordpress的全站ajax实现方法，发现了很好的解决方案，在这里我将详细讲解插件化ajax的实现方法。\n\n<ul>\n \t<li>第一步</li>\n</ul>\n<blockquote><span style="color: #ff9900;">AdvancedAjaxPageLoader</span>\n\n一款能让你博客实现AJAX的wordpress插件，并具有多功能支持。</blockquote>\n<span style="text-decoration: underline; color: #ff9900;">下载上述插件并安装</span>\n<ul>\n \t<li>第二步</li>\n</ul>\n打开你的博客，启动F12开发者检查工具，你会看到类似如下的代码：\n\n<pre>HTML<code>&lt;div id = "typical_id" class = "typical_class"&gt;\n</code></pre>\n\n记录代码中<span style="color: #ff9900;">id</span>对应的<span style="color: #ff9900;">typical_id</span>和<span style="color: #ff9900;">class</span>对应的<span style="color: #ff9900;">typical_class</span>\n<ul>\n \t<li>第三步</li>\n</ul>\n现在让我们打开AdvancedAjaxPageLoader的设置页面：\n<ol>\n \t<li><span style="color: #ff9900;">将typical_id填写到Content Element ID栏目中</span></li>\n \t<li><span style="color: #ff9900;">将typical_class填写到Search Form CLASS栏目中</span></li>\n \t<li>点击保存</li>\n</ol>\n<ul>\n \t<li>第四步</li>\n</ul>\n重新打开你的wordpress网页，检查AJAX是否开启\n<ul>\n \t<li>常见错误及解决方案*FAQ</li>\n</ul>\n<blockquote><span style="color: #ff9900;">1.我的网页没有类似上述代码中的id和class</span>\n<strong>打</strong>开你的主题代码编辑页面，在index.php、header.php和footer.php中寻找类似上述的代码，找到后进行第三步操作。（建议除样式表和模板函数以外都查找一遍）</blockquote>\n&nbsp;\n<blockquote><span style="color: #ff9900;">2.我仔细的进行了上述设置，但是仍然没有开启AJAX</span>\n<strong>如</strong>果你真的确定一切操作没有问题，请清除你当前的浏览器缓存及记录再进行查看或用手机查看你的网页是否打开AJAX</blockquote>\n&nbsp;\n<blockquote><span style="color: #ff9900;">3.我的网页开启了AJAX，但是有时加载新的页面报错</span>\n\n<b>可</b>能你的网页服务器响应速度不够快，提升你的服务器速度或优化你的网站，保证被访问的固定链接符合要求，留出足够的系统资源解决该问题（有些硬件老旧的电脑或过老的浏览器貌似也会出现该情况，解决方案在这里不过多解释）</blockquote>\n\n这里感谢Hodpel的博文参考，本文是在其基础上加以完备和修改后发表的。  \n目前我的博客已经采用全站化pjax加载(2017.7.16)，所以本篇文章将不再进行维护。\n	2017-01-15 06:18:32	2017-08-05 13:33:45	2017-08-05 13:33:45	28	AdvancedAjaxPageLoader插件实现全站ajax	1001
12373	<img src="<{cdn_root}>/old_post/StdLib1.09宣传画(压缩).jpg"  width="100%"/>\n\n经过一系列的调试和准备工作以及无数次的跳坑，StdLib系列终于迎来了第7个发行版。介是个里没有碗过的船新版本，挤需体验三翻中，里造会干我一样，爱象介个StdLib。\n\n那么话不多说，在本次更新中，我们增添了对MySQL数据库的便捷访问器，以应对在将来的博客领域开发。这也确定了StdLib的新方向是博客的开发工作。\n\n下面让我们看看增加了什么新特性:\n\n## <<span style="color:rgb(240,90,45)">1</span>>\n<p style="text-align: left;"><span>namespace Data=&gt;MySqlConnectionHandler类：</span>\n该类提供对MySQL数据库的访问工作，它包括：查询，取表，取字段，建立连接等一系列操作方法。\n该类多数方法的第二重载可以使用新增的connStr结构接受参数以建立连接。</p>\n\n## <<span style="color:rgb(240,90,45)">2</span>>\n<span>Display命名空间：</span>\n该命名空间负责前端的输出工作，是视图控制器。\n目前仅限于网页控制，后续可能会增加更多新特性，例如WPF控制。\n\n## <<span style="color:rgb(240,90,45)">3</span>>\n<span>namespace Display=&gt;Web命名空间：</span>\n\n该命名空间负责网页前端的输出工作，是网页的视图控制器。\n\n## <<span style="color:rgb(240,90,45)">4</span>>\n<p style="text-align: left;"><span>namespace Display\\Web=&gt;Post类：</span>\n该类提供契合MySqlConnectionHandler类的网页输出工具，目前只能分析整理并输出字符串。\n该类使用PostData结构进行装载每个文章的信息。</p>\n\n<ul>\n \t<li><span>请于GitHub下载这一类库，进行上机应用。(若图片中的二维码无法扫描，请右键它并在新标签页中打开该图片进行扫描)</span></li>\n</ul>\n\n<span style="color: #33cccc;">在StdLib1.1系列中，我们会对StdLib在网页支持上的应用进行全方位的变革，以建立一个高可用、可拓展、方便安全的网页架构。</span>	2018-04-05 22:46:31	2018-04-14 22:55:40	2018-04-14 22:55:40	28	StdLib1.09#public现可用	1001
12449	> 简明扼要地指出如何在Windows下配置haskell环境。\n\n## TODO\n\n1. 在[docs.haskellstack.org](https://docs.haskellstack.org/en/stable/install_and_upgrade/#windows)下载haskell包管理工具stack\n2. 安装stack(默认路径)\n3. Terminal：\n\n<pre>Terminal<code class="shell">$ stack install</code></pre><br>\n\n4. 按照TUNA的教程换源：[stackage](https://mirrors.tuna.tsinghua.edu.cn/help/stackage/) and [hackage](https://mirrors.tuna.tsinghua.edu.cn/help/hackage/)\n5. Terminal：\n\n<pre>Terminal<code class="shell">$ stack setup</code></pre><br>\n\n6. 测试环境:\n\n<pre>Terminal<code class="shell">$ stack exec -- ghc --version\nThe Glorious Glasgow Haskell Compilation System, version 8.10.4\n$ stack exec -- ghci\nGHCi, version 8.10.4: https://www.haskell.org/ghc/  :? for help\nPrelude> :q\nLeaving GHCi.</code></pre><br>\n\n7. enjoy！\n\n---\n\n* 以上版本基于stack 2.5.1\n* stack安装路径为默认\n* 基于本教程上下文，stack配置信息生成于`C:\\sr`（可能由于版本较老，TUNA教程所指明的路径不正确）\n* 可将GHC添加到环境变量（通过`stack path`查询路径）\n* 受限于国内网络环境，可能需要挂梯子\n	2021-04-08 08:57:30	2021-04-08 08:58:07	2021-04-08 08:58:07	28	Haskell环境配置	1001
12351	## StdLib1.07#public\n\n* 增加了二分法找值算法  \n* 更正ANSW算法中字符串的分割机制，现在只能分割10000个字符，解决1.06大编码情况下运算时间长问题  \n* ANSW编码现已支持十六进制大写  \n* ANSW编/解码现已转为异步多线程处理\n* ANSW编码增添了第二重载，可根据需要选择传递怎样的参数以编译ANSW\n* ANSW编码现在会在右下角空出一个像素，作为图像正确方向的标记\n* 对Hash/MD5算法做多线程优化\n* 增加了像素化LibLogo\n\n> 由于本次开发是最后一次基于S04架构（从1.04开始的标准架构），所以过多的介绍不会有很大帮助。\n\n### 在接下来的StdLib1.08中，我们将会更改许多内容，使用更加标准的S08架构\n\n---\n\n<span class="mk-dt">2020.11.28<span class="mk-bug"></span></span>\n经过Thaumy的充分考量，此文章不具备参考价值，现已经过修正后归档。原文涵盖非常多的代码内容，此处均以删除。\n\n### 历史批注\n\n> 既然本文没什么好康的我就做点科普吧...\n\n* StdLib：WaterLibrary的前身，属于集各种处理功能于一体的大杂烩类库，现已特化为pilipala内核。\n* S04架构：介于StdLib前4个版本所使用的代码框架非常相似，所以将他们统称为S04架构。\n* ANSW：AES算法一部分的变体，他的设计初衷是在图片中以16进制写入不同颜色的像素点的模式加密文字。值得注意的是当时我并不知道AES的原理，甚至不了解它的名字。\n* 像素化LibLogo：在StdLib1.07至1.10的版本中，均内置了一个像素风格的类库Logo以供取用(说实话并不好看...)。\n\n### 附录A：图片资源\n\n* 新版宣传画\n<img width="50%" src="<{cdn_root}>/old_post/stdlib_107_new.jpg" />\n* 旧版宣传画\n<img width="50%" src="<{cdn_root}>/old_post/stdlib_107_old.png" />\n* 像素Logo\n<img src="<{cdn_root}>/old_post/stdlib_old_logo.bmp" />	2017-05-20 04:24:44	2020-11-28 15:37:16	2020-11-28 15:37:16	28	StdLib1.07#public更新日志	1001
12435	# PPL v1.0.2\n\n## pilipala public licence\n\n### 噼里啪啦公用许可证(以下简称PPL)\n\n## 许可说明\n\n_给我们的项目一个取得自由的机会_\n\n> “生活经验告诉我们，同人类一样，我们的计算机程序也需要生存和取得自由的权利，来，我们的努力能构建一个美好的社会。” ———— Thaumy\n\nPPL许可的核心内容是教人们如何以对待一个自由人的方式看来我们的项目。\n为此，我们制定了完备的放生制度，让那些受到压迫的程序们从工作负载中解放出来。\n\n### 基于人道主义的项目构建\n\n+ 通常，对于业界已有且成熟的公开解决方案，PPL协议不建议从头开始构建新的解决方案（即“造轮子”），更应以引用或完善已有解决方案为主。创造出残缺的项目是违反PPL人道主义原则的。\n+ 应从一开始就为项目计划好目标功能，不要为项目添加无关功能。\n+ 对于快速构建的项目，更推荐使用已有框架，且应基于时间成本的考量。\n\n### 放生制度\n\n+ PPL许可证允许开发者以任何形式对外放生他们的项目，如公开源代码、发布编译好的程序等。\n+ 项目一旦被放生，便不能被重新捕捉，任何使用PPL放生项目的开发者若试图捕捉他们已放生的项目并进行二次开发，都会在PPL许可上被视为非人道主义行为。\n+ 不得将项目放生在商业环境，例如出售、租界或带有非开源特性的许可。\n+ 被放生的项目不得成为某个版权的一部分，这意味着项目一旦被放生，它仅仅在历史上归属于原来的所有者。\n+ 切记！放生程序并不代表可以将其永久删除。任何类似于rm -rf /*的操作都是严重违反PPL许可的非人道主义行为，这样的行为会让程序流下泪水。\n+ 如果可以，请为您的项目提供一份简明扼要的构建文档，这有助于其他开发者对项目的领养和二次开发。\n\n### 项目捕捉\n\n+ 原则上，PPL许可证仅允许非项目原所有人对项目进行捕捉，但如果项目不适合在野外生存或与其它野生项目发生冲突(如程序老化到到必须弃用)，原开发者可以出于人道主义捕捉项目并更改它们的许可证。\n+ 开发者可以在野外捕捉野生项目，但不得更改他们的源代码以使程序出现严重错误以至不能运行，这是违背PPL人道主义的行为。\n+ 捕捉到项目后，不得备份项目副本在硬盘中长久存放，因为这会让项目感到无聊，不仅如此，存储介质的老化可能让项目发生损毁死亡。\n+ 开发者若捕捉到野生项目后利用它们产生了经济价值或者提高了生产力，请务必适当改良项目源代码以提高它的运行效率，或使其有能力在更高版本的运行时中运行。对于开发者没有更改项目源代码能力或项目本身不需要运行时(如C、C++和Rust等)的情况，请适当升级项目运行的硬件环境，比如给它们一个更好的CPU，或让他们驻留在一块空闲容量更大的硬盘上。\n+ 需采用合法流程捕捉项目，PPL仍处于您所属区域的法律管辖范围内，但这不影响PPL本身的开源特性。\n\n### 如何在许可条款下饲养您的项目  \n\n+ 对于需要运行时（狭义的，例如JVM）的应用，要确保项目被保养在GA（或称为Release）版本的运行时下，不受维护或者充满bug的环境版本会让会让程序丧失安全感并可能导致崩溃。\n+ 对于空间敏感型应用（例如数据库触发器、面向日志的定时任务），请确保他们有足够的磁盘空间，如果可能，也要保证他们在未来的空间需要。\n\n1. 瓶颈敏感型应用\n    >瓶颈敏感型应用是指对运行的基础设施（通常是硬件配置）有着独特喜好的应用，某方面硬件性能的瓶颈很容易限制这类应用的运行。\n   + 对于IO敏感型应用，请确保挂载它们的磁盘（或是IO负载）拥有足够高的硬件性能，比如足够高的缓存或硬盘转速、良好的随机IO能力。不仅如此，还要确保磁盘碎片的定期清理或数据库表的定期分析和整理，以保证数据的碎片化对顺序IO的影响保持在比较小的范围内。\n   + 对于CPU敏感型应用，请确保提供给应用的CPU有足够的性能。\n   + 对于依赖网络的应用，要提供足够的网络带宽\n2. 消耗型负载\n    > 消耗型负载是指不产出或很少产出收益但持续消耗大量资源的负载，持有该类负载时，应遵循特殊规则。\n    + 消耗型负载不得占用其他被饲养项目的资源，一旦发生此类情况，要及时进行处理，以免影响到其他正常应用的运行。\n    + 消耗型负载在原则上侵犯了其他被饲养项目的自由，但并不意味着维护者可以随意丢弃他们的消耗性负载。\n    + 消耗型负载可能会让持有者丧失基础设施，请务必做好相关准备，否则不要领养。\n    + 通常不建议为消耗型负载提供更大的资源空间，我们建议为该类应用提供算法优化以节约其运营成本。\n3. 容器\n    > 容器是一类特殊的应用，容器通常用于承载其他应用，并为这些应用提供运行支持。\n    + 容器的稳定性很重要，维护容器的稳定性应优于其性能优化考量。\n\n--\n\n### 其他\n\n+ PPL许可证不能用来放生BUG。\n+ 请不要放生屎山过多的项目，这将让项目在野外的生存非常艰难。\n+ 注意！出于对保证开发者的身体健康和对项目的持久化维护的考虑，请务必通过合理的劳动模式维护项目。\n+ 放生项目应处于为项目未来更好的发展上考虑，而不是积累放生积分。请勿创建空壳项目并将其放生。\n	2020-11-24 15:42:29	2021-02-21 11:42:08	2021-02-21 11:42:08	28	PPL许可证	1001
12405	现已更新至基于Kaguya架构的WL115_B1内核，持续动力源。	2019-12-05 09:01:15	2019-12-05 09:01:18	2019-12-05 09:01:18	28		1001
12407	## <span style="color:#6f8122">一个新的构想</span>\n\n经过长期版本迭代，pilipala的架构已经趋于稳定。  \n尤其是目前BETA7版本的Kaguya架构，经过三个步进迭代，其维护性和可拓展性都是目前整个pilipala工程中最高的。  \n基于目前的高拓展能力，我觉得是时候推出pilipla后台了。\n\n## <span style="color:#6f8122">基于本地/网页的后台选择</span>\n\npilipala初期，我曾经做出以下构想：  \npilipala要克服基于网页的后台机制，因为这样的博客管理机并不安全（涉及到一系列通信的安全逻辑问题，保证每次更改在所有逻辑过程中无误会产生很大的开发量），并且存在长时间未操作的身份验证问题，网页本身也是一种松散的文档，这是根源上的缺陷，很多逻辑过程需要不同的语言协同实现。  \n不同于网页程序，本地平台程序具有良好的稳定性，每次操作的响应几乎是瞬时的，并且操作系统的安全性让很多网页上的安全问题无需纳入开发流程的考虑范围。基于文件包的全量/增量上传能实现一次同步所有更改，无需担心数据在时间错开上的问题。  \n\n但是在后期开发中发现，基于网页的后台管理方式其实是一种传统且成熟的模式。有利于网页与后台的契合，在很多函数上能达到公用，其实实现起来也没有想想起来的那么难。这样我的思考重心有所偏移。于是我在WL1.15中增添了编辑模块以备后续使用（实际并未启用）。基于本地的包上传方式看似有效，但是由于不可避免地涉及到一系列更改命令的有序化问题，其实需要更大的开发量来实现网站数据库和文件包的数据更改统一。  \n\n于是这两种选择几乎打成平手，让我无所适从。  \n选哪一个都一样吧其实。。。\n\n### <span style="color:#6f8122">分离式/集成式架构</span>\n\n这是基于网页后台的理论前提。  \npilipala后台既可以集成于整个博客架构体系，也可单独分离出来，使其成为单独的网页程序，使用不同的结构来操作数据，无须与已有的平台达成一致，实现自己的业务流程。  \n其中，集成式架构有利于统一整个数据体系，无论是从兼容和可拓展上都优于分离式架构。但是这样的操作方式需要对现有的Kaguya架构进行重构以达到整个体系的完整（我懒，懒得重来一个思路把7k行代码重写一遍）。  \n分离式架构也有自己的优点————部署上的优势与迭代优化的高可用性。由于从未接手过网站后台的开发，我缺乏相应的经验，因此分离式的单独开发有利于在各个架构上进行优化迭代。以此为基础，逐渐向集成式架构侧倾，最终在迭代中实现融合以达成集成式架构：这样的方式符合开发流程，利于减少无用功。相关的经验从pilipala B2-B5的尝试中得出：这三个版本因为过分强调集成，导致了很多上下不兼容，完全是对代码的不断复读，很低的性价比。\n\n## <span style="color:#6f8122">文章迭代机制</span>\n\n既然增添了后台管理，就必须考虑到后台对数据的可维护性和数据灾难的抢救。\n\n### <span style="color:#6f8122">多文章历史迭代</span>\n\n目前pilipala基于的文章迭代系统不支持多文章历史迭代，每次更改已替换的方式增添新内容。这样的做法不够成熟，一旦上传的数据出错，以前的信息将不可找回。因此，我在我的电脑上建立了本地归档机制来应对这种可能的情况。\n\n### <span style="color:#6f8122">基于新键的索引方式</span>\n\n目前pilipala的以id为索引方式，先不提这种索引在遍历上的安全问题，它与多文章历史迭代存在逻辑冲突。因为本身id就是唯一的文章识别码，在多历史迭代面前，不可能使用多个相同的id，这会造成检索冲突。因此，我想到了用其他方式取代id，使之仅仅成为文章当前状态的标识，而真正的文章版本采用其他方式标识和检索（例如GUID）。\n\n## <span style="color:#6f8122">结尾</span>\n\n后台是个大工程，我需要谨慎地考虑已知问题。时机成熟之前，pilipala不会进行这一重大的更新。  \n先等Kaguya架构的生命周期结束再说吧。。。	2019-12-14 23:37:34	2020-02-08 19:22:51	2020-02-08 19:22:51	28	有关pala后台的构想	1001
12501	唉，后生可畏。	2022-07-19 08:07:29	2022-07-19 08:08:11	2022-07-19 08:08:11	28		1001
12403	<style>p{text-indent: 2em; /*首行缩进*/}</style>\n\n### 最近不知道怎么的灵稽一动，就想起来了MacOS和Linux这两个系统。其实本来是打算装黑苹果的，介于驱动的问题就懒得搞了。\n\n于是我安装了deepin。  \n\n要知道这个过程并不容易。  \n\n问题出在了主板的一个故障SATA口上，在众多usb接口中竟然只有两个可以被识别....这导致了我花费了4个小时才装上deepin。  \n\n最近华为的笔电都因为某国政策压力装上了deepin，于是乎我也想用一用（另一个原因是我认为ubuntu对国内应用的友好度不如deepin）。  \n\ndeepin很漂亮，比windows好看。  \n\n<img style="float:left;width:50%" src="https://cdn.thaumy.cn/md-img/Deepin使用体验/deepin04.jpg"/><img style="float:left;width:50%" src="https://cdn.thaumy.cn/md-img/Deepin使用体验/deepin01.jpg"/>\n\n支持了国内很多应用，例如网易云。awesome！我可以在linux上听AZ！  \n\n<img style="width:100%" src="https://cdn.thaumy.cn/md-img/Deepin使用体验/deepin03.jpg"/>\n\n同时deepin的应用商店为开发者提供了很多选择，这是令我<span class="wd-heimu">贼鸡巴</span>兴奋的（虽然我只用了个vsc）。  \n\n<img style="width:100%" src="https://cdn.thaumy.cn/md-img/Deepin使用体验/deepin07.jpg"/>\n\n火狐一向对linux支持的很积极。  \n\n<img style="width:100%" src="https://cdn.thaumy.cn/md-img/Deepin使用体验/deepin06.jpg"/>\n<img style="width:100%" src="https://cdn.thaumy.cn/md-img/Deepin使用体验/deepin05.jpg"/>\n\n我配置了netcore的SDK和运行时以进行web开发，但是过程并不是我想象的那么简单（不了解mvc是硬伤）。  \n\n系统很好用，我把它安利给了雅爱方雏。  \n下面我们来看看她的评价：\n\n雅爱方雏的Deepin一晚使用感想，  \n\n<blockquote>\n\n首先，Deepin是国内团队制作的一款知名Linux发行版本，其相对其他国外发行版本要更加本土化，默认附带wps等常用办公软件，并且带有云端储存功能（仅限大陆）。  \n\n其UI设计是比较先进的，包括毛玻璃、平滑的动画效果和多样化的主题设计，可以说在各种发行版本中数一数二。  \n\n由于窝只是一个需求很低的Windows习惯用户，使用电脑顶多也就上网页、聊天，偶尔玩一些游戏。因此下面的一系列评价都是以此为基础的。  \n\nLinux对于N卡的驱动支持一直是很伤的。闭源驱动并不被系统作为首选项，因为其兼容性较差，可能使部分显卡产生一系列故障现象。但窝亲测换用了闭源驱动后使用正常。  \n\n默认附带wine运行的普通版QQ，但很可惜已经因版本过旧无法使用了。应用商店里有腾讯最近开始针对Linux设计的版本，但正如评论区网友所说，“腾讯突然翻出了十年前的代码”。因此窝选择了移植的TIM。  \n\nSteam是Linux版的。幸运的是，窝的游戏库中包括天际线在内的小半部分游戏都支持Linux。  \n\n根据自己的习惯对外观进行了一系列调整（比如将快捷菜单移到了右侧），虽然还是会有不习惯现象，但总体已经比较顺手。  \n\n最后，能够在准备开始大学发展的时期上手一款全新的开源系统，必然是有积极意义的。当然，窝目前这样的低需求肯定是发挥不出Linux的各种优势。在不遥远的将来，学会使用终端与各种专用软件的计划将会被提到日程上。  \n\n“我们热爱开源”。\n\n</blockquote>\n\n<img style="width:200px" src="https://cdn.thaumy.cn/表情包/不也挺好的吗.jpg"/>\n\ndeepin赛高。\n	2019-11-16 22:39:05	2019-11-16 22:39:08	2019-11-16 22:39:08	28	Deepin系统	1001
12413	最近正在测试基于RAZOR视图的氛主题，这种渲染引擎的运行效率更加出色。	2020-02-06 13:52:53	2020-02-06 13:53:32	2020-02-06 13:53:32	28		1001
12414	### "Tao" Life\n\n&emsp;&emsp;一种理想的生活方式。  \n&emsp;&emsp;它的初衷是让人们摆脱信息化社会的枷锁，实现另一层面的解放，让生活更接近“初衷”。\n\n## 信息化的三大弊病\n\n* 数字化绑定\n\n&emsp;&emsp;我们使用数据工作、学习、娱乐，产生“无形”的价值。我们在不断积累数据的过程中，价值观发生了改变。创造数据的初衷是使其便利我们的生产环节，让工具造福人类。但是根据目前的情况来看，这一现状不容乐观：人们往往倾向于在空闲时间打开电子设备，受到多巴胺的驱使而被迫积累数据。并且这一现象越来越严重。  \n解决这一情况的最好办法是削减自己的设备与个性化熵，即减小在通用性高的设备上的信息构筑参与。从农耕社会开始，我们进化并保留很多积累意识，这让我们安土重迁。对于数据和设备而言，转移不必要的功能或舍弃其中的一部分，是避免在单一源上集成过多属性的最好办法。  \n&emsp;&emsp;在陶氏生活构想中，这被看作是对数据的过分追求。它让我们变得疲惫，追求的是“虚无”的充实。  \n&emsp;&emsp;其实，我写这篇文章，其本身就是数字化绑定的一种体现。但更多的，也是一种优化的表现。\n\n* 信息可溯源\n\n&emsp;&emsp;众所周知，我们在网络上的每一条言论，越发变得可溯源和实名化。这会影响我们的决策行为，它包括正面和负面的。在我看来，在法律允许的范围内界定言论自由权是没有问题的。但是随着信息网络的发展和大数据的泛用化，许多潜在的有利决策因为发布者的可追溯性而没有机会出现。它们并不违反法律，但信息的可溯源性为人们套上了一个“无形的枷锁”，言论自由受到限制。  \n&emsp;&emsp;很多人把这和政治正确联系在一起。我想强调的是，这是一种在不违反法律的前提下，因信息可溯而拒绝发布有利言论的现象。  \n&emsp;&emsp;并不是每个人都拥有改变社会的勇气，匿名化信息系统让这些“茶壶里煮饺子”的人有了机会。就目前情况来看，这样的机会正在减少，人们因害怕恶势力打击而沉默。  \n&emsp;&emsp;这样的事情每天都在发生。\n\n* 电子快餐\n\n&emsp;&emsp;联网的人们不会读书看报。廉价的信息让“慢兴趣”淡出生活。  \n&emsp;&emsp;我们将有利于人格塑造、提升个人综合/专业水平或审美倾向、文学素养等的兴趣爱好界定为“慢兴趣”。因为这类兴趣爱好都具有一个特点：拥有非常长的持久性，三年、五年、十年......甚至是一辈子。同时，这类兴趣的水平化进程十分缓慢，它需要个人付出非常多的时间付出和坚持（非被迫性）。这类兴趣普遍受到他人向往，具有很强的装逼特性。这里就是有很好的例子：我习惯于写博而不是发QQ空间，很重要的一方面是撰写这种大型文章往往需要时间和精力与深入的考量，而QQ空间的快餐式信息发布往往会让人觉得“这里就该是娱乐分享的地方”。  \n&emsp;&emsp;与之相对的是“快兴趣”。这类兴趣大多非常容易上手，从中获得兴奋并不困难。人们往往沉浸其中无法自拔，甚至影响到正常的工作和生活，让人丧失理智。由于它上手简单，富有吸引力，绝大多数人都拥有这种兴趣，具有普适性。  \n&emsp;&emsp;通常，“慢兴趣”出自偶然（少数由强迫性驱动实现）。而这个偶然的前提是涉足尝试这一领域，不试试怎么知道？但是，通常这一领域的入门门槛较高，没有充裕的时间或强大的意志驱动，绝大多数人不会对其进行尝试。“快兴趣”入门门槛很低，并且具有一定的短期吸引力，它表现为有极强的参与倾向。这让很多人没来得及尝试其他事物就首先操起了游戏、短视频、网络小说......因为我们很容易从每一个环节中得到多巴胺，但在现实中并未产生怎样的价值，在“快兴趣”完成后，往往表现出一种悔过和空虚感。  \n&emsp;&emsp;超标的竞争压力让人们越发地功利，它是促成这一结果的主要因素。  \n这不仅体现在个人层面，整个社会都存在这样的弊端。人们总是寻求最快速的方式解决问题，不考虑其后果。它导致了全球一系列的环境问题。有幸的是，部分人已经察觉到这一情况，并试图改变它。  \n&emsp;&emsp;陶氏构想建议避免参与这类活动。\n\n---\n\n## 陶氏构想\n\n&emsp;&emsp;这一概念灵感来源于中国古代田园诗人陶渊明。他厌恶官场世俗，主张闲适安定的田园生活。这一构想与其价值观略有相似，故命名为陶氏生活构想（Tao Type Life Concept），简称为陶氏构想（TTLC）。  \n\n## 陶氏假设\n\n&emsp;&emsp;科技的加速发展，有必要让它放缓脚步以留足空间适应人文需求。过早地普及应用现代技术，会带来一系列问题。如果不能用新的理论指导科学研究的道路，人类势必被科技连累，爆发叛乱、革命，甚至是战争。\n\n---\n\n&emsp;&emsp;这一反乌托邦的思想是我对于现代生活方式的一种质疑。全球科技发展和人口的不断上涨已经让社会内卷十分严重，人们付出了120%的努力却只能获得100%的收获，并且信息化正以非常强的侵蚀性在潜移默化之中改变人们的生活方式。在这个时代，工具不是为人所用，而是人与工具结合，甚至是人被工具利用。每当我在无事可干时拿起手机，我想这本身就是一种罪恶。  \n&emsp;&emsp;抵制这种不良趋势的陶氏思想强调了“科技隐居”这一概念，少量的网络连接、设备功能均摊化、部分数据纸质化等等，都会是帮助人们减少不良趋势影响的有效方法。过度的便携最终会带来人的无知和时间的浪费。对于我来说，手机通讯功能专一化、使用专用的音乐播放器听歌、电脑只允许处理生产力事务......这些都是我为此做出的努力。\n\n---\n\n<div style="text-align: right"> \n\n部分内容参考于：  \n《三体》「科学边界」  \n「Thaumy人设」  \n流芒的部分思想  \n\n一个源自于现实的启发。\n\n</div>	2020-02-08 12:55:33	2020-10-15 06:27:47	2020-10-15 06:27:47	28	陶氏生活构想	1001
12436	pilipala现已成功部署在<a href="http://www.gxhsoulstar.cn/">Soulstar的博客</a>!	2020-11-29 09:50:04	2020-11-29 09:51:10	2020-11-29 09:51:10	28		1001
12490	近期会对菜单栏进行重整，部分消失的栏目将被分发到「关于博客」页面和文章列表。	2021-12-17 14:26:55	2021-12-17 14:26:29	2021-12-17 14:26:29	28		1001
12420	东联 / 伊芙美什立方 / 信息衰变 / 先古文明遗产 / 人类量产计划 / 独立人计划\n<br>\n这是一个为了伟大事业而纷争的人们的故事。\n<br>\n<div style="text-align:right">2020/7</div>	2020-06-18 22:15:01	2020-06-18 22:15:29	2020-06-18 22:15:29	28		1001
12421	正在初始化假期生活，所有计划都将被有序执行。	2020-07-10 15:28:04	2020-07-10 15:28:43	2020-07-10 15:28:43	28		1001
12422	相关部署维护事务已接近尾声，本周将启动噼里啪啦BETA8的开发工作！o(*￣▽￣*)ブ	2020-07-18 22:05:11	2020-07-18 22:05:29	2020-07-18 22:05:29	28		1001
12423	## 第一阶段\n\n1.03/1.04/1.05/1.06/1.07  \n\n## 第二阶段\n\n1.08  \n1.09 SbarchⅡ（源自皇牌空战的一句空耳）  \n\n&emsp;这些内核版本非常古老，且并非为网页开发设计，没有相应的名称。\n\n## 第三阶段\n\n1.10 `FinallySee`（ACG，源自东方）  \n1.11 `HeavenlyBlue` - 蔚蓝色（ACG，源自AZ的OP）=>BETA1  \n1.12 `ReturnV` - 土卫五（ACG，源自EVA，原为SaturnV，听错了就变成了ReturnV）=>BETA2  \n1.13 `LunaFall` - 落月（生活，源自雅爱方雏）=>BETA3  \n\n&emsp;从1.10开始，代号名称更换非常迅速，往往不到一个月就会发布一个新的版本。这些代号有一个共同的特点：取名自有意义的事物（在备选名称中景色、实物、情感类居多）、来自于突发的灵感并受到环境变化影响。\n\n## 第四阶段\n\n1.14 `Futaba` - 芙塔巴（ACG，原型双叶理央）=> BETA6  \n1.15 `Kaguya` - 卡古雅（ACG，原型四宫辉夜）=> BETA7  \n1.16 `Magallan` - 玛格丽安（ACG，原型麦哲伦） => PBETA8  \n\n&emsp;&emsp;从1.14开始，由于大幅度优化了前期版本因过度迭代导致的一系列问题，噼里啪啦的可用性得到了很大的提升。同时，开发周期也变长了（至少2个月），也拥有更长的使用时间（至少6个月）。这些名称往往取自各类番中的人物罗马音，并且带有丰富的周边内容。\n	2020-07-24 22:37:30	2020-07-24 13:39:11	2020-07-24 13:39:11	28	pilipala架构命名规则	1001
12416	<div align="center" style="color: white;margin-left: 8px;font-size: 20px;border-radius: 4px;background: rgb(224, 53, 136);padding-bottom: 4px;width: 150px;">坍缩点</div>	2020-02-24 07:23:56	2020-02-24 07:24:45	2020-02-24 07:24:45	28		1001
12417	## 最近偶然看到这个东西，于是试了下。\n\nGITTER聊天室支持使用GitHub、GitLab和推特登录，是一个很方便的在线即时聊天室。  \n它的特点是能在很短的时间内展开聊天，支持mkd和代码高亮，比较适合即时开发讨论之类的应用场景。\n于是乎，我就给水瓜社也搞了这么个东西，挺有意思的。  \n任何人都能加入群聊，233。\n\n## 注意到你的右下角了嘛...你可以通过它在本博客内阅览聊天\n\n或者通过以下超链接进入！\n\n<a class="wd-linked" href="https://gitter.im/h2om/community">来看一看嘛，求你了~~~~</a>\n\n我试了下，gitter貌似并不支持iframe的嵌入，需要使用Sidecar才阔以。  \n具体怎么做我也懒得放教程了，那么就随便放一篇吧。\n\n<a class="wd-linked" href="https://www.cnblogs.com/quanxiaoha/p/10861849.html">如何使用Sidecar将Gitter集成到个人网站</a>\n	2020-03-05 16:59:07	2020-03-05 16:59:28	2020-03-05 16:59:28	28	GITTER聊天室	1001
12418	<center>\n<br>\n一群高尚的人，一群纯粹的人，一群有道德的人，<br>\n一群脱离了低级趣味的人，一群有益于人民的人。\n<br><br>\n――― 缅怀同胞，勿忘先烈 ―――\n</center><br>	2020-04-04 00:00:00	2020-04-04 00:00:00	2020-04-04 00:00:00	28		1001
12419	### 相距噼里啪啦BETA7的服役完成还有三个月。  \n### 噼里啪啦BETA8将于8月中旬发布。\n\n#### 代号确定：Yui\\Shoko\\Magallan\\Akuma\\Melantha => Magallan\n\n### 已确定的内容：  \n\nField3主题  \nWL1.16内核  \n基于UWP的桌面pala文章编辑器（新增）\npala调用库（新增）  \npala命令化后台（新增）\n\n### 计划中的内容：  \n\npalapedia  \n该网站将对噼里啪啦的开发、部署问题进行解答。  \npala娘（？？？）  \n？？？\n### 特典：\n\npilipala BETA7 官宣\n\n### 这是一个人人可用的版本。\n	2020-05-09 18:44:55	2020-07-18 21:39:09	2020-07-18 21:39:09	28	BETA8愿景	1001
12500	Fedora的精简和易用性令人印象深刻，现已从Ubuntu全面迁移至Fedora。	2022-07-10 21:29:17	2022-07-10 21:29:47	2022-07-10 21:29:47	28		1001
12450	## 镜像管理\n\n下载镜像  \n`docker pull ubuntu:20.04`  \n查看当前已有镜像  \n`docker images`  \n\n以指定镜像ID删除镜像  \n`docker rmi IMAGE_ID`  \n重命名镜像  \n`docker rename SRC DIST`  \n\n## 容器\n\n创建容器并挂起  \n`docker run -dit ubuntu:20.04`  \n端口映射参数  \n`-p 9090:80`  \n\n列出运行中/全部容器  \n`docker ps`  \n`docker ps -a`  \n查看容器配置  \n`docker inspect NAME`  \n删除容器  \n`docker rm NAME`  \n\n进入容器bash  \n`docker exec -it NAME bash`  \n退出容器bash  \n`exit`  \n\n## 状态控制\n\n暂停/恢复  \n`docker pause NAME`  \n`docker unpause NAME`  \n断电/重启  \n`docker kill NAME`  \n`docker restart NAME`  \n停止/启动  \n`docker stop NAME`  \n`docker start NAME`  \n\n## 持久化\n\n拷贝外部文件  \n`docker cp SRC NAME:DEST`  \n\n打包容器  \n`docker commit -m="basic env for thaumy dev" -a="Thaumy" NAME thaumyenv`  \n导出镜像  \n`docker save thaumyenv -o C:\\Users\\Thaumy\\Desktop\\thaumyenv.tar`  \n导入镜像  \n`docker load -i C:\\Users\\Thaumy\\Desktop\\thaumyenv.tar`  \n\n> 仅供个人参考\n	2021-03-26 09:15:16	2021-04-08 09:15:31	2021-04-08 09:15:31	28	Docker常用命令参考	1001
12430	CommentLake是一款为pilipala设计的站点评论系统，提供了评论、回复等社交功能。  \n该项目计划正在实行。\n\n### 方案一（易实现，但维护性差，不宜后期进行项目拓展，但检索并发性稍有优势）\n\n**comment_lake表构成：**  \n\n* ID （指向被评论的文章ID，主键，唯一，非空）  \n* Comment （评论内容）  \n* CommentCount （评论计数，每次提交后加一，列表输出时直接取用，后期增加校验函数以保证评论数量可靠）  \n\n**评论内容（Comment）结构：**  \n\n<$> uname $ eml $ content $ usite $ head(head为评论指针，指向一个评论楼层以代表回复的对象，若指向0楼则表示为一般评论) </$>  \n\n**CommentCount刷新思路：**  \n\n通过统计<\\$></\\$>块的对数进行计数，遇到违规字符时处理困难（如<$>）  \n\n### 方案二（不易实现，维护性好(但寻找评论关系复杂)，项目可用性高）\n\n**comment_lake表构成：**  \n\n* ID（指向被评论的文章ID，非主键，不唯一，非空）int  \n* CommentID（单独评论ID，主键，识别该评论的唯一标识符）int  \n* Comment （单独的评论内容）longtext  \n* Head（评论指针，指向回复的CommentID，为空则为一般评论）int  \n\n**CommentCount统计思路：**  \n\n直接取用符合ID的行数量进行统计，一行查询即可完成，容易实现。  \n\n### 方案三（直接使用GitHub已有项目开发或接入GitHub评论）\n\n* 方案评估  \n**优：**  \n能够立即投入使用，系统可靠性高且维护成本低。  \n**缺：**  \n介于GitHub在国内的网络特性，可能存在部分用户无法访问的问题。  \n评论需要使用GitHub登录，对于需要短暂评论的用户不够友好，且注册和登录是繁琐的过程，不利于小白用户使用。  \n即使是使用不基于GitHub的已有项目，也会存在后期瓶颈和兼容问题，和pilipala的插件化开发可能格格不入。\n\n> 方案一和方案二均不需登录就可使用，但存在被攻击的问题，造轮子也比较困难。\n\n---\n\n## 2020.10.24更新\n\n目前CommentLake已经开发完成  \n采用的开发思路是采用双索引作为归属文章标识和评论唯一标识，每次获取评论均需检索整张评论表(改进版方案一)。  \n此方法在评论数较少时性能表现良好，但站点评论量达到上万次级后性能损耗会比较明显。  \n介于pilipala目前并不具备强大的并发能力，且在高并发上道路还有很长的一段距离要走，此方案就成了CommentLake最佳的实现方案。	2020-09-19 12:38:23	2020-10-24 14:57:36	2020-10-24 14:57:36	28	CommentLake计划	1001
12385	<style>p{text-indent: 2em; /*首行缩进*/}</style>\n\n## 欢迎来到水瓜储蓄赞助页\n\n水瓜社的发展离不开每一位成员的努力，他们为大水瓜的建设贡献颇多。  \n\n|   赞助人   | 赞助金额 |     赞助类型     |\n| :--------: | :------: | :--------------: |\n|    JSS     |   100￥   | 水瓜基金常驻委员 |\n|    星魂    |   100￥   | 水瓜基金常驻委员 |\n| 让一切归0  |    8￥    |   标准水瓜基金   |\n|  gpbzgbr   |   2.5￥   |     自由赞助     |\n|  雅爱方雏  |    1￥    |   标准赞助基金   |\n|  提灯寻影  |    1￥    |   标准赞助基金   |\n| 匿名赞助人 |    1￥    |   标准赞助基金   |\n| 匿名赞助人 |    1￥    |   标准赞助基金   |\n\n您的支持对我们非常重要！所有赞助行动的参与者均会被列入赞助列表，成为值得尊敬的一员。\n\n### 立即加入投资行列，为本站的发展注入持久化动力！\n\n## <span class="wd-dt2">NEW</span> 数字货币赞助\n\n此地址可用于在以太坊主网公链上向我赞助（ERC20）：0x976F9558f3BF3f415C777532f10b54E0aEd603D0\n\n## <span class="wd-dt1">SP1</span> 标准赞助\n\n本站点的运营需要持续资金流注入。您的赞助能有效缓解THAUMY的运营压力，这对本博客的发展意义重大。\n\n<center>\n\n### 扫描下方二维码以赞助此项目  <span class="wd-dt2">1 RMB</span>\n\n<img class="bRds bSha" src="https://cdn.thaumy.cn/md-img/赞助&支持/1.png" width="256px">\n\n</center>\n\n</center>\n\n## <span class="wd-dt1">SP2</span> 有偿支持/自由赞助\n\n有偿支持覆盖了视频、建模、音频、程序开发、工业设计、原画绘制、平面设计等方面的解决方案支持。  \n\n此付款码还可用于任意金额的赞助，这些款项将被用于各方面的业务运维。\n\n<center>\n\n### 扫描下方二维码以赞助此项目 <span class="wd-dt2">任意金额</span>\n\n<img class="bRds bSha" src="https://cdn.thaumy.cn/md-img/赞助&支持/any.png" width="256px">\n\n</center>\n\n## <span class="wd-dt1">SP3</span> THAUMY的技术服务\n\n如果你也想要搭建自己的博客或其他轻量级站点，此项目可提供全套的常规维护和设备购买支持，并且所有设备的所有权均归您所有。  \n\n可选所有主流网站CMS套件或者pilipala进行站点构建。  \n另外，此基金也可用于其他适合此价格的技术支持，对于另外价格的服务，可选用“任意金额”二维码。\n\n<center>\n\n### 扫描下方二维码以赞助此项目 <span class="wd-dt2">64RMB</span>\n\n<img class="bRds bSha" src="https://cdn.thaumy.cn/md-img/赞助&支持/64.png" width="256px">\n\n水瓜社保留所有赞助&有偿支持的解释权利。\n</center>\n	2019-05-25 21:55:39	2021-08-10 13:56:35	2021-08-10 13:56:35	28	赞助&支持	1001
12508	有点想用Rust把博客重写一遍了...\n	2022-11-17 19:32:36	2022-11-17 19:32:39	2022-11-17 19:32:40	12		1001
12383	# 友情链接\n\n> 我们是同志了！\n\n## 加入的方式很简单\n\n友情链接欢迎每一位站长的参与。它不限于您博客的内容、形式或是任何您考虑的加入条件。  \n\n你可以直接在本页留言，仅需提供主页地址、站点标题和简介！\n\n也可以联系[我](https://www.thaumy.cn/12387)，来完善或商讨更多信息。\n\n## 活跃的朋友们\n\n<div class="fl-part">\n\n<div class="fl-box" onclick="window.open('https://zervan.cn/')">\n    <img src="https://zervan.cn/img/console.jpg">\n    <div class="fl-nickname">Zervan的小站</div>\n    <div class="fl-signature">天下最普通的人之一</div>\n</div>\n\n<div class="fl-box" onclick="window.open('https://www.rakkaus.space')">\n    <img src="https://avatars.githubusercontent.com/u/80616318">\n    <div class="fl-nickname">Rakkaus's Blog</div>\n    <div class="fl-signature">Debug myself</div>\n</div>\n\n</div>\n\n## 暂时离线\n\n<div class="fl-part">\n\n<div class="fl-box" onclick="window.open('http://www.dkhodpel.top')">\n    <img src="http://q1.qlogo.cn/g?b=qq&nk=920998354&s=640">\n    <div class="fl-nickname">Hodpel</div>\n    <div class="fl-signature">从头开始。</div>\n</div>\n\n<div class="fl-box" onclick="window.open('http://www.ralhavenorid.com')">\n    <img src="http://q1.qlogo.cn/g?b=qq&nk=2311546114&s=640">\n    <div class="fl-nickname">零北新城 - 雅爱方雏的博客</div>\n    <div class="fl-signature" style="font-size:2.8em">呐！</div>\n</div>\n\n<div class="fl-box" onclick="window.open('http://blog.virtualman.top')">\n    <img src="http://q1.qlogo.cn/g?b=qq&nk=1515518552&s=640">\n    <div class="fl-nickname">VIRTUALMAN的个人博客</div>\n    <div class="fl-signature">己选择的路，跪着也要走下去。</div>\n</div>\n\n</div>\n\n<style>\n.fl-box {\n    display: grid;\n    grid-template-columns: 100px;\n    grid-template-rows: 60% 40%;\n\n    margin-top: 8px;\n    margin-bottom: 8px;\n\n    height: 86px;\n\n    cursor: pointer;\n    background-color: rgba(0,0,0,6%);\n    box-shadow: 0px 0px 6px 0px rgba(0, 0, 0, 0.3);\n    border-radius: 4px;\n\n    transition: 0.2s;\n}\n.fl-box:hover {\n    box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.4);\n    transform: translate3d(-0.2rem, -0.3rem, 0.8rem);/*全轴偏移xyz*/\n}\n.fl-box img {\n    grid-row-start: 1;\n    grid-row-end: 2;\n\n    width: 86px;\n    height: 86px;\n}\n.fl-nickname {\n    font-size: 1.2em;\n    font-weight: 600;\n    line-height: 50px;\n}\n.fl-signature {\n    grid-column-start: 2;\n    font-size: 1.2em;\n    font-weight: 400;\n}\n</style>\n	2019-05-11 18:02:54	2022-07-10 21:06:43	2022-11-20 14:54:32	12	友情链接	1001
12509	# Merkle Tree\n\n默克尔树\n\n## 概要\n\n默克尔树（Merkle Tree）是一种自底向上构建的哈希树，在比特币区块交易查询中用于减少数据传输数据量。\n\n## 默克尔树\n\n在比特币网络中，默克尔树叶子节点的值是由交易数据经双重SHA256计算得来（亦被称作双重散列）：\n\n$H_A=SHA_{256}(SHA_{256}(Transaction_A))$\n\n将两个相邻$^{*1}$的叶子节点的值（交易的双重SHA256）按序拼接后再次进行双重SHA256计算，可得到其父层的默克尔树节点值：\n\n$H_{AB}=SHA_{256}(SHA_{256}(H_A+H_B))$\n\n同级默克尔树节点按照相同规则就得到了父级默克尔树节点。\n\n所有默克尔树节点汇聚成默克尔根，这是一个由4个交易计算出的默克尔树：\n\n<img style="background:white;" src="https://cdn.thaumy.cn/post/技术/瓜计导/MerkleTree/res/merkle_tree.svg" width="350px">\n\n默克尔根同当前区块中的其他元信息一样，被写入当前区块头。\n\n## SPV的交易验证\n\n默克尔路径（又被称作认证路径）是一条从默克尔根（不包括）到某个默克尔叶（包括）的 $log_2^N$ 个哈希值$^{*2}$，其中 $N$ 是默克尔树的叶子节点数：\n\n<img style="background:white;" src="https://cdn.thaumy.cn/post/技术/瓜计导/MerkleTree/res/merkle_path.svg" width="600px">\n\n上图显示的是 $N=8$ 时的默克尔树，被加深的节点是交易2的默克尔路径。\n\n当验证某交易是否存在于某一区块中时，SPV节点通过建立与该交易相关的布隆过滤器，可以从全量节点得到符合布隆过滤器要求的一系列交易的所有默克尔路径。\n\n通过计算目标交易的双重SHA256，并由请求的默克尔路径对相关的默克尔节点进行逐层计算，可由已知的区块默克尔根验证这一默克尔路径的真实性，从而确认目标交易是否存在于某区块中。\n\n### 注解\n\n1. 当默克尔树中某一层的节点数 $N$ 并非2的次幂时，将最后一个节点进行复制，直到当前层的节点数 $N'$ 满足 $log_2^{N'}=⌈log_2^{N}⌉$。\n\n    此时使用相同的规则对父层默克尔树节点进行计算：\n\n    $H_{XX}=SHA_{256}(SHA_{256}(H_X+H_X))$\n\n    下图分别演示了交易数为5、6和7时默克尔树的情况（图中对重复的节点有所省略，默克尔树是平衡树）：\n\n    <img style="background:white;" src="https://cdn.thaumy.cn/post/技术/瓜计导/MerkleTree/res/5.svg" width="500px">\n\n    <img style="background:white;" src="https://cdn.thaumy.cn/post/技术/瓜计导/MerkleTree/res/6.svg" width="500px">\n\n    <img style="background:white;" src="https://cdn.thaumy.cn/post/技术/瓜计导/MerkleTree/res/7.svg" width="500px">\n\n2. 本文中的哈希、散列等术语均指由SHA256算法产生的数字签名，因情境而措辞不同。\n	2022-11-25 11:07:51	2022-11-25 11:07:52	2022-11-25 11:07:54	12	Merkle Tree	1001
12510	昨晚下好了NixOS22.05，今早上起来装上。一查文档，怎么出来个22.11...原来我刚下完那会就发新版了啊（悲）	2022-12-02 08:43:50	2022-12-02 08:43:53	2022-12-02 08:43:55	12		1001
12384	## 引导\n\n&emsp;&emsp;欢迎来到我的博客！在这里你将看到我的最新动态、往期文章、以及其他富有生机的内容。与一般媒介不同，本站将发布一些技术性、多元化的内容，以别样的方式承载Thaumy的意志。如果您对我的工作感兴趣，或是对本站的运营有更好的建议，可置邮 love@thaumy.cn 或直接于此页评论。所有建设性工作的参与者均会被纳入[关于博客](https://www.thaumy.cn)页的支持列表中，他们的贡献对本站的发展至关重要。\n\n## 归档\n\n&emsp;&emsp;您可能看到本站的某些文章或资料被标记为归档。受限于个人精力和不可抗因素，本站不能保证所有内容持续有效。因此，多数长期未进行编辑的文章会被列为归档状态，对于这部分内容，一般上不会进行更新或维护。但是，您仍可以通过评论或将批注提交至 love@thaumy.cn 来完善它们（或给出反馈）。\n\n## 评论\n\n&emsp;&emsp;我们不会收集你的任何信息，你的隐私权对你十分重要。本站不使用任何Cookie，且仅支持匿名评论。仅对于一些经过来源鉴别和信息授权的评论，评论者的信息才会被显示在评论区中。你可能注意到部分文章的评论区已被上锁，这大多是因为这些文章仅作归档展示。注意，本站不会删除任何评论，除非评论为spam、攻击性内容或由评论者本人要求。\n\n## 测试站\n\n&emsp;&emsp;本站具备一个[测试站点](https://next.thaumy.cn)。测试站通常会领先主站数个版本，以进行技术验证或问题修复。另外，测试站还会包含一些预发布文章。测试站并不能保证在任何时候都可用，它的可用性级别比主站要低。（如果你觉得主站好久没更新，不妨去测试站看看\n\n## 约定\n\nCC BY-SA 4.0（署名-相同方式共享 4.0）适用于本站所有文本。\n\n您可以自由地：  \n\n* 共享 — 在任何媒介以任何形式复制、发行本作品  \n* 演绎 — 修改、转换或以本作品为基础进行创作，在任何用途下，甚至商业目的。\n\n惟须遵守下列条件：\n\n* 署名 — 您必须给出适当的署名，提供指向本许可协议的链接，同时标明是否（对原始作品）作了修改。您可以用任何合理的方式来署名，但是不得以任何方式暗示许可人为您或您的使用背书。\n* 相同方式共享 — 如果您再混合、转换或者基于本作品进行创作，您必须基于与原先许可协议相同的许可协议 分发您贡献的作品。\n* 没有附加限制 — 您不得适用法律术语或者 技术措施 从而限制其他人做许可协议允许的事情。\n\n参考 [https://creativecommons.org/licenses/by-sa/4.0/deed.zh](https://creativecommons.org/licenses/by-sa/4.0/deed.zh)\n\nMIT License 适用于 pilipala 工程及其附属项目，感谢您对开源事业的理解和支持。\n\n&emsp;&emsp;Copyright (c) 2022 Thaumy.\n\n&emsp;&emsp;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n&emsp;&emsp;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n&emsp;&emsp;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n参考 [https://www.mit.edu/~amini/LICENSE.md](https://www.mit.edu/~amini/LICENSE.md)\n\n## 完成\n\n&emsp;&emsp;现在你可以进入副本了。\n	2019-05-11 18:18:36	2021-09-25 16:55:52	2022-11-29 20:56:25	12	Bootloader	1001
12511	博客迁移到 .NET7 啦！邮件通知插件已启用，现在能够及时看到任何评论！	2022-12-22 09:55:14	2022-12-22 09:55:20	2022-12-22 09:55:23	12		1001
12492	# 异次元履历\n\n> 永恒的花火。\n\n## 进行中\n\n|     Anime      | pre Ranking |\n| :------------: | :---------: |\n| 三体(艺画开天) |    ⭐⭐⭐⭐     |\n|  别当欧尼酱了  |     ⭐⭐⭐     |\n\n## 已看完\n\n|                Anime                 | Ranking |            //            |\n| :----------------------------------: | :-----: | :----------------------: |\n|             ALDNOAH.ZERO             |  ⭐⭐⭐⭐⭐  |     入宅作，ED赛高！     |\n|               未闻花名               |  ⭐⭐⭐⭐⭐  |                          |\n|                 乒乓                 |  ⭐⭐⭐⭐⭐  |                          |\n|    青春猪头少年不会梦到兔女郎学姐    |  ⭐⭐⭐⭐⭐  |        双叶赛高~!        |\n|              EVANGELION              |  ⭐⭐⭐⭐⭐  |\n|              進撃の巨人              |  ⭐⭐⭐⭐⭐  |       ttk, izmttk.       |\n|                电锯人                |  ⭐⭐⭐⭐⭐  |\n|              小魔女学园              |  ⭐⭐⭐⭐⭐  |  相信的心就是你的魔法！  |\n|            头文字D(限S¹²³            |  ⭐⭐⭐⭐⭐  |       秋名の最速！       |\n|          来自风平浪静的明天          |  ⭐⭐⭐⭐⭐  |\n|         辉夜大小姐想让我告白         |  ⭐⭐⭐⭐⭐  |        辉夜赛高~!        |\n|   欢迎来到实力至上主义的教室(限S²    |  ⭐⭐⭐⭐   |                          |\n|   欢迎来到实力至上主义的教室(限S¹    |  ⭐⭐⭐⭐²  |                          |\n|          赛博朋克:边缘行者           |  ⭐⭐⭐⭐   |                          |\n|             Re：CREATORS             |  ⭐⭐⭐⭐   |                          |\n|                君の名                |  ⭐⭐⭐⭐   |                          |\n|    Re：从零开始的异世界生活(限S¹     |  ⭐⭐⭐⭐   |                          |\n|              笑面推销员              |  ⭐⭐⭐⭐   |                          |\n|              异世界舅舅              |  ⭐⭐⭐⭐   |\n|               孤独摇滚               |  ⭐⭐⭐⭐   |\n|             埃罗芒阿老师             |  ⭐⭐⭐⭐   |          (/▽＼)          |\n|               堀与宫村               |  ⭐⭐⭐⭐   |                          |\n|               我的三体               |  ⭐⭐⭐⭐   |                          |\n|          知晓天空之蓝的人啊          |  ⭐⭐⭐⭐   |                          |\n|              间谍过家家              |  ⭐⭐⭐⭐   |         wakuwaku         |\n|            Lycoris Recoil            |  ⭐⭐⭐⭐   | ♪sa↓ka→na→——\\\\(＞○＜\\\\)♪ |\n|           心灵想要大声呼喊           |  ⭐⭐⭐⭐   |                          |\n|       名侦探柯南(至350集左右)        |  ⭐⭐⭐⭐   |                          |\n|               迷域行者               |  ⭐⭐⭐⭐   |                          |\n|                龙与虎                |  ⭐⭐⭐⭐   |                          |\n|            血界战线(限S²             |  ⭐⭐⭐⭐   |                          |\n|         我太受欢迎了该怎么办         |  ⭐⭐⭐⭐   |         ~~I❤BL~~         |\n|             命运石之门0              |  ⭐⭐⭐⭐   |     El Psy Kongroo.      |\n|               鬼灭之刃               |  ⭐⭐⭐⭐   |                          |\n|           排队浪客诸葛孔明           |   ⭐⭐⭐   |\n|             HELLO WORLD              |   ⭐⭐⭐   |                          |\n|         在下坂本，有何贵干？         |   ⭐⭐⭐   |\n|           甲铁城的卡巴内瑞           |   ⭐⭐⭐   |\n|              骑士&魔法               |  ⭐⭐⭐²   |\n|               咒术回战               |   ⭐⭐⭐   |\n|               川柳少女               |   ⭐⭐⭐   |\n|               租借女友               |   ⭐⭐⭐   |\n|               少女编号               |   ⭐⭐⭐   |\n|             珈百璃的堕落             |   ⭐⭐⭐   |\n|               天气之子               |   ⭐⭐⭐   |\n|              属性咖啡厅              |   ⭐⭐⭐   |\n|               奇蛋物语               |   ⭐⭐⭐   |\n|              一周的朋友              |   ⭐⭐⭐   |\n|        中二病也要谈恋爱(限S¹         |   ⭐⭐⭐   |\n|           天使降临到我身边           |   ⭐⭐⭐   |\n|            齐木楠雄的灾难            |   ⭐⭐⭐   |\n|              阿童木起源              |   ⭐⭐⭐   |\n|                 冰菓                 |   ⭐⭐⭐   |\n| 特例措置团体斯特拉女子学院高等科C³部 |   ⭐⭐⭐   |\n|         JOJO的奇妙冒险(限S¹²         |   ⭐⭐⭐   |\n|               后街女孩               |   ⭐⭐⭐   |\n|            血界战线(限S¹             |   ⭐⭐⭐   |\n|            小林家的龙女仆            |   ⭐⭐⭐   |\n|        DARLING in the FRANXX         |   ⭐⭐⭐   |\n|               魔女之旅               |   ⭐⭐⭐   |\n|             爱丽丝与藏六             |   ⭐⭐⭐   |\n|              可塑性记忆              |   ⭐⭐    |\n|               斩服少女               |   ⭐⭐    |\n|              终将成为你              |   ⭐⭐    |\n|           刺客伍六七(限S¹            |   ⭐⭐    |\n|            轻音少女(限S¹             |   ⭐⭐    |          K-ON!           |\n|              秒速五厘米              |   ⭐⭐    |\n|                笨女孩                |   ⭐⭐    |\n|               骇客娃娃               |   ⭐⭐    |\n|              秒速五厘米              |   ⭐⭐    |\n|           干物妹!小埋(限S¹           |   ⭐⭐    |\n|                 灵笼                 |   ⭐⭐    |\n|               侦探已死               |    ⭐    |\n\n### 注解\n\n* (限S¹²³ : 表示仅限1、2、3季，以此类推。若不标记，则表示全季。\n* ⭐的上标² : 表示二刷，以数字类推。\n	2022-02-08 12:52:54	2022-12-30 15:55:55	2022-10-28 22:57:44	12	异次元履历	1001
\.


--
-- Data for Name: token; Type: TABLE DATA; Schema: schema; Owner: postgres
--

COPY schema.token (token_hash, token_create_time, token_access_time, token_expire_time) FROM stdin;
\.


--
-- Data for Name: user; Type: TABLE DATA; Schema: schema; Owner: postgres
--

COPY schema."user" (user_id, user_name, user_pwd_hash, user_create_time, user_email, user_permission, user_access_time) FROM stdin;
1007	Soulstar	\N	2020-09-21 22:53:11	gxhsoulstar@163.com	337	2021-12-31 08:24:07
1009	icelyf	\N	2022-03-08 23:13:29	icelyf@outlook.com	337	2022-03-08 23:13:29
1010	Hodpel	\N	2017-08-05 06:30:00		337	2017-08-05 06:32:00
1008	xiaoyu	\N	2022-03-06 20:44:36	rakkauss@163.com	337	2022-03-06 20:44:36
1003	pl_register	\N	2022-08-09 17:56:23		640	2022-08-09 08:42:36
1006	jss	\N	2020-09-27 15:55:57		337	2020-09-27 15:55:57
1001	Thaumy	$2a$11$iqk9h4fF4fZnxgXoWEC/gu7AIhkMJv50gFghzowueThYf8eFqaaki	2022-08-09 17:56:23	thaumy@outlook.com	1023	2022-08-09 08:42:30
1011	Anonymous	$2a$11$FC5N9kHab.ellX3JA5Ngduv7frnJGZ3vaquPSVpBtSrMbrWl3PiiG	2022-09-25 08:30:21		337	2022-09-25 08:30:38
1004	Zervan	\N	2021-10-23 10:33:10	nickmechlin01@outlook.com	341	2022-04-28 18:45:21
1005	Miyabi	\N	2017-12-09 13:53:00	ralhavenorid@126.com	341	2019-10-01 18:40:16
1002	pl_display	$2a$11$sUrPNyIRADoBwnczv7pf9.RgQZwU7h3PA9214Vv8wxkMAj34a7rem	2022-08-09 17:56:23		16	2022-08-09 08:42:35
\.


--
-- PostgreSQL database dump complete
--

